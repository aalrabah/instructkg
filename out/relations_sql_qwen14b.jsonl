{"A": {"name": "ATTRIBUTE_CLOSURE", "role": "Definition"}, "B": {"name": "FUNCTIONAL_DEPENDENCIES", "role": "Definition"}, "relation": "depends_on", "justification": "Attribute Closure is introduced after Functional Dependencies and relies on the understanding of Functional Dependencies to be meaningful.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0026", "lecture_id": "13-NFs-FDs", "text": "- Functional Dependencies and Keys\n- Inference Rules of Functional Dependencies\n- Attribute Closure\n- Closure of a Set of FDs"}, {"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0031", "lecture_id": "13-NFs-FDs", "text": "-  Functional Dependencies and Keys\n- Inference Rules of Functional Dependencies\n- Attribute Closure\n- Closure of a Set of FDs"}, {"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0036", "lecture_id": "13-NFs-FDs", "text": "-  Functional Dependencies and Keys\n-  Inference Rules of Functional Dependencies\n- Attribute Closure\n- Closure of a Set of FDs"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 7, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 7 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0003"}, "A_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0026"}, "gap_lectures": 0}}}
{"A": {"name": "ACID_PROPERTIES", "role": "Definition"}, "B": {"name": "ISOLATION_LEVELS", "role": "Definition"}, "relation": null, "justification": "The provided evidence does not clearly indicate a dependency or part_of relationship between ACID properties and isolation levels. Both concepts are discussed in the context of transaction management but do not imply one depends on the other or that one is a part of the other.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0002", "lecture_id": "19-Trxn-Mgmt", "text": "- Describe transactions, ACID properties and issues related to concurrent exaction of transactions.\n- Describe how database systems implement isolation levels"}, {"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0003", "lecture_id": "19-Trxn-Mgmt", "text": "- Transactions and ACID properties\n- Transactions in SQL\n- Isolation levels\n- Isolation Levels and Locking"}, {"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0016", "lecture_id": "19-Trxn-Mgmt", "text": "-  Transactions and ACID properties\n- Transactions in SQL\n- Isolation levels\n- Isolation Levels and Locking"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 6, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 6 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0002"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0002"}, "gap_lectures": 0}}}
{"A": {"name": "ACID_PROPERTIES", "role": "Definition"}, "B": {"name": "TRANSACTIONS", "role": "Definition"}, "relation": "part_of", "justification": "ACID properties are described as characteristics of transactions, indicating that ACID properties are a component of the broader concept of transactions.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0002", "lecture_id": "19-Trxn-Mgmt", "text": "- Describe transactions, ACID properties and issues related to concurrent exaction of transactions.\n- Describe how database systems implement isolation levels"}, {"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0003", "lecture_id": "19-Trxn-Mgmt", "text": "- Transactions and ACID properties\n- Transactions in SQL\n- Isolation levels\n- Isolation Levels and Locking"}, {"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0016", "lecture_id": "19-Trxn-Mgmt", "text": "-  Transactions and ACID properties\n- Transactions in SQL\n- Isolation levels\n- Isolation Levels and Locking"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 6, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 6 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0000"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0002"}, "gap_lectures": 8}}}
{"A": {"name": "ISOLATION_LEVELS", "role": "Definition"}, "B": {"name": "TRANSACTIONS", "role": "Definition"}, "relation": "depends_on", "justification": "The evidence shows that isolation levels are described in the context of transactions, indicating that understanding transactions is a prerequisite for understanding isolation levels.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0002", "lecture_id": "19-Trxn-Mgmt", "text": "- Describe transactions, ACID properties and issues related to concurrent exaction of transactions.\n- Describe how database systems implement isolation levels"}, {"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0003", "lecture_id": "19-Trxn-Mgmt", "text": "- Transactions and ACID properties\n- Transactions in SQL\n- Isolation levels\n- Isolation Levels and Locking"}, {"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0016", "lecture_id": "19-Trxn-Mgmt", "text": "-  Transactions and ACID properties\n- Transactions in SQL\n- Isolation levels\n- Isolation Levels and Locking"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 6, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 6 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0000"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0002"}, "gap_lectures": 8}}}
{"A": {"name": "ACID_PROPERTIES", "role": "Definition"}, "B": {"name": "SQL_TRANSACTIONS", "role": "NA"}, "relation": "part_of", "justification": "ACID properties are a specific set of characteristics that transactions in SQL must adhere to, making them a component of the broader concept of SQL transactions.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0003", "lecture_id": "19-Trxn-Mgmt", "text": "- Transactions and ACID properties\n- Transactions in SQL\n- Isolation levels\n- Isolation Levels and Locking"}, {"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0016", "lecture_id": "19-Trxn-Mgmt", "text": "-  Transactions and ACID properties\n- Transactions in SQL\n- Isolation levels\n- Isolation Levels and Locking"}, {"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0025", "lecture_id": "19-Trxn-Mgmt", "text": "-  Transactions and ACID properties\n-  Transactions in SQL\n- Isolation levels\n- Isolation Levels and Locking"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 5, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 5 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0003"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0002"}, "gap_lectures": 0}}}
{"A": {"name": "DATABASE_SYSTEMS", "role": "Definition"}, "B": {"name": "STORAGE_STRUCTURES", "role": "NA"}, "relation": "depends_on", "justification": "Storage structures are foundational components that underpin the functionality of database systems. The evidence suggests that understanding storage structures is a prerequisite for comprehending database systems.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0001", "lecture_id": "19-Trxn-Mgmt", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0000", "lecture_id": "20-Trxn-Serializability", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}, {"source": "chunk_co_occurrence", "chunk_id": "5- SQL4-AggGrpViews__0000", "lecture_id": "5- SQL4-AggGrpViews", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems\n工"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 5, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 5 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0001"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0020"}, "gap_lectures": -9}}}
{"A": {"name": "DATABASE_SYSTEMS", "role": "Definition"}, "B": {"name": "TRANSACTION_MANAGEMENT", "role": "NA"}, "relation": "depends_on", "justification": "Transaction Management is a specific topic within Database Systems that builds upon the foundational concepts of the relational model and other database principles. It is introduced later in the course, indicating a dependency on earlier material.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0001", "lecture_id": "19-Trxn-Mgmt", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0000", "lecture_id": "20-Trxn-Serializability", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}, {"source": "chunk_co_occurrence", "chunk_id": "5- SQL4-AggGrpViews__0000", "lecture_id": "5- SQL4-AggGrpViews", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems\n工"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 5, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 5 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0001"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0020"}, "gap_lectures": -9}}}
{"A": {"name": "FOREIGN_KEYS", "role": "Definition"}, "B": {"name": "KEYS", "role": "Definition"}, "relation": "part_of", "justification": "FOREIGN_KEYS are a specific type of key within the broader concept of KEYS in the context of relational database models.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "1-RelationalModel__0006", "lecture_id": "1-RelationalModel", "text": "Src: Wikipedia\n-  Data Models\n- Relational Database Model\n- Basic Concepts and Terminology\n- Keys and Foreign Keys\n- Schema Specifications"}, {"source": "chunk_co_occurrence", "chunk_id": "1-RelationalModel__0012", "lecture_id": "1-RelationalModel", "text": "The intension of the table\n101, Owner = J. Smith. 101, Balance = 1000.00. 101, Type = checking. 102, Owner = W. Wei. 102, Balance = 2000.00. 102, Type = checking. 103, Owner = J. Smith. 103, Balance = 5000.00. 103, Type = savings. 104, Owner = M. Jones. 104, Balance = 1000.00. 104, Type = checking. 105, Owner = H. Martin. 105, Balance = 10,000.00. 105, Type = checking\nThe extension of the table.  Also called the extent .\n, Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. Cardinality, Number = 102. Cardinality, Owner = W. Wei. Cardinality, Balance = 2000.00. Cardinality, Type = checking. of this instance is 5 (because, Number = 103. of this instance is 5 (because, Owner = J. Smith. of this instance is 5 (because, Balance = 5000.00. of this instance is 5 (because, Type = savings. there are 5, Number = 104. there are 5, Owner = M. Jones. there are 5, Balance = 1000.00. there are 5, Type = checking. rows), Number = 105. rows), Owner = H. Martin. rows), Balance = 10,000.00. rows), Type = checking\n-  Data Models\n- Relational Database Model\n-  Basic Concepts and Terminology\n- Keys and Foreign Keys\n- Schema Specifications"}, {"source": "chunk_co_occurrence", "chunk_id": "1-RelationalModel__0015", "lecture_id": "1-RelationalModel", "text": ", Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. , Number = 102. , Owner = W. Wei. , Balance = 2000.00. , Type = checking. , Number = 103. , Owner = J. Smith. , Balance = 5000.00. , Type = savings. , Number = 104. , Owner = M. Jones. , Balance = 1000.00. , Type = checking. , Number = 105. , Owner = H. Martin. , Balance = 10,000.00. , Type = checking. Deposit, Number = AcctNo Transaction-id. Deposit, Owner = Date. Deposit, Balance = Amount. Deposit, Type = . , Number = 102 1. , Owner = 10/22/00. , Balance = 500.00. , Type = . , Number = 102 2. , Owner = 10/29/00. , Balance = 200.00. , Type = . , Number = 104 3. , Owner = 10/29/00. , Balance = 1000.00. , Type = . , Number = 105 4. , Owner = 11/02/00. , Balance = 10,000.00. , Type = . , Number = 106 5. , Owner = 12/05/00. , Balance = 555.00. , Type = \nWe say that Deposit.AcctNo is a foreign key that references Account.Number.  If the DBMS enforces this constraint, we have referential integrity .\n, Foreign keys might or might not be part of the key for the referring table.Number = 101 102 103 104 105. , Foreign keys might or might not be part of the key for the referring table.Owner = J. Smith W. Wei J. Smith M. Jones H. Martin. , Foreign keys might or might not be part of the key for the referring table.Balance = 1000.00 2000.00 5000.00 1000.00 10,000.00. , Foreign keys might or might not be part of the key for the referring table.Type = checking checking savings checking checking. Deposit, Foreign keys might or might not be part of the key for the referring table.Number = AcctNo. Deposit, Foreign keys might or might not be part of the key for the referring table.Owner = Transaction-id. Deposit, Foreign keys might or might not be part of the key for the referring table.Balance = Date. Deposit, Foreign keys might or might not be part of the key for the referring table.Type = Amount. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Number = AcctNo 101 101. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Owner = Check-number 924 925. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Balance = Date 10/23/00 10/24/00. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Type = Amount 125.00 23.98\n-  Data Models\n- Relational Database Model\n-  Basic Concepts and Terminology\n-  Keys and Foreign Keys\n- Schema Specifications"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 5, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 5 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "gap_lectures": 0}}}
{"A": {"name": "ISOLATION_LEVELS", "role": "Definition"}, "B": {"name": "SQL_TRANSACTIONS", "role": "NA"}, "relation": "part_of", "justification": "Isolation levels are a specific aspect or component of SQL transactions, as they pertain to the behavior and interaction of transactions in a database.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0003", "lecture_id": "19-Trxn-Mgmt", "text": "- Transactions and ACID properties\n- Transactions in SQL\n- Isolation levels\n- Isolation Levels and Locking"}, {"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0016", "lecture_id": "19-Trxn-Mgmt", "text": "-  Transactions and ACID properties\n- Transactions in SQL\n- Isolation levels\n- Isolation Levels and Locking"}, {"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0025", "lecture_id": "19-Trxn-Mgmt", "text": "-  Transactions and ACID properties\n-  Transactions in SQL\n- Isolation levels\n- Isolation Levels and Locking"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 5, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 5 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0003"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0002"}, "gap_lectures": 0}}}
{"A": {"name": "READ_OPERATION", "role": "Example"}, "B": {"name": "WRITE_OPERATION", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly establish a 'depends_on' or 'part_of' relationship between READ_OPERATION and WRITE_OPERATION. They co-occur in the context of transaction management but do not imply a prerequisite or component relationship.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0004", "lecture_id": "20-Trxn-Serializability", "text": "Run transactions one at a time, in a series. (Different orders might give different results.)\nREAD(A, t) t := t+100 WRITE(A, t) READ(B, t) t := t+100 WRITE(B,t), T2 = . , T2 = READ(A, s) s := s*2. , T2 = WRITE(A,s). , T2 = READ(B,s). , T2 = s := s*2. , T2 = WRITE(B,s)"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0006", "lecture_id": "20-Trxn-Serializability", "text": "READ(A, t) t := t+100 WRITE(A, t), T2 = READ(A, s) s := s*2 WRITE(A,s). READ(B, t), T2 = . t := t+100 WRITE(B,t), T2 ="}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0014", "lecture_id": "20-Trxn-Serializability", "text": "Two schedules S1 and S2 are view equivalent if:\n- If ௜ reads an initial value of A in S1, then ௜ reads the initial value of A in S2\n- If ௜ reads a value of A written by ௝ in S1, then ௜ reads a value of A written by ௝ in S2\n- If ௜ writes the final value of A in S1, then ௜ writes the final value of A in S2\nA schedule is view serializable if it is view-equivalent to a serial schedule"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 5, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 5 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0004"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0021"}, "gap_lectures": -2}}}
{"A": {"name": "SQL_TRANSACTIONS", "role": "NA"}, "B": {"name": "TRANSACTIONS", "role": "Definition"}, "relation": "part_of", "justification": "SQL_TRANSACTIONS is a specific type of TRANSACTIONS, as evidenced by the co-occurrence and context in the provided chunks.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0003", "lecture_id": "19-Trxn-Mgmt", "text": "- Transactions and ACID properties\n- Transactions in SQL\n- Isolation levels\n- Isolation Levels and Locking"}, {"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0016", "lecture_id": "19-Trxn-Mgmt", "text": "-  Transactions and ACID properties\n- Transactions in SQL\n- Isolation levels\n- Isolation Levels and Locking"}, {"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0025", "lecture_id": "19-Trxn-Mgmt", "text": "-  Transactions and ACID properties\n-  Transactions in SQL\n- Isolation levels\n- Isolation Levels and Locking"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 5, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 5 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0000"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0003"}, "gap_lectures": 8}}}
{"A": {"name": "STORAGE_STRUCTURES", "role": "NA"}, "B": {"name": "TRANSACTION_MANAGEMENT", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly indicate any specific relationship between STORAGE_STRUCTURES and TRANSACTION_MANAGEMENT. The co-occurrence in chunks does not provide enough context to determine if one depends on the other or if one is part of the other.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0001", "lecture_id": "19-Trxn-Mgmt", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0000", "lecture_id": "20-Trxn-Serializability", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}, {"source": "chunk_co_occurrence", "chunk_id": "5- SQL4-AggGrpViews__0000", "lecture_id": "5- SQL4-AggGrpViews", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems\n工"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 5, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 5 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0001"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0001"}, "gap_lectures": 0}}}
{"A": {"name": "ACID_PROPERTIES", "role": "Definition"}, "B": {"name": "LOCKING", "role": "NA"}, "relation": "depends_on", "justification": "The evidence shows that ACID properties and locking are discussed together in the context of isolation levels, suggesting that understanding locking is a prerequisite for fully grasping ACID properties in the context of transaction management.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0003", "lecture_id": "19-Trxn-Mgmt", "text": "- Transactions and ACID properties\n- Transactions in SQL\n- Isolation levels\n- Isolation Levels and Locking"}, {"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0016", "lecture_id": "19-Trxn-Mgmt", "text": "-  Transactions and ACID properties\n- Transactions in SQL\n- Isolation levels\n- Isolation Levels and Locking"}, {"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0025", "lecture_id": "19-Trxn-Mgmt", "text": "-  Transactions and ACID properties\n-  Transactions in SQL\n- Isolation levels\n- Isolation Levels and Locking"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 4, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 4 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0003"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0002"}, "gap_lectures": 0}}}
{"A": {"name": "ATTRIBUTES", "role": "Definition"}, "B": {"name": "KEYS", "role": "Definition"}, "relation": "part_of", "justification": "Both attributes and keys are components of the relational model and are discussed together in the context of tables and entity sets.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0001", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Relational model has:\n- tables (relations) with attributes, keys, foreign keys, domain definitions for attributes"}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0002", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Entities and entity sets with attributes, keys, and domain definitions for attributes\n- Relationships among entities and relationship sets with uniqueness or cardinality constraints"}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0001", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Relational model has:\n- tables (relations) with attributes, keys, foreign keys, domain definitions for attributes"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 4, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 4 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0001"}, "gap_lectures": 4}}}
{"A": {"name": "ATTRIBUTE_CLOSURE", "role": "Definition"}, "B": {"name": "FDS_CLOSURE", "role": "NA"}, "relation": "depends_on", "justification": "Both concepts are introduced together and discussed in the context of functional dependencies, but the evidence suggests that understanding attribute closure is a prerequisite for understanding the closure of a set of FDs.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0026", "lecture_id": "13-NFs-FDs", "text": "- Functional Dependencies and Keys\n- Inference Rules of Functional Dependencies\n- Attribute Closure\n- Closure of a Set of FDs"}, {"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0031", "lecture_id": "13-NFs-FDs", "text": "-  Functional Dependencies and Keys\n- Inference Rules of Functional Dependencies\n- Attribute Closure\n- Closure of a Set of FDs"}, {"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0036", "lecture_id": "13-NFs-FDs", "text": "-  Functional Dependencies and Keys\n-  Inference Rules of Functional Dependencies\n- Attribute Closure\n- Closure of a Set of FDs"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 4, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 4 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0026"}, "A_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0026"}, "gap_lectures": 0}}}
{"A": {"name": "ATTRIBUTE_CLOSURE", "role": "Definition"}, "B": {"name": "INFERENCE_RULES", "role": "Definition"}, "relation": null, "justification": "The provided evidence does not clearly indicate a dependency or part_of relationship between ATTRIBUTE_CLOSURE and INFERENCE_RULES. Both concepts are introduced and discussed together without specifying a hierarchical or prerequisite relationship.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0026", "lecture_id": "13-NFs-FDs", "text": "- Functional Dependencies and Keys\n- Inference Rules of Functional Dependencies\n- Attribute Closure\n- Closure of a Set of FDs"}, {"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0031", "lecture_id": "13-NFs-FDs", "text": "-  Functional Dependencies and Keys\n- Inference Rules of Functional Dependencies\n- Attribute Closure\n- Closure of a Set of FDs"}, {"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0036", "lecture_id": "13-NFs-FDs", "text": "-  Functional Dependencies and Keys\n-  Inference Rules of Functional Dependencies\n- Attribute Closure\n- Closure of a Set of FDs"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 4, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 4 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0026"}, "A_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0026"}, "gap_lectures": 0}}}
{"A": {"name": "CONCEPTUAL_DESIGN", "role": "NA"}, "B": {"name": "ENTITIES_RELATIONSHIPS", "role": "NA"}, "relation": "depends_on", "justification": "The evidence shows that entities and relationships are identified as part of the conceptual design process, indicating that understanding entities and relationships is a prerequisite for conceptual design.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0000", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0000", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0001", "lecture_id": "13-NFs-FDs", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 4, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 4 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "gap_lectures": 0}}}
{"A": {"name": "CONCEPTUAL_DESIGN", "role": "NA"}, "B": {"name": "LOGICAL_DESIGN", "role": "NA"}, "relation": "depends_on", "justification": "The evidence shows that logical design follows conceptual design, indicating that logical design depends on the completion of conceptual design.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0000", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0000", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0001", "lecture_id": "13-NFs-FDs", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 4, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 4 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "gap_lectures": 0}}}
{"A": {"name": "CONCEPTUAL_DESIGN", "role": "NA"}, "B": {"name": "PHYSICAL_DESIGN", "role": "NA"}, "relation": "depends_on", "justification": "Conceptual design is introduced before physical design, and physical design builds upon the schema created in conceptual design.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0000", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0000", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0001", "lecture_id": "13-NFs-FDs", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 4, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 4 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "gap_lectures": 0}}}
{"A": {"name": "CONCEPTUAL_DESIGN", "role": "NA"}, "B": {"name": "RELATIONAL_SCHEMA", "role": "NA"}, "relation": "depends_on", "justification": "Conceptual design (A) involves defining entities and relationships, which are then transformed into a relational schema (B). This indicates that the relational schema depends on the conceptual design as a prerequisite.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0000", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0000", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0001", "lecture_id": "13-NFs-FDs", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 4, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 4 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "gap_lectures": 0}}}
{"A": {"name": "CONCEPTUAL_DESIGN", "role": "NA"}, "B": {"name": "SCHEMA_REFINEMENT", "role": "Definition"}, "relation": "depends_on", "justification": "Conceptual design (A) is a prerequisite step that precedes schema refinement (B) in the database design process. Schema refinement involves checking and refining the relational schema derived from the conceptual design.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0000", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0000", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0001", "lecture_id": "13-NFs-FDs", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 4, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 4 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "gap_lectures": 0}}}
{"A": {"name": "DATABASE_SYSTEMS", "role": "Definition"}, "B": {"name": "QUERY_PROCESSING", "role": "NA"}, "relation": "depends_on", "justification": "Query processing is a fundamental component of database systems, and understanding database systems is necessary before delving into query processing.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0001", "lecture_id": "19-Trxn-Mgmt", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0000", "lecture_id": "20-Trxn-Serializability", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}, {"source": "chunk_co_occurrence", "chunk_id": "7- ConstraintsTriggers__0000", "lecture_id": "7- ConstraintsTriggers", "text": "University of Illinois at Urbana -Champaign CS411: Database Systems\n工"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 4, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 4 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0001"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0020"}, "gap_lectures": -9}}}
{"A": {"name": "ENTITIES_RELATIONSHIPS", "role": "NA"}, "B": {"name": "LOGICAL_DESIGN", "role": "NA"}, "relation": "depends_on", "justification": "Entities and relationships are identified in the conceptual design phase, which is a prerequisite for the logical design phase where the ER design is transformed into a relational schema.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0000", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0000", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0001", "lecture_id": "13-NFs-FDs", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 4, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 4 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "gap_lectures": 0}}}
{"A": {"name": "ENTITIES_RELATIONSHIPS", "role": "NA"}, "B": {"name": "PHYSICAL_DESIGN", "role": "NA"}, "relation": "depends_on", "justification": "The evidence shows that entities and relationships are defined in the conceptual design phase, which precedes the physical design phase. The physical design phase builds upon the logical design, which is based on the conceptual design involving entities and relationships.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0000", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0000", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0001", "lecture_id": "13-NFs-FDs", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 4, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 4 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "gap_lectures": 0}}}
{"A": {"name": "ENTITIES_RELATIONSHIPS", "role": "NA"}, "B": {"name": "RELATIONAL_SCHEMA", "role": "NA"}, "relation": "depends_on", "justification": "The evidence shows that entities and relationships are used to transform ER design into a relational schema, indicating that understanding entities and relationships is a prerequisite for creating a relational schema.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0000", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0000", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0001", "lecture_id": "13-NFs-FDs", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 4, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 4 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "gap_lectures": 0}}}
{"A": {"name": "ENTITIES_RELATIONSHIPS", "role": "NA"}, "B": {"name": "SCHEMA_REFINEMENT", "role": "Definition"}, "relation": "depends_on", "justification": "Entities and relationships are identified in the conceptual design phase, which precedes the logical design phase where schema refinement (normalization) is performed.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0000", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0000", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0001", "lecture_id": "13-NFs-FDs", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 4, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 4 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "gap_lectures": 0}}}
{"A": {"name": "ENTITY_SET", "role": "Definition"}, "B": {"name": "RELATIONSHIP_SET", "role": "Definition"}, "relation": null, "justification": "The evidence does not clearly indicate a dependency or a part_of relationship between ENTITY_SET and RELATIONSHIP_SET. Both concepts are introduced as distinct definitions without implying one depends on the other or that one is a part of the other.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0005", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Entity: Real-world object distinguishable from  other objects. An entity is described using a set of attributes .\n- Entity Set :  A collection of similar entities.  E.g., all employees. (often referred to as just entity, which blurs the distinction between type and collection)\n- Relationship :  Association among 2 or more entities.  E.g., Kristin's home department is Research & Development.\n- Relationship Set :  Collection of similar relationships.  E.g., Home (often referred to as just relationship)\n- Formal definition:\n- if A, B are sets, then a relation R is a subset of A x B\n- A={1,2,3},   B={a,b,c,d}, R = {(1,a), (1,c), (3,b)}\nSame story w/ entity sets sponsor is a subset of Project x Department :"}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0021", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "supporting entity set supporting relationship set\nweak Entity set"}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0005", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Entity: Real-world object distinguishable from  other objects. An entity is described using a set of attributes .\n- Entity Set :  A collection of similar entities.  E.g., all employees. (often referred to as just entity, which blurs the distinction between type and collection)\n- Relationship :  Association among 2 or more entities.  E.g., Kristin's home department is Research & Development.\n- Relationship Set :  Collection of similar relationships.  E.g., Home (often referred to as just relationship)\n- Formal definition:\n- if A, B are sets, then a relation R is a subset of A x B\n- A={1,2,3},   B={a,b,c,d}, R = {(1,a), (1,c), (3,b)}\nSame story w/ entity sets sponsor is a subset of Project x Department :"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 4, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 4 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0005"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0005"}, "gap_lectures": 0}}}
{"A": {"name": "FDS_CLOSURE", "role": "NA"}, "B": {"name": "FUNCTIONAL_DEPENDENCIES", "role": "Definition"}, "relation": "depends_on", "justification": "FDS_CLOSURE is introduced and discussed in the context of Functional Dependencies, indicating that understanding Functional Dependencies is a prerequisite for understanding FDS_CLOSURE.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0026", "lecture_id": "13-NFs-FDs", "text": "- Functional Dependencies and Keys\n- Inference Rules of Functional Dependencies\n- Attribute Closure\n- Closure of a Set of FDs"}, {"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0031", "lecture_id": "13-NFs-FDs", "text": "-  Functional Dependencies and Keys\n- Inference Rules of Functional Dependencies\n- Attribute Closure\n- Closure of a Set of FDs"}, {"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0036", "lecture_id": "13-NFs-FDs", "text": "-  Functional Dependencies and Keys\n-  Inference Rules of Functional Dependencies\n- Attribute Closure\n- Closure of a Set of FDs"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 4, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 4 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0003"}, "A_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0026"}, "gap_lectures": 0}}}
{"A": {"name": "FDS_CLOSURE", "role": "NA"}, "B": {"name": "INFERENCE_RULES", "role": "Definition"}, "relation": "depends_on", "justification": "The evidence shows that both concepts are introduced and discussed together, but the order and context suggest that understanding inference rules is a prerequisite for attribute closure and closure of a set of FDs.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0026", "lecture_id": "13-NFs-FDs", "text": "- Functional Dependencies and Keys\n- Inference Rules of Functional Dependencies\n- Attribute Closure\n- Closure of a Set of FDs"}, {"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0031", "lecture_id": "13-NFs-FDs", "text": "-  Functional Dependencies and Keys\n- Inference Rules of Functional Dependencies\n- Attribute Closure\n- Closure of a Set of FDs"}, {"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0036", "lecture_id": "13-NFs-FDs", "text": "-  Functional Dependencies and Keys\n-  Inference Rules of Functional Dependencies\n- Attribute Closure\n- Closure of a Set of FDs"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 4, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 4 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0026"}, "A_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0026"}, "gap_lectures": 0}}}
{"A": {"name": "FUNCTIONAL_DEPENDENCIES", "role": "Definition"}, "B": {"name": "INFERENCE_RULES", "role": "Definition"}, "relation": "depends_on", "justification": "Functional Dependencies are introduced and explained first, followed by Inference Rules of Functional Dependencies, indicating that Inference Rules depend on the understanding of Functional Dependencies.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0026", "lecture_id": "13-NFs-FDs", "text": "- Functional Dependencies and Keys\n- Inference Rules of Functional Dependencies\n- Attribute Closure\n- Closure of a Set of FDs"}, {"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0031", "lecture_id": "13-NFs-FDs", "text": "-  Functional Dependencies and Keys\n- Inference Rules of Functional Dependencies\n- Attribute Closure\n- Closure of a Set of FDs"}, {"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0036", "lecture_id": "13-NFs-FDs", "text": "-  Functional Dependencies and Keys\n-  Inference Rules of Functional Dependencies\n- Attribute Closure\n- Closure of a Set of FDs"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 4, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 4 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0026"}, "A_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0003"}, "gap_lectures": 0}}}
{"A": {"name": "FUNCTIONAL_DEPENDENCIES", "role": "NA"}, "B": {"name": "MINIMAL_BASIS", "role": "Definition"}, "relation": "depends_on", "justification": "MINIMAL_BASIS is introduced as a concept that relies on the understanding of FUNCTIONAL_DEPENDENCIES, as it describes a specific basis derived from a set of FDs.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "15-NFs-3NF__0007", "lecture_id": "15-NFs-3NF", "text": "Given a set of FDs: F.\nSay the set F ' is equivalent to F, in the sense that F ' can be inferred from F and v. versa.\n- Any such F ' is said to be a basis for F.\n- ' Minimal basis '\n- A basis with all RHS singletons, where any modifications lead to no longer a basis, including:\n- Dropping attribute from LHS of a rule: compact rules\n- Dropping a rule:  small # of rules"}, {"source": "chunk_co_occurrence", "chunk_id": "15-NFs-3NF__0008", "lecture_id": "15-NFs-3NF", "text": "- R(A, B, C) with FDs:\n- A  BC; B  AC; C  AB\n- A basis:\n- A  B; A  C; B  A; B  C; C  A; C  B\n- One minimal basis:\n- A  B\n- B  C\n- C  A"}, {"source": "chunk_co_occurrence", "chunk_id": "15-NFs-3NF__0012", "lecture_id": "15-NFs-3NF", "text": "1. Get a ' minimal basis ' G of given FDs\n2. For each FD A  B in the minimal basis G , use AB as the schema of a new relation.\n3. If none of the schemas from Step 2 is a superkey, add another relation whose schema is a key for the original relation.\nResult will be lossless, will be dependency-preserving, 3NF; might not be BCNF\n1. Get a ' minimal basis ' G of given FDs\n2. For each FD A  B in the minimal basis G , use AB as the schema of a new relation.\n3. If none of the schemas from Step 2 is a superkey, add another relation whose schema is a key for the original relation.\nResult will be lossless, will be dependency-preserving, Basically every minimal FD is preserved somewhere Implicitly this is connecting all the LHSs with the remaining attributes"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 4, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 4 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 7, "lecture_id": "15-NFs-3NF", "chunk_id": "15-NFs-3NF__0007"}, "A_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0003"}, "gap_lectures": -1}}}
{"A": {"name": "ISOLATION_LEVELS", "role": "Definition"}, "B": {"name": "LOCKING", "role": "NA"}, "relation": "depends_on", "justification": "The evidence shows that isolation levels are discussed in conjunction with locking, indicating that understanding locking is a prerequisite for understanding isolation levels.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0003", "lecture_id": "19-Trxn-Mgmt", "text": "- Transactions and ACID properties\n- Transactions in SQL\n- Isolation levels\n- Isolation Levels and Locking"}, {"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0016", "lecture_id": "19-Trxn-Mgmt", "text": "-  Transactions and ACID properties\n- Transactions in SQL\n- Isolation levels\n- Isolation Levels and Locking"}, {"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0025", "lecture_id": "19-Trxn-Mgmt", "text": "-  Transactions and ACID properties\n-  Transactions in SQL\n- Isolation levels\n- Isolation Levels and Locking"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 4, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 4 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0003"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0002"}, "gap_lectures": 0}}}
{"A": {"name": "LOCKING", "role": "NA"}, "B": {"name": "SQL_TRANSACTIONS", "role": "NA"}, "relation": "part_of", "justification": "The evidence shows that locking is discussed within the context of isolation levels and SQL transactions, indicating that locking is a component or aspect of SQL transactions.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0003", "lecture_id": "19-Trxn-Mgmt", "text": "- Transactions and ACID properties\n- Transactions in SQL\n- Isolation levels\n- Isolation Levels and Locking"}, {"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0016", "lecture_id": "19-Trxn-Mgmt", "text": "-  Transactions and ACID properties\n- Transactions in SQL\n- Isolation levels\n- Isolation Levels and Locking"}, {"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0025", "lecture_id": "19-Trxn-Mgmt", "text": "-  Transactions and ACID properties\n-  Transactions in SQL\n- Isolation levels\n- Isolation Levels and Locking"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 4, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 4 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0003"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0003"}, "gap_lectures": 0}}}
{"A": {"name": "LOCKING", "role": "NA"}, "B": {"name": "TRANSACTIONS", "role": "Definition"}, "relation": "depends_on", "justification": "The evidence shows that locking is discussed in the context of isolation levels and transactions, indicating that locking is a mechanism used to ensure the proper execution of transactions. Therefore, understanding transactions is a prerequisite for understanding locking.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0003", "lecture_id": "19-Trxn-Mgmt", "text": "- Transactions and ACID properties\n- Transactions in SQL\n- Isolation levels\n- Isolation Levels and Locking"}, {"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0016", "lecture_id": "19-Trxn-Mgmt", "text": "-  Transactions and ACID properties\n- Transactions in SQL\n- Isolation levels\n- Isolation Levels and Locking"}, {"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0025", "lecture_id": "19-Trxn-Mgmt", "text": "-  Transactions and ACID properties\n-  Transactions in SQL\n- Isolation levels\n- Isolation Levels and Locking"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 4, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 4 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0000"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0003"}, "gap_lectures": 8}}}
{"A": {"name": "LOGICAL_DESIGN", "role": "NA"}, "B": {"name": "PHYSICAL_DESIGN", "role": "NA"}, "relation": "depends_on", "justification": "Logical design transforms ER design to a relational schema and refines it, while physical design considers workloads and selects file types and indexes. The physical design depends on the logical design as a prerequisite.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0000", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0000", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0001", "lecture_id": "13-NFs-FDs", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 4, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 4 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "gap_lectures": 0}}}
{"A": {"name": "LOGICAL_DESIGN", "role": "NA"}, "B": {"name": "RELATIONAL_SCHEMA", "role": "NA"}, "relation": "depends_on", "justification": "The evidence shows that logical design involves transforming ER design into a relational schema, indicating that understanding relational schema is a prerequisite for logical design.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0000", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0000", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0001", "lecture_id": "13-NFs-FDs", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 4, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 4 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "gap_lectures": 0}}}
{"A": {"name": "LOGICAL_DESIGN", "role": "NA"}, "B": {"name": "SCHEMA_REFINEMENT", "role": "Definition"}, "relation": "depends_on", "justification": "Logical design involves transforming an ER design to a relational schema, and schema refinement (normalization) is a subsequent step that builds upon the logical design to eliminate redundancies and anomalies.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0000", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0000", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0001", "lecture_id": "13-NFs-FDs", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 4, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 4 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "gap_lectures": 0}}}
{"A": {"name": "MANY_MANY_RELATIONSHIP", "role": "Definition"}, "B": {"name": "MANY_ONE_RELATIONSHIP", "role": "Definition"}, "relation": "depends_on", "justification": "The evidence suggests that understanding many-one relationships is a prerequisite for understanding many-many relationships, as many-many relationships are a more complex form that builds upon the simpler many-one relationship concept.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0006", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- one-one:\n- many-one:\n- many-many:\nOne on LHS/RHS connected to at most one on RHS/LHS\nOne on LHS connected to at most one on RHS\nNo constraints\n-  Multiplicity can be shown with arrows\n-  Arrow = at most 1"}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0006", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- one-one:\n- many-one:\n- many-many:\nOne on LHS/RHS connected to at most one on RHS/LHS\nOne on LHS connected to at most one on RHS\nNo constraints\n-  Multiplicity can be shown with arrows\n-  Arrow = at most 1"}, {"source": "chunk_co_occurrence", "chunk_id": "PT1-WS1-DBDesign_GCP__0006", "lecture_id": "PT1-WS1-DBDesign_GCP", "text": "- An entity set should satisfy at least one of the following conditions:\n- It is more than the name of something (i.e., it has at least one non-key attribute) Or\n- It is the 'many' in a many-one or many-many relationship.\nExamples will illustrate why, but also think why each of these rules actually make sense.\n\n"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 4, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 4 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0006"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0006"}, "gap_lectures": 0}}}
{"A": {"name": "PHYSICAL_DESIGN", "role": "NA"}, "B": {"name": "RELATIONAL_SCHEMA", "role": "NA"}, "relation": "depends_on", "justification": "The evidence shows that physical database design and tuning come after the transformation of ER design to relational schema, indicating that physical design depends on the relational schema.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0000", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0000", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0001", "lecture_id": "13-NFs-FDs", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 4, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 4 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "gap_lectures": 0}}}
{"A": {"name": "PHYSICAL_DESIGN", "role": "NA"}, "B": {"name": "SCHEMA_REFINEMENT", "role": "Definition"}, "relation": "depends_on", "justification": "Physical Database Design and Tuning appears after Schema Refinement in the logical sequence of database design, indicating that Schema Refinement is a prerequisite for Physical Design.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0000", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0000", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0001", "lecture_id": "13-NFs-FDs", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 4, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 4 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "gap_lectures": 0}}}
{"A": {"name": "QUERY_PROCESSING", "role": "NA"}, "B": {"name": "STORAGE_STRUCTURES", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly indicate a dependency or part_of relationship between QUERY_PROCESSING and STORAGE_STRUCTURES. The co-occurrence in chunks does not provide sufficient context to determine a clear direction of dependency or inclusion.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0001", "lecture_id": "19-Trxn-Mgmt", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0000", "lecture_id": "20-Trxn-Serializability", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}, {"source": "chunk_co_occurrence", "chunk_id": "7- ConstraintsTriggers__0000", "lecture_id": "7- ConstraintsTriggers", "text": "University of Illinois at Urbana -Champaign CS411: Database Systems\n工"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 4, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 4 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0001"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0001"}, "gap_lectures": 0}}}
{"A": {"name": "QUERY_PROCESSING", "role": "NA"}, "B": {"name": "TRANSACTION_MANAGEMENT", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly indicate a dependency or part_of relationship between QUERY_PROCESSING and TRANSACTION_MANAGEMENT. The co-occurrence in chunks does not provide sufficient context to determine a clear prerequisite or component relationship.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0001", "lecture_id": "19-Trxn-Mgmt", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0000", "lecture_id": "20-Trxn-Serializability", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}, {"source": "chunk_co_occurrence", "chunk_id": "7- ConstraintsTriggers__0000", "lecture_id": "7- ConstraintsTriggers", "text": "University of Illinois at Urbana -Champaign CS411: Database Systems\n工"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 4, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 4 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0001"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0001"}, "gap_lectures": 0}}}
{"A": {"name": "READ_COMMITTED", "role": "Definition"}, "B": {"name": "TRANSACTION_ISOLATION", "role": "NA"}, "relation": "part_of", "justification": "READ_COMMITTED is a specific level of transaction isolation, indicating it is a part of the broader concept of transaction isolation.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0027", "lecture_id": "19-Trxn-Mgmt", "text": "- To signal to the system that a dirty read is acceptable,\nSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\n- In addition, there are\nSET TRANSACTION ISOLATION LEVEL READ COMMITTED; SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;"}, {"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0036", "lecture_id": "19-Trxn-Mgmt", "text": "READ UNCOMMITTED allows queries in the transaction to read data without acquiring any lock\n- Access mode READ ONLY, no updates are allowed\nREAD COMMITTED requires a read-lock to be obtained for all tuples touched by queries, but it releases the locks immediately after the read\n- Exclusive locks must be obtained for updates and held to end of transaction"}, {"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0039", "lecture_id": "19-Trxn-Mgmt", "text": "- Suppose we have two transactions:\nT1: SET TRANSACTION READ WRITE ISOLATION LEVEL READ COMMITTED;\nSQL code that translates to: R1(A), R1(B) W1(B) W1(C)\nT2: SET TRANSACTION READ WRITE ISOLATION LEVEL READ COMMITTED;\nSQL code that translates to: R2(C), R2(A) W2(A)\nOne possible interleaved execution of the transactions above:\nR1(A) R2(C) R2(A) W2(A) R1(B) W1(B) W1(C)\nS1(A) R1(A) REL1(A) S2(C) R2(C) REL2(C) S2(A) R2(A) X2(A) W2(A) REL2(A) S1(B) R1(B) X1(B) W1(B) X1(C) W1(C) REL1(B,C)\n37"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 4, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 4 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0013"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0027"}, "gap_lectures": 0}}}
{"A": {"name": "RELATIONAL_SCHEMA", "role": "NA"}, "B": {"name": "SCHEMA_REFINEMENT", "role": "Definition"}, "relation": "depends_on", "justification": "Schema Refinement (B) is a process that follows and depends on the creation of a Relational Schema (A) to refine and optimize it.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0000", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0000", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0001", "lecture_id": "13-NFs-FDs", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 4, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 4 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "gap_lectures": 0}}}
{"A": {"name": "ACCOUNT_NUMBER", "role": "NA"}, "B": {"name": "ACCOUNT_TYPE", "role": "NA"}, "relation": null, "justification": "No decision (LLM output invalid).", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "1-RelationalModel__0013", "lecture_id": "1-RelationalModel", "text": ", Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. , Number = 102. , Owner = W. Wei. , Balance = 2000.00. , Type = checking. , Number = 103. , Owner = J. Smith. , Balance = 5000.00. , Type = savings. , Number = 104. , Owner = M. Jones. , Balance = 1000.00. , Type = checking. , Number = 105. , Owner = H. Martin. , Balance = 10,000.00. , Type = checking. Deposit, Number = AcctNo. Deposit, Owner = Transaction-id. Deposit, Balance = Date. Deposit, Type = Amount. , Number = 102. , Owner = 1. , Balance = 10/22/00. , Type = 500.00. , Number = 102. , Owner = 2. , Balance = 10/29/00. , Type = 200.00. , Number = 104. , Owner = 3. , Balance = 10/29/00. , Type = 1000.00. , Number = 105. , Owner = 4. , Balance = 11/02/00. , Type = 10,000.00. Check, Number = AcctNo. Check, Owner = Check-number. Check, Balance = Date. Check, Type = Amount. , Number = 101. , Owner = 924. , Balance = 10/23/00. , Type = 125.00. , Number = 101. , Owner = 925. , Balance = 10/24/00. , Type = 23.98"}, {"source": "chunk_co_occurrence", "chunk_id": "1-RelationalModel__0017", "lecture_id": "1-RelationalModel", "text": "Account, 1 = Number. Account, 2 = Owner. Account, 3 = Balance. Account, 4 = Type. , 1 = 101. , 2 = J. Smith. , 3 = 1000.00. , 4 = checking. , 1 = 102. , 2 = W. Wei. , 3 = 2000.00. , 4 = checking\n...\nFor every column of every table, the schema specifies allowable values.  For example,\nNumber must be a 3-digit number\nOwner must be a 30-character string\nType must be 'checking' or 'savings'\nThe set of allowable values for a column is called the domain of the column."}, {"source": "chunk_co_occurrence", "chunk_id": "2-SQL-Basics__0005", "lecture_id": "2-SQL-Basics", "text": "Account, 1 = Number. Account, 2 = Owner. Account, 3 = Balance. Account, 4 = T\\pe. , 1 = 101. , 2 = J. Smith. , 3 = 1000.00. , 4 = checking. , 1 = 102. , 2 = W. Wei. , 3 = 2000.00. , 4 = checking. , 1 = 103. , 2 = J. Smith. , 3 = 5000.00. , 4 = savings. , 1 = 104. , 2 = M. Jones. , 3 = 1000.00. , 4 = checking. , 1 = 105. , 2 = H. Martin. , 3 = 10,000.00. , 4 = checking\nSELECT, 1 = Number, Owner. FROM, 1 = Account. WHERE, 1 = T\\pe = \" savings \" ;\nNumber, 1 = Owner\n103\nJ. Smith"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0009"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0013"}, "gap_lectures": 0}, "_error": "Unbalanced JSON braces in output."}}
{"A": {"name": "ASSERTIONS", "role": "Definition"}, "B": {"name": "TRIGGERS", "role": "Definition"}, "relation": null, "justification": "The provided evidence does not clearly indicate a dependency or part_of relationship between Assertions and Triggers. Both concepts are introduced and discussed separately without implying one depends on the other or is a part of the other.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "7- ConstraintsTriggers__0001", "lecture_id": "7- ConstraintsTriggers", "text": "After this lecture, you should be able to:\n- Define Database Constraints, including\n- Referential integrity constraints\n- Attribute -level constraints\n- Tuple -level constraints\n- Assertions\n- Define database triggers\n2\n- Constraints\n- Foreign -key, or referential -integrity constraints.\n- Value -based constraints.\n- Tuple -based constraints.\n- Assertions.\n- Triggers"}, {"source": "chunk_co_occurrence", "chunk_id": "7- ConstraintsTriggers__0019", "lecture_id": "7- ConstraintsTriggers", "text": "- An attribute -based check is checked only when a value for that attribute is inserted or updated.\n- Example: CHECK (price <= 5.00) checks every new price and rejects it if it is more than $5.\n- Example: CHECK (drink IN (SELECT name FROM Drinks)) not checked if a drink is deleted from Drinks or updated (unlike foreign -keys).\n- Only checked during inserts/updates of that attribute\nI ILLINOIS\n- Constraints\n-  Foreign -key, or referential -integrity constraints.\n-  Value -based constraints.\n- Tuple -based constraints.\n- Assertions.\n- Triggers"}, {"source": "chunk_co_occurrence", "chunk_id": "7- ConstraintsTriggers__0023", "lecture_id": "7- ConstraintsTriggers", "text": "- We can do attribute -based check, why tuple level?\n- Reason 1: If the check involves more than one attribute of the tuple, we need the tuple -level check.\n- Reason 2: Tuple -level constraints are checked more frequently.\n- Whenever there are any inserts or updates to any of the concerned attributes\nI\n- Constraints\n-  Foreign -key, or referential -integrity constraints.\n-  Value -based constraints.\n-  Tuple -based constraints.\n- Assertions.\n- Triggers"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 19, "lecture_id": "7- ConstraintsTriggers", "chunk_id": "7- ConstraintsTriggers__0001"}, "A_first_introduced_at": {"lecture_index": 19, "lecture_id": "7- ConstraintsTriggers", "chunk_id": "7- ConstraintsTriggers__0001"}, "gap_lectures": 0}}}
{"A": {"name": "ATTRIBUTE_CLOSURE", "role": "Definition"}, "B": {"name": "KEYS", "role": "NA"}, "relation": "depends_on", "justification": "The evidence shows that Attribute Closure is discussed in the context of Functional Dependencies and Keys, suggesting that understanding Keys is a prerequisite for understanding Attribute Closure.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0031", "lecture_id": "13-NFs-FDs", "text": "-  Functional Dependencies and Keys\n- Inference Rules of Functional Dependencies\n- Attribute Closure\n- Closure of a Set of FDs"}, {"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0036", "lecture_id": "13-NFs-FDs", "text": "-  Functional Dependencies and Keys\n-  Inference Rules of Functional Dependencies\n- Attribute Closure\n- Closure of a Set of FDs"}, {"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0043", "lecture_id": "13-NFs-FDs", "text": "-  Functional Dependencies and Keys\n-  Inference Rules of Functional Dependencies\n-  Attribute Closure\n- Closure of a Set of FDs"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "A_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0026"}, "gap_lectures": 6}}}
{"A": {"name": "CARDINALITY", "role": "Definition"}, "B": {"name": "KEYS", "role": "Definition"}, "relation": null, "justification": "No decision (LLM output invalid).", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "1-RelationalModel__0012", "lecture_id": "1-RelationalModel", "text": "The intension of the table\n101, Owner = J. Smith. 101, Balance = 1000.00. 101, Type = checking. 102, Owner = W. Wei. 102, Balance = 2000.00. 102, Type = checking. 103, Owner = J. Smith. 103, Balance = 5000.00. 103, Type = savings. 104, Owner = M. Jones. 104, Balance = 1000.00. 104, Type = checking. 105, Owner = H. Martin. 105, Balance = 10,000.00. 105, Type = checking\nThe extension of the table.  Also called the extent .\n, Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. Cardinality, Number = 102. Cardinality, Owner = W. Wei. Cardinality, Balance = 2000.00. Cardinality, Type = checking. of this instance is 5 (because, Number = 103. of this instance is 5 (because, Owner = J. Smith. of this instance is 5 (because, Balance = 5000.00. of this instance is 5 (because, Type = savings. there are 5, Number = 104. there are 5, Owner = M. Jones. there are 5, Balance = 1000.00. there are 5, Type = checking. rows), Number = 105. rows), Owner = H. Martin. rows), Balance = 10,000.00. rows), Type = checking\n-  Data Models\n- Relational Database Model\n-  Basic Concepts and Terminology\n- Keys and Foreign Keys\n- Schema Specifications"}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0002", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Entities and entity sets with attributes, keys, and domain definitions for attributes\n- Relationships among entities and relationship sets with uniqueness or cardinality constraints"}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0002", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Entities and entity sets with attributes, keys, and domain definitions for attributes\n- Relationships among entities and relationship sets with uniqueness or cardinality constraints"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0012"}, "gap_lectures": 0}, "_error": "Unbalanced JSON braces in output."}}
{"A": {"name": "CONCEPTUAL_DESIGN", "role": "NA"}, "B": {"name": "DATABASE_TUNING", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly establish a 'depends_on' or 'part_of' relationship between CONCEPTUAL_DESIGN and DATABASE_TUNING. Both concepts are mentioned in the same context but do not indicate a clear prerequisite or component relationship.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0000", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0000", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0001", "lecture_id": "13-NFs-FDs", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "gap_lectures": 0}}}
{"A": {"name": "CONDITIONAL_CHECK", "role": "Definition"}, "B": {"name": "INSERT_OPERATION", "role": "NA"}, "relation": "depends_on", "justification": "The evidence shows that a conditional check (IF statement) is used to determine whether an INSERT operation should be performed, indicating that the conditional check depends on the context of the insert operation.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "7- ConstraintsTriggers__0033", "lecture_id": "7- ConstraintsTriggers", "text": "```\nCREATE TRIGGER DrinkTrig AFTER INSERT ON Sells FOR EACH ROW BEGIN SET @drink =(SELECT name FROM Drinks WHERE name = new.drink); IF @drink IS NULL THEN INSERT INTO Drinks(name,manf) VALUES(new.drink,'abdu'); END IF; END;\n```\nI ILLINOIS\n- INSERT statements imply a new tuple (for row -level) or new set of tuples (for statement -level).\n- DELETE implies an old tuple or set of tuples.\n- UPDATE implies both.\n- Refer to these by [NEW/OLD]"}, {"source": "chunk_co_occurrence", "chunk_id": "7- ConstraintsTriggers__0034", "lecture_id": "7- ConstraintsTriggers", "text": "```\nCREATE TRIGGER DrinkTrig AFTER INSERT ON Sells FOR EACH ROW BEGIN SET @drink =(SELECT name FROM Drinks WHERE name = new.drink); IF @drink IS NULL THEN INSERT INTO Drinks(name,manf) VALUES(new.drink,'abdu'); END IF; END;\n```\nI ILLINOIS\n- Any Boolean -valued condition is appropriate.\n- It is evaluated before or after the triggering event, depending on whether BEFORE or AFTER is used in the event.\n- Use new/old to access the new/old tuple (row)."}, {"source": "chunk_co_occurrence", "chunk_id": "7- ConstraintsTriggers__0035", "lecture_id": "7- ConstraintsTriggers", "text": "```\nCREATE TRIGGER DrinkTrig AFTER INSERT ON Sells FOR EACH ROW BEGIN SET @drink =(SELECT name FROM Drinks WHERE name = new.drink); IF @drink IS NULL THEN INSERT INTO Drinks(name,manf) VALUES(new.drink,'abdu'); END IF; END;\n```\nI ILLINOIS\n- There can be more than one SQL statement in the action.\n- But queries make no sense in an action, so we are really limited to modifications."}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 19, "lecture_id": "7- ConstraintsTriggers", "chunk_id": "7- ConstraintsTriggers__0033"}, "A_first_introduced_at": {"lecture_index": 19, "lecture_id": "7- ConstraintsTriggers", "chunk_id": "7- ConstraintsTriggers__0016"}, "gap_lectures": 0}}}
{"A": {"name": "CONFLICT", "role": "Definition"}, "B": {"name": "READ", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly indicate a dependency or part_of relationship between 'CONFLICT' and 'READ'. The co-occurrence in the chunks is in the context of transaction serializability and does not suggest one concept depends on or is part of the other.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0019", "lecture_id": "20-Trxn-Serializability", "text": "T1:        R(A)   W(A)\nR(B)    W(B)\nT2:\nR(A)     W(A)\nR(B)   W(B)"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0021", "lecture_id": "20-Trxn-Serializability", "text": "T1:R(A) W(A), 1 = R(B)W(B). T2: R(A) W(A), 1 = R(B) W(B)"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0026", "lecture_id": "20-Trxn-Serializability", "text": "T1:R(A) W(A), 1 = R(B)W(B). T2: R(A) W(A), 1 = R(B) W(B)"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0019"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0019"}, "gap_lectures": 0}}}
{"A": {"name": "CONFLICT", "role": "Definition"}, "B": {"name": "TRANSACTION", "role": "NA"}, "relation": "depends_on", "justification": "The evidence shows that the concept of 'CONFLICT' is explained in the context of 'TRANSACTION', indicating that understanding transactions is a prerequisite for understanding conflicts.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0019", "lecture_id": "20-Trxn-Serializability", "text": "T1:        R(A)   W(A)\nR(B)    W(B)\nT2:\nR(A)     W(A)\nR(B)   W(B)"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0021", "lecture_id": "20-Trxn-Serializability", "text": "T1:R(A) W(A), 1 = R(B)W(B). T2: R(A) W(A), 1 = R(B) W(B)"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0026", "lecture_id": "20-Trxn-Serializability", "text": "T1:R(A) W(A), 1 = R(B)W(B). T2: R(A) W(A), 1 = R(B) W(B)"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0022"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0019"}, "gap_lectures": 2}}}
{"A": {"name": "CONFLICT", "role": "Definition"}, "B": {"name": "WRITE", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly establish a 'depends_on' or 'part_of' relationship between 'CONFLICT' and 'WRITE'. The co-occurrence in the chunks does not provide sufficient context to infer a prerequisite or component relationship.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0019", "lecture_id": "20-Trxn-Serializability", "text": "T1:        R(A)   W(A)\nR(B)    W(B)\nT2:\nR(A)     W(A)\nR(B)   W(B)"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0021", "lecture_id": "20-Trxn-Serializability", "text": "T1:R(A) W(A), 1 = R(B)W(B). T2: R(A) W(A), 1 = R(B) W(B)"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0026", "lecture_id": "20-Trxn-Serializability", "text": "T1:R(A) W(A), 1 = R(B)W(B). T2: R(A) W(A), 1 = R(B) W(B)"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0019"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0019"}, "gap_lectures": 0}}}
{"A": {"name": "CONFLICT_SERIALIZABLE", "role": "Definition"}, "B": {"name": "SERIALIZABLE_SCHEDULES", "role": "NA"}, "relation": "part_of", "justification": "Conflict-Serializable schedules are a specific type of serializable schedules, indicating that A is part of B.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0007", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n- Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0015", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0023", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n-  Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "gap_lectures": 0}}}
{"A": {"name": "CONFLICT_SERIALIZABLE", "role": "Definition"}, "B": {"name": "SERIAL_SCHEDULES", "role": "NA"}, "relation": "part_of", "justification": "Conflict-Serializable schedules are a specific type of serializable schedules, indicating that A is part of B.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0007", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n- Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0015", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0023", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n-  Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0001"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "gap_lectures": 0}}}
{"A": {"name": "CONFLICT_SERIALIZABLE", "role": "Definition"}, "B": {"name": "STRICT_TWO_PHASED_LOCKING", "role": "Definition"}, "relation": null, "justification": "The provided evidence does not clearly indicate a dependency or part_of relationship between 'CONFLICT_SERIALIZABLE' and 'STRICT_TWO_PHASED_LOCKING'. Both concepts are mentioned in the same context but without a clear hierarchical or prerequisite relationship.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0007", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n- Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0015", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0023", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n-  Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "gap_lectures": 0}}}
{"A": {"name": "CONFLICT_SERIALIZABLE", "role": "Definition"}, "B": {"name": "THEORY_OF_SERIALIZABILITY", "role": "Definition"}, "relation": "part_of", "justification": "Conflict-Serializable schedules are a specific type of serializability concept within the broader Theory of Serializability.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0007", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n- Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0015", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0023", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n-  Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "gap_lectures": 0}}}
{"A": {"name": "CONFLICT_SERIALIZABLE", "role": "Definition"}, "B": {"name": "TWO_PHASED_LOCKING", "role": "Definition"}, "relation": "part_of", "justification": "Both concepts are introduced and discussed within the same theoretical framework of serializability, indicating that Conflict-Serializable schedules are a specific type of schedule that can be achieved using Two-Phased Locking.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0007", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n- Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0015", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0023", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n-  Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "gap_lectures": 0}}}
{"A": {"name": "CYPHER_QUERY", "role": "Example"}, "B": {"name": "GRAPH_DATABASE", "role": "NA"}, "relation": "part_of", "justification": "CYPHER_QUERY is a specific query language used within GRAPH_DATABASE, indicating that CYPHER_QUERY is a part of GRAPH_DATABASE.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "10-Neo4J-Part 1__0010", "lecture_id": "10-Neo4J-Part 1", "text": "```\n() (matrix) (:Movie) (matrix:Movie) (matrix:Movie {title: \"The Matrix\"}) (matrix:Movie {title: \"The Matrix\", released: 1997})\n```"}, {"source": "chunk_co_occurrence", "chunk_id": "10-Neo4J-Part 1__0011", "lecture_id": "10-Neo4J-Part 1", "text": "```\nMATCH (node:Label) WHERE node.property = {value} RETURN node.property\n```\n- Find 'Apollo 13' movie\n- Find 1990's movies\n```\nMATCH (n:Movie {title:\"Apollo 13\"}) RETURN n.released;\n```\n```\nMATCH (n:Movie) WHERE n.released >= 1990 AND n.released <=2000 RETURN I n;\n```"}, {"source": "chunk_co_occurrence", "chunk_id": "10-Neo4J-Part 1__0028", "lecture_id": "10-Neo4J-Part 1", "text": "1. Neo4j Tutorial: https://www.tutorialspoint.com/neo4j/index.htm\n2. Video Tutorials: https://neo4j.com/blog/neo4j -video -tutorials/?_ga=2.57983406.580712586.1555337212 -902296776.1553382068\n3. GraphGists are teaching tools which allow you to explore how data in a particular domain would be modeled as a graph and see some example queries of that graph data\n- https://neo4j.com/graphgists/\n4. Awesome user -defined procedures: https://github.com/neo4j -contrib/neo4j -apoc -procedures"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 3, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0008"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0010"}, "gap_lectures": 0}}}
{"A": {"name": "DATABASE_SYSTEMS", "role": "Definition"}, "B": {"name": "DATA_MANAGEMENT", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly indicate a 'depends_on' or 'part_of' relationship between DATABASE_SYSTEMS and DATA_MANAGEMENT. The co-occurrence in the same lectures does not provide sufficient context to infer a clear prerequisite or component relationship.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0001", "lecture_id": "19-Trxn-Mgmt", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0000", "lecture_id": "20-Trxn-Serializability", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}, {"source": "chunk_co_occurrence", "chunk_id": "PT1-WS1-DBDesign_GCP__0009", "lecture_id": "PT1-WS1-DBDesign_GCP", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 2, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0001"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0020"}, "gap_lectures": -9}}}
{"A": {"name": "DATABASE_TUNING", "role": "NA"}, "B": {"name": "ENTITIES_RELATIONSHIPS", "role": "NA"}, "relation": "depends_on", "justification": "DATABASE_TUNING depends on ENTITIES_RELATIONSHIPS because the conceptual design phase, which includes identifying entities and relationships, is a prerequisite for the physical database design and tuning phase.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0000", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0000", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0001", "lecture_id": "13-NFs-FDs", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "gap_lectures": 0}}}
{"A": {"name": "DATABASE_TUNING", "role": "NA"}, "B": {"name": "LOGICAL_DESIGN", "role": "NA"}, "relation": "depends_on", "justification": "DATABASE_TUNING appears to require the foundational knowledge of LOGICAL_DESIGN, as the logical design is a prerequisite for understanding and performing database tuning.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0000", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0000", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0001", "lecture_id": "13-NFs-FDs", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "gap_lectures": 0}}}
{"A": {"name": "DATABASE_TUNING", "role": "NA"}, "B": {"name": "PHYSICAL_DESIGN", "role": "NA"}, "relation": "part_of", "justification": "DATABASE_TUNING is described as a component of the broader concept of Physical Database Design, indicating that it is a specific aspect or technique within Physical Database Design.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0000", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0000", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0001", "lecture_id": "13-NFs-FDs", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "gap_lectures": 0}}}
{"A": {"name": "DATABASE_TUNING", "role": "NA"}, "B": {"name": "RELATIONAL_SCHEMA", "role": "NA"}, "relation": "depends_on", "justification": "DATABASE_TUNING requires an understanding of RELATIONAL_SCHEMA as it involves modifying the database design and selecting file types and indexes based on the relational schema.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0000", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0000", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0001", "lecture_id": "13-NFs-FDs", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "gap_lectures": 0}}}
{"A": {"name": "DATABASE_TUNING", "role": "NA"}, "B": {"name": "SCHEMA_REFINEMENT", "role": "Definition"}, "relation": "depends_on", "justification": "DATABASE_TUNING appears after SCHEMA_REFINEMENT in the logical progression of database design, indicating that SCHEMA_REFINEMENT is a prerequisite for DATABASE_TUNING.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0000", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0000", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0001", "lecture_id": "13-NFs-FDs", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "gap_lectures": 0}}}
{"A": {"name": "DATA_MANAGEMENT", "role": "NA"}, "B": {"name": "QUERY_PROCESSING", "role": "NA"}, "relation": null, "justification": "The provided evidence does not contain any specific information that clearly indicates a 'depends_on' or 'part_of' relationship between DATA_MANAGEMENT and QUERY_PROCESSING.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0001", "lecture_id": "19-Trxn-Mgmt", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0000", "lecture_id": "20-Trxn-Serializability", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}, {"source": "chunk_co_occurrence", "chunk_id": "PT1-WS1-DBDesign_GCP__0009", "lecture_id": "PT1-WS1-DBDesign_GCP", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0001"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0001"}, "gap_lectures": 0}}}
{"A": {"name": "DATA_MANAGEMENT", "role": "NA"}, "B": {"name": "STORAGE_STRUCTURES", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly indicate a 'depends_on' or 'part_of' relationship between DATA_MANAGEMENT and STORAGE_STRUCTURES. The co-occurrence in the same chunks does not provide sufficient context to determine a clear prerequisite or component relationship.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0001", "lecture_id": "19-Trxn-Mgmt", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0000", "lecture_id": "20-Trxn-Serializability", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}, {"source": "chunk_co_occurrence", "chunk_id": "PT1-WS1-DBDesign_GCP__0009", "lecture_id": "PT1-WS1-DBDesign_GCP", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0001"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0001"}, "gap_lectures": 0}}}
{"A": {"name": "DATA_MANAGEMENT", "role": "NA"}, "B": {"name": "TRANSACTION_MANAGEMENT", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly indicate a 'depends_on' or 'part_of' relationship between DATA_MANAGEMENT and TRANSACTION_MANAGEMENT. The co-occurrence in chunks does not provide sufficient context to determine a clear prerequisite or component relationship.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0001", "lecture_id": "19-Trxn-Mgmt", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0000", "lecture_id": "20-Trxn-Serializability", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}, {"source": "chunk_co_occurrence", "chunk_id": "PT1-WS1-DBDesign_GCP__0009", "lecture_id": "PT1-WS1-DBDesign_GCP", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0001"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0001"}, "gap_lectures": 0}}}
{"A": {"name": "ENTITY", "role": "Definition"}, "B": {"name": "RELATIONSHIP", "role": "Definition"}, "relation": null, "justification": "The evidence does not clearly indicate a dependency or part_of relationship between ENTITY and RELATIONSHIP. Both concepts are defined independently without one being a prerequisite or a component of the other.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0005", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Entity: Real-world object distinguishable from  other objects. An entity is described using a set of attributes .\n- Entity Set :  A collection of similar entities.  E.g., all employees. (often referred to as just entity, which blurs the distinction between type and collection)\n- Relationship :  Association among 2 or more entities.  E.g., Kristin's home department is Research & Development.\n- Relationship Set :  Collection of similar relationships.  E.g., Home (often referred to as just relationship)\n- Formal definition:\n- if A, B are sets, then a relation R is a subset of A x B\n- A={1,2,3},   B={a,b,c,d}, R = {(1,a), (1,c), (3,b)}\nSame story w/ entity sets sponsor is a subset of Project x Department :"}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0016", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nWhat are the attributes and what is the key for Assignment?\n```\nProject(P-number, P-name, Due-Date) Employee(SSN, E-Name, Office)\n```\nProject\nP-number P-name Due-Date\nEmployee\nSSN\nE-Name\nOffice\n0..*     Assignment      0..*\n- 0..*        Manager        1..1\nAnswer: Assignment(P-Number, SSN)\nP-Number is a foreign key for Project SSN is a foreign key for Employee\nProject(P-Number, P-Due-Date)\nEmployee(SSN, E-Name, Office)"}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0005", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Entity: Real-world object distinguishable from  other objects. An entity is described using a set of attributes .\n- Entity Set :  A collection of similar entities.  E.g., all employees. (often referred to as just entity, which blurs the distinction between type and collection)\n- Relationship :  Association among 2 or more entities.  E.g., Kristin's home department is Research & Development.\n- Relationship Set :  Collection of similar relationships.  E.g., Home (often referred to as just relationship)\n- Formal definition:\n- if A, B are sets, then a relation R is a subset of A x B\n- A={1,2,3},   B={a,b,c,d}, R = {(1,a), (1,c), (3,b)}\nSame story w/ entity sets sponsor is a subset of Project x Department :"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0005"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0005"}, "gap_lectures": 0}}}
{"A": {"name": "FDS_CLOSURE", "role": "NA"}, "B": {"name": "KEYS", "role": "NA"}, "relation": "depends_on", "justification": "The evidence shows that both concepts are discussed together in the context of functional dependencies and inference rules, suggesting that understanding keys is a prerequisite for discussing attribute closure and closure of a set of FDs.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0031", "lecture_id": "13-NFs-FDs", "text": "-  Functional Dependencies and Keys\n- Inference Rules of Functional Dependencies\n- Attribute Closure\n- Closure of a Set of FDs"}, {"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0036", "lecture_id": "13-NFs-FDs", "text": "-  Functional Dependencies and Keys\n-  Inference Rules of Functional Dependencies\n- Attribute Closure\n- Closure of a Set of FDs"}, {"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0043", "lecture_id": "13-NFs-FDs", "text": "-  Functional Dependencies and Keys\n-  Inference Rules of Functional Dependencies\n-  Attribute Closure\n- Closure of a Set of FDs"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "A_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0026"}, "gap_lectures": 6}}}
{"A": {"name": "FOREIGN_KEY", "role": "Definition"}, "B": {"name": "PRIMARY_KEY", "role": "Definition"}, "relation": "depends_on", "justification": "FOREIGN_KEY depends on PRIMARY_KEY because FOREIGN_KEY references a PRIMARY_KEY in another table, indicating that understanding PRIMARY_KEY is a prerequisite for understanding FOREIGN_KEY.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "1-RelationalModel__0000", "lecture_id": "1-RelationalModel", "text": "- Define a data model\n- Define the relational data model\n- Articulate the basic terminologies of the relational data model (from a practical perspective)\n- Define Primary and Foreign keys"}, {"source": "chunk_co_occurrence", "chunk_id": "7- ConstraintsTriggers__0005", "lecture_id": "7- ConstraintsTriggers", "text": "```\nCREATE TABLE Drinks ( name  CHAR(20) PRIMARY KEY, manf CHAR(20) ); CREATE TABLE Sells ( cafe CHAR(20), drink CHAR(20) REFERENCES Drinks(name), price REAL );\n```\nI ILLINOIS\n8"}, {"source": "chunk_co_occurrence", "chunk_id": "7- ConstraintsTriggers__0006", "lecture_id": "7- ConstraintsTriggers", "text": "```\nCREATE TABLE Drinks ( name CHAR(20) PRIMARY KEY, manf CHAR(20) ); CREATE TABLE Sells ( cafe CHAR(20), drink CHAR(20), price REAL,\n```\n```\nFOREIGN KEY(drink) REFERENCES Drink(name)); 9 I ILLINOIS\n```"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0000"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0000"}, "gap_lectures": 0}}}
{"A": {"name": "FOREIGN_KEY", "role": "NA"}, "B": {"name": "REFERENTIAL_INTEGRITY", "role": "NA"}, "relation": "part_of", "justification": "FOREIGN_KEY is a specific type of constraint that enforces REFERENTIAL_INTEGRITY, indicating that FOREIGN_KEY is part_of REFERENTIAL_INTEGRITY.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0018", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nMgrSSN is a foreign key (referencing the Employee relation)\nvalue of Manager must match an SSN\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nvs.\nProject(P-number, P-name, Due-Date)\nEmployee(SSN, E-Name, Office)\nManager(P-number, SSN)\nWhat are the tradeoffs between these two?\nNote: P-number is the key for Manager"}, {"source": "chunk_co_occurrence", "chunk_id": "7- ConstraintsTriggers__0013", "lecture_id": "7- ConstraintsTriggers", "text": "```\nCREATE TABLE Sells ( cafe CHAR(20), drink CHAR(20), price REAL, FOREIGN KEY(drink) REFERENCES Drinks(name) ON DELETE SET NULL ON UPDATE CASCADE );\n```\nIILLINOIS\n- Constraints\n-  Foreign -key, or referential -integrity constraints.\n- Value -based constraints.\n- Tuple -based constraints.\n- Assertions.\n- Triggers"}, {"source": "chunk_co_occurrence", "chunk_id": "7- ConstraintsTriggers__0023", "lecture_id": "7- ConstraintsTriggers", "text": "- We can do attribute -based check, why tuple level?\n- Reason 1: If the check involves more than one attribute of the tuple, we need the tuple -level check.\n- Reason 2: Tuple -level constraints are checked more frequently.\n- Whenever there are any inserts or updates to any of the concerned attributes\nI\n- Constraints\n-  Foreign -key, or referential -integrity constraints.\n-  Value -based constraints.\n-  Tuple -based constraints.\n- Assertions.\n- Triggers"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 2, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0015"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0000"}, "gap_lectures": 0}}}
{"A": {"name": "FOREIGN_KEYS", "role": "Definition"}, "B": {"name": "SCHEMA_SPECIFICATIONS", "role": "Definition"}, "relation": "part_of", "justification": "Foreign keys are a specific component of schema specifications in the context of relational database models.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "1-RelationalModel__0006", "lecture_id": "1-RelationalModel", "text": "Src: Wikipedia\n-  Data Models\n- Relational Database Model\n- Basic Concepts and Terminology\n- Keys and Foreign Keys\n- Schema Specifications"}, {"source": "chunk_co_occurrence", "chunk_id": "1-RelationalModel__0012", "lecture_id": "1-RelationalModel", "text": "The intension of the table\n101, Owner = J. Smith. 101, Balance = 1000.00. 101, Type = checking. 102, Owner = W. Wei. 102, Balance = 2000.00. 102, Type = checking. 103, Owner = J. Smith. 103, Balance = 5000.00. 103, Type = savings. 104, Owner = M. Jones. 104, Balance = 1000.00. 104, Type = checking. 105, Owner = H. Martin. 105, Balance = 10,000.00. 105, Type = checking\nThe extension of the table.  Also called the extent .\n, Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. Cardinality, Number = 102. Cardinality, Owner = W. Wei. Cardinality, Balance = 2000.00. Cardinality, Type = checking. of this instance is 5 (because, Number = 103. of this instance is 5 (because, Owner = J. Smith. of this instance is 5 (because, Balance = 5000.00. of this instance is 5 (because, Type = savings. there are 5, Number = 104. there are 5, Owner = M. Jones. there are 5, Balance = 1000.00. there are 5, Type = checking. rows), Number = 105. rows), Owner = H. Martin. rows), Balance = 10,000.00. rows), Type = checking\n-  Data Models\n- Relational Database Model\n-  Basic Concepts and Terminology\n- Keys and Foreign Keys\n- Schema Specifications"}, {"source": "chunk_co_occurrence", "chunk_id": "1-RelationalModel__0015", "lecture_id": "1-RelationalModel", "text": ", Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. , Number = 102. , Owner = W. Wei. , Balance = 2000.00. , Type = checking. , Number = 103. , Owner = J. Smith. , Balance = 5000.00. , Type = savings. , Number = 104. , Owner = M. Jones. , Balance = 1000.00. , Type = checking. , Number = 105. , Owner = H. Martin. , Balance = 10,000.00. , Type = checking. Deposit, Number = AcctNo Transaction-id. Deposit, Owner = Date. Deposit, Balance = Amount. Deposit, Type = . , Number = 102 1. , Owner = 10/22/00. , Balance = 500.00. , Type = . , Number = 102 2. , Owner = 10/29/00. , Balance = 200.00. , Type = . , Number = 104 3. , Owner = 10/29/00. , Balance = 1000.00. , Type = . , Number = 105 4. , Owner = 11/02/00. , Balance = 10,000.00. , Type = . , Number = 106 5. , Owner = 12/05/00. , Balance = 555.00. , Type = \nWe say that Deposit.AcctNo is a foreign key that references Account.Number.  If the DBMS enforces this constraint, we have referential integrity .\n, Foreign keys might or might not be part of the key for the referring table.Number = 101 102 103 104 105. , Foreign keys might or might not be part of the key for the referring table.Owner = J. Smith W. Wei J. Smith M. Jones H. Martin. , Foreign keys might or might not be part of the key for the referring table.Balance = 1000.00 2000.00 5000.00 1000.00 10,000.00. , Foreign keys might or might not be part of the key for the referring table.Type = checking checking savings checking checking. Deposit, Foreign keys might or might not be part of the key for the referring table.Number = AcctNo. Deposit, Foreign keys might or might not be part of the key for the referring table.Owner = Transaction-id. Deposit, Foreign keys might or might not be part of the key for the referring table.Balance = Date. Deposit, Foreign keys might or might not be part of the key for the referring table.Type = Amount. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Number = AcctNo 101 101. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Owner = Check-number 924 925. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Balance = Date 10/23/00 10/24/00. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Type = Amount 125.00 23.98\n-  Data Models\n- Relational Database Model\n-  Basic Concepts and Terminology\n-  Keys and Foreign Keys\n- Schema Specifications"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "gap_lectures": 0}}}
{"A": {"name": "FUNCTIONAL_DEPENDENCIES", "role": "NA"}, "B": {"name": "KEYS", "role": "NA"}, "relation": "depends_on", "justification": "The evidence suggests that both concepts are discussed together, but the lectures introduce and explain Functional Dependencies in the context of Keys, implying that understanding Keys is a prerequisite for understanding Functional Dependencies.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0031", "lecture_id": "13-NFs-FDs", "text": "-  Functional Dependencies and Keys\n- Inference Rules of Functional Dependencies\n- Attribute Closure\n- Closure of a Set of FDs"}, {"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0036", "lecture_id": "13-NFs-FDs", "text": "-  Functional Dependencies and Keys\n-  Inference Rules of Functional Dependencies\n- Attribute Closure\n- Closure of a Set of FDs"}, {"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0043", "lecture_id": "13-NFs-FDs", "text": "-  Functional Dependencies and Keys\n-  Inference Rules of Functional Dependencies\n-  Attribute Closure\n- Closure of a Set of FDs"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 2, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "A_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0003"}, "gap_lectures": 6}}}
{"A": {"name": "FUNCTIONAL_DEPENDENCIES", "role": "NA"}, "B": {"name": "NORMALIZATION", "role": "NA"}, "relation": "depends_on", "justification": "Functional dependencies are used to transform the original database schema to achieve a good design, which is a key step in normalization. The evidence shows that identifying and using functional dependencies is crucial before normalization can be effectively applied.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0003", "lecture_id": "13-NFs-FDs", "text": "- Start with the original db schema R\n- From ER translation or otherwise\n- Identify its functional dependencies\n- Use them to transform R until we get a good design R*"}, {"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0017", "lecture_id": "13-NFs-FDs", "text": "caused by 'troublesome' FDs\nEMP(name, SSN, birthdate, address, dnum, dname, dmgr)"}, {"source": "chunk_co_occurrence", "chunk_id": "DBDesign_BCNF__0009", "lecture_id": "DBDesign_BCNF", "text": "- R(SSN, netid, phone).\n- Each of these two FDs violates BCNF.\n- FD1: SSN -> netid\n- FD2: netid -> SSN\nCan you tell me two different BCNF decomp for R?\nPick FD1\nPick FD2\nR(SSN, netid, phone)\n(SSN, netid)\n(SSN, phone)\nR(SSN, netid, phone)\n(netid, SSN)\n(netid, phone)"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 4, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0000"}, "A_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0003"}, "gap_lectures": 5}}}
{"A": {"name": "INFERENCE_RULES", "role": "Definition"}, "B": {"name": "KEYS", "role": "NA"}, "relation": "depends_on", "justification": "The evidence shows that inference rules of functional dependencies are discussed in the context of functional dependencies and keys, suggesting that understanding keys is a prerequisite for understanding inference rules.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0031", "lecture_id": "13-NFs-FDs", "text": "-  Functional Dependencies and Keys\n- Inference Rules of Functional Dependencies\n- Attribute Closure\n- Closure of a Set of FDs"}, {"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0036", "lecture_id": "13-NFs-FDs", "text": "-  Functional Dependencies and Keys\n-  Inference Rules of Functional Dependencies\n- Attribute Closure\n- Closure of a Set of FDs"}, {"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0043", "lecture_id": "13-NFs-FDs", "text": "-  Functional Dependencies and Keys\n-  Inference Rules of Functional Dependencies\n-  Attribute Closure\n- Closure of a Set of FDs"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "A_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0026"}, "gap_lectures": 6}}}
{"A": {"name": "KEYS", "role": "Definition"}, "B": {"name": "SCHEMA_SPECIFICATIONS", "role": "Definition"}, "relation": "part_of", "justification": "Both 'Keys' and 'Schema Specifications' are introduced together and discussed within the context of basic concepts and terminology of the relational database model. 'Keys' are a specific component of the broader concept of 'Schema Specifications'.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "1-RelationalModel__0006", "lecture_id": "1-RelationalModel", "text": "Src: Wikipedia\n-  Data Models\n- Relational Database Model\n- Basic Concepts and Terminology\n- Keys and Foreign Keys\n- Schema Specifications"}, {"source": "chunk_co_occurrence", "chunk_id": "1-RelationalModel__0012", "lecture_id": "1-RelationalModel", "text": "The intension of the table\n101, Owner = J. Smith. 101, Balance = 1000.00. 101, Type = checking. 102, Owner = W. Wei. 102, Balance = 2000.00. 102, Type = checking. 103, Owner = J. Smith. 103, Balance = 5000.00. 103, Type = savings. 104, Owner = M. Jones. 104, Balance = 1000.00. 104, Type = checking. 105, Owner = H. Martin. 105, Balance = 10,000.00. 105, Type = checking\nThe extension of the table.  Also called the extent .\n, Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. Cardinality, Number = 102. Cardinality, Owner = W. Wei. Cardinality, Balance = 2000.00. Cardinality, Type = checking. of this instance is 5 (because, Number = 103. of this instance is 5 (because, Owner = J. Smith. of this instance is 5 (because, Balance = 5000.00. of this instance is 5 (because, Type = savings. there are 5, Number = 104. there are 5, Owner = M. Jones. there are 5, Balance = 1000.00. there are 5, Type = checking. rows), Number = 105. rows), Owner = H. Martin. rows), Balance = 10,000.00. rows), Type = checking\n-  Data Models\n- Relational Database Model\n-  Basic Concepts and Terminology\n- Keys and Foreign Keys\n- Schema Specifications"}, {"source": "chunk_co_occurrence", "chunk_id": "1-RelationalModel__0015", "lecture_id": "1-RelationalModel", "text": ", Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. , Number = 102. , Owner = W. Wei. , Balance = 2000.00. , Type = checking. , Number = 103. , Owner = J. Smith. , Balance = 5000.00. , Type = savings. , Number = 104. , Owner = M. Jones. , Balance = 1000.00. , Type = checking. , Number = 105. , Owner = H. Martin. , Balance = 10,000.00. , Type = checking. Deposit, Number = AcctNo Transaction-id. Deposit, Owner = Date. Deposit, Balance = Amount. Deposit, Type = . , Number = 102 1. , Owner = 10/22/00. , Balance = 500.00. , Type = . , Number = 102 2. , Owner = 10/29/00. , Balance = 200.00. , Type = . , Number = 104 3. , Owner = 10/29/00. , Balance = 1000.00. , Type = . , Number = 105 4. , Owner = 11/02/00. , Balance = 10,000.00. , Type = . , Number = 106 5. , Owner = 12/05/00. , Balance = 555.00. , Type = \nWe say that Deposit.AcctNo is a foreign key that references Account.Number.  If the DBMS enforces this constraint, we have referential integrity .\n, Foreign keys might or might not be part of the key for the referring table.Number = 101 102 103 104 105. , Foreign keys might or might not be part of the key for the referring table.Owner = J. Smith W. Wei J. Smith M. Jones H. Martin. , Foreign keys might or might not be part of the key for the referring table.Balance = 1000.00 2000.00 5000.00 1000.00 10,000.00. , Foreign keys might or might not be part of the key for the referring table.Type = checking checking savings checking checking. Deposit, Foreign keys might or might not be part of the key for the referring table.Number = AcctNo. Deposit, Foreign keys might or might not be part of the key for the referring table.Owner = Transaction-id. Deposit, Foreign keys might or might not be part of the key for the referring table.Balance = Date. Deposit, Foreign keys might or might not be part of the key for the referring table.Type = Amount. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Number = AcctNo 101 101. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Owner = Check-number 924 925. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Balance = Date 10/23/00 10/24/00. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Type = Amount 125.00 23.98\n-  Data Models\n- Relational Database Model\n-  Basic Concepts and Terminology\n-  Keys and Foreign Keys\n- Schema Specifications"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "gap_lectures": 0}}}
{"A": {"name": "NODES", "role": "Example"}, "B": {"name": "RELATIONSHIPS", "role": "Definition"}, "relation": null, "justification": "The evidence does not clearly support a 'depends_on' or 'part_of' relationship between NODES and RELATIONSHIPS. Both concepts are introduced as separate components of graph theory without one being a prerequisite or a part of the other.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "10-Neo4J-Part 1__0002", "lecture_id": "10-Neo4J-Part 1", "text": "- Many types of data can be represented as graphs\n- Road networks, with intersections as nodes and road segments as edges\n- Computer networks, with computers as nodes and connections as edges\n- Social networks, with people/postings as nodes and edges as relationship (e.g. friends, likes, created, …)\n- Graph databases store relationships and connections as first -class entities: 'Property Graph Model'\nRoad Nodes\n非\nSingle Direction Road Links\nDouble Direction Road Links"}, {"source": "chunk_co_occurrence", "chunk_id": "10-Neo4J-Part 1__0013", "lecture_id": "10-Neo4J-Part 1", "text": "Relationships are basically an arrow --> between two nodes.\n- relationship -types -[:KNOWS] -> , < -[: LIKE] -\n- a variable name -[rel:KNOWS] -> before the colon\n- additional properties -[rel:KNOWS {since:2018}] ->\n- structural information for paths of variable length -[:KNOWS*..4] ->\nMATCH (n1:Label1) - [rel:TYPE] - >(n2:Label2) WHERE rel.property = {value} RETURN rel.property, type(rel)"}, {"source": "chunk_co_occurrence", "chunk_id": "10-Neo4J-Part 1__0022", "lecture_id": "10-Neo4J-Part 1", "text": "```\n{name:\"Lamya\"}) MATCH (a:Person {name:\"Devin\"}) MATCH (b:Person \"Vidisha\"}) MATCH (c:Person {name: CREATE (a)-[:Friends]->(b)<-[:Friends]-(c) RETURN a,b,c\n```"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0002"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0002"}, "gap_lectures": 0}}}
{"A": {"name": "PRIMARY_KEY", "role": "Definition"}, "B": {"name": "RELATIONAL_MODEL", "role": "Definition"}, "relation": "part_of", "justification": "The evidence shows that PRIMARY_KEY is a specific concept within the broader context of the RELATIONAL_MODEL, indicating that PRIMARY_KEY is part of the RELATIONAL_MODEL.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "1-RelationalModel__0000", "lecture_id": "1-RelationalModel", "text": "- Define a data model\n- Define the relational data model\n- Articulate the basic terminologies of the relational data model (from a practical perspective)\n- Define Primary and Foreign keys"}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0015", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- can be represented as a table in the relational model\n- has a key … which becomes a key for the table\nCREATE TABLE Employee (SSN CHAR(11) NOT NULL, E-Name CHAR(20), Office  INTEGER, PRIMARY KEY  (SSN))"}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0015", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- can be represented as a table in the relational model\n- has a key … which becomes a key for the table\nCREATE TABLE Employee (SSN CHAR(11) NOT NULL, E-Name CHAR(20), Office  INTEGER, PRIMARY KEY  (SSN))"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0000"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0000"}, "gap_lectures": 0}}}
{"A": {"name": "PROJECTION", "role": "Definition"}, "B": {"name": "RENAME", "role": "Definition"}, "relation": null, "justification": "The provided evidence does not clearly indicate a dependency or part_of relationship between PROJECTION and RENAME. Both concepts are introduced and used independently without one being a prerequisite or a component of the other.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "21-RA__0004", "lecture_id": "21-RA", "text": "- Projection\n  (R)\n• Selection  (R)\n- (Rename)   (R)\n- Union R1 U R2\n- Difference\nR1 - R 2\n- Product\nR1 x R2"}, {"source": "chunk_co_occurrence", "chunk_id": "21-RA__0016", "lecture_id": "21-RA", "text": "- Using Sells(cafe, drink, price), find the cafes that sell two different drinks at the same price.\n- R1:=  Sells1(cafe, drink1, price) Sells\n- R2:=  NOT (drink1 = drink) (R1         Sells)\n- R3:=  cafe R2"}, {"source": "chunk_co_occurrence", "chunk_id": "21-RA__0019", "lecture_id": "21-RA", "text": "- Using Sells(cafe, drink, price), find the cafes that sell two different drinks at the same price.\n- R1:=  Sells1(cafe, drink1, price) Sells\n- R2:=  NOT (drink1 = drink) R1         Sells\n- R3:=  cafe R2"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0004"}, "A_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0004"}, "gap_lectures": 0}}}
{"A": {"name": "PROJECTION", "role": "Definition"}, "B": {"name": "SELECTION", "role": "Definition"}, "relation": null, "justification": "The evidence does not clearly indicate a dependency or part_of relationship between PROJECTION and SELECTION. Both concepts are introduced and used independently without one being a prerequisite or a component of the other.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "21-RA__0004", "lecture_id": "21-RA", "text": "- Projection\n  (R)\n• Selection  (R)\n- (Rename)   (R)\n- Union R1 U R2\n- Difference\nR1 - R 2\n- Product\nR1 x R2"}, {"source": "chunk_co_occurrence", "chunk_id": "21-RA__0016", "lecture_id": "21-RA", "text": "- Using Sells(cafe, drink, price), find the cafes that sell two different drinks at the same price.\n- R1:=  Sells1(cafe, drink1, price) Sells\n- R2:=  NOT (drink1 = drink) (R1         Sells)\n- R3:=  cafe R2"}, {"source": "chunk_co_occurrence", "chunk_id": "21-RA__0019", "lecture_id": "21-RA", "text": "- Using Sells(cafe, drink, price), find the cafes that sell two different drinks at the same price.\n- R1:=  Sells1(cafe, drink1, price) Sells\n- R2:=  NOT (drink1 = drink) R1         Sells\n- R3:=  cafe R2"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0004"}, "A_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0004"}, "gap_lectures": 0}}}
{"A": {"name": "READ", "role": "NA"}, "B": {"name": "TRANSACTION", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly establish a 'depends_on' or 'part_of' relationship between 'READ' and 'TRANSACTION'. The co-occurrence in the chunks is in the context of transaction serializability and does not indicate a prerequisite or part-of relationship.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0019", "lecture_id": "20-Trxn-Serializability", "text": "T1:        R(A)   W(A)\nR(B)    W(B)\nT2:\nR(A)     W(A)\nR(B)   W(B)"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0021", "lecture_id": "20-Trxn-Serializability", "text": "T1:R(A) W(A), 1 = R(B)W(B). T2: R(A) W(A), 1 = R(B) W(B)"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0026", "lecture_id": "20-Trxn-Serializability", "text": "T1:R(A) W(A), 1 = R(B)W(B). T2: R(A) W(A), 1 = R(B) W(B)"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0022"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0019"}, "gap_lectures": 2}}}
{"A": {"name": "READ", "role": "NA"}, "B": {"name": "WRITE", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly indicate a dependency or part_of relationship between 'READ' and 'WRITE'. They co-occur in the context of transaction serializability but do not establish a clear prerequisite or component relationship.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0019", "lecture_id": "20-Trxn-Serializability", "text": "T1:        R(A)   W(A)\nR(B)    W(B)\nT2:\nR(A)     W(A)\nR(B)   W(B)"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0021", "lecture_id": "20-Trxn-Serializability", "text": "T1:R(A) W(A), 1 = R(B)W(B). T2: R(A) W(A), 1 = R(B) W(B)"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0026", "lecture_id": "20-Trxn-Serializability", "text": "T1:R(A) W(A), 1 = R(B)W(B). T2: R(A) W(A), 1 = R(B) W(B)"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0019"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0019"}, "gap_lectures": 0}}}
{"A": {"name": "READ_COMMITTED", "role": "Definition"}, "B": {"name": "READ_UNCOMMITTED", "role": "Definition"}, "relation": null, "justification": "The provided evidence does not clearly indicate a dependency or part_of relationship between READ_COMMITTED and READ_UNCOMMITTED. Both concepts are introduced as different transaction isolation levels without one being a prerequisite or a component of the other.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0027", "lecture_id": "19-Trxn-Mgmt", "text": "- To signal to the system that a dirty read is acceptable,\nSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\n- In addition, there are\nSET TRANSACTION ISOLATION LEVEL READ COMMITTED; SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;"}, {"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0030", "lecture_id": "19-Trxn-Mgmt", "text": "READ UN- COMMITTED, Dirty Read = Maybe. READ UN- COMMITTED, Unrepeatable Read = Maybe. READ UN- COMMITTED, Phantoms = Maybe. READ COMMITTED, Dirty Read = No. READ COMMITTED, Unrepeatable Read = Maybe. READ COMMITTED, Phantoms = Maybe. REPEATABLE READ, Dirty Read = No. REPEATABLE READ, Unrepeatable Read = No. REPEATABLE READ, Phantoms = Maybe. SERIALIZABLE, Dirty Read = No. SERIALIZABLE, Unrepeatable Read = No. SERIALIZABLE, Phantoms = No"}, {"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0036", "lecture_id": "19-Trxn-Mgmt", "text": "READ UNCOMMITTED allows queries in the transaction to read data without acquiring any lock\n- Access mode READ ONLY, no updates are allowed\nREAD COMMITTED requires a read-lock to be obtained for all tuples touched by queries, but it releases the locks immediately after the read\n- Exclusive locks must be obtained for updates and held to end of transaction"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0027"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0027"}, "gap_lectures": 0}}}
{"A": {"name": "READ_COMMITTED", "role": "NA"}, "B": {"name": "REPEATABLE_READ", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly indicate a dependency or part_of relationship between READ_COMMITTED and REPEATABLE_READ. Both concepts are presented as different transaction isolation levels without one being a prerequisite or a component of the other.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0027", "lecture_id": "19-Trxn-Mgmt", "text": "- To signal to the system that a dirty read is acceptable,\nSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\n- In addition, there are\nSET TRANSACTION ISOLATION LEVEL READ COMMITTED; SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;"}, {"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0030", "lecture_id": "19-Trxn-Mgmt", "text": "READ UN- COMMITTED, Dirty Read = Maybe. READ UN- COMMITTED, Unrepeatable Read = Maybe. READ UN- COMMITTED, Phantoms = Maybe. READ COMMITTED, Dirty Read = No. READ COMMITTED, Unrepeatable Read = Maybe. READ COMMITTED, Phantoms = Maybe. REPEATABLE READ, Dirty Read = No. REPEATABLE READ, Unrepeatable Read = No. REPEATABLE READ, Phantoms = Maybe. SERIALIZABLE, Dirty Read = No. SERIALIZABLE, Unrepeatable Read = No. SERIALIZABLE, Phantoms = No"}, {"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0040", "lecture_id": "19-Trxn-Mgmt", "text": "- Now suppose that T1 is REPEATABLE READ:\nT1: SET TRANSACTION READ WRITE ISOLATION LEVEL REPEATABLE READ;\nSQL code that translates to: R1(A), R1(B) W1(B) W1(C)\nT2: SET TRANSACTION READ WRITE ISOLATION LEVEL READ COMMITTED;\nSQL code that translates to: R2(C), R2(A) W2(A)\nOne possible interleaved execution of the transactions above: R1(A) R2(C) R2(A) R1(B) W1(B) W1(C) W2(A)\nS1(A) R1(A) S2(C) R2(C) REL2(C) S2(A) R2(A) Rel2(A) S1(B) R1(B) X1(B) W1(B) X1(C) W1(C)  REL1(A, B,C) X2(A) W2(A) REL2(A)"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0027"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0027"}, "gap_lectures": 0}}}
{"A": {"name": "RENAME", "role": "Definition"}, "B": {"name": "SELECTION", "role": "Definition"}, "relation": null, "justification": "The provided evidence does not clearly indicate a dependency or part_of relationship between 'RENAME' and 'SELECTION'. Both concepts are listed as separate operations in the context of relational algebra, but there is no clear indication that one depends on the other or is a part of the other.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "21-RA__0004", "lecture_id": "21-RA", "text": "- Projection\n  (R)\n• Selection  (R)\n- (Rename)   (R)\n- Union R1 U R2\n- Difference\nR1 - R 2\n- Product\nR1 x R2"}, {"source": "chunk_co_occurrence", "chunk_id": "21-RA__0016", "lecture_id": "21-RA", "text": "- Using Sells(cafe, drink, price), find the cafes that sell two different drinks at the same price.\n- R1:=  Sells1(cafe, drink1, price) Sells\n- R2:=  NOT (drink1 = drink) (R1         Sells)\n- R3:=  cafe R2"}, {"source": "chunk_co_occurrence", "chunk_id": "21-RA__0019", "lecture_id": "21-RA", "text": "- Using Sells(cafe, drink, price), find the cafes that sell two different drinks at the same price.\n- R1:=  Sells1(cafe, drink1, price) Sells\n- R2:=  NOT (drink1 = drink) R1         Sells\n- R3:=  cafe R2"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0004"}, "A_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0004"}, "gap_lectures": 0}}}
{"A": {"name": "SERIALIZABLE_SCHEDULES", "role": "NA"}, "B": {"name": "SERIAL_SCHEDULES", "role": "NA"}, "relation": "depends_on", "justification": "The evidence shows that serial schedules are a prerequisite for understanding serializable schedules, as serializable schedules are a more complex concept that builds upon the simpler concept of serial schedules.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0007", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n- Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0015", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0023", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n-  Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0001"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "gap_lectures": 0}}}
{"A": {"name": "SERIALIZABLE_SCHEDULES", "role": "NA"}, "B": {"name": "STRICT_TWO_PHASED_LOCKING", "role": "Definition"}, "relation": "depends_on", "justification": "Strict two-phased locking (S2PL) is a specific locking protocol that ensures serializability of schedules, implying that understanding S2PL is necessary to fully grasp the concept of serializable schedules.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0007", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n- Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0015", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0023", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n-  Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "gap_lectures": 0}}}
{"A": {"name": "SERIALIZABLE_SCHEDULES", "role": "NA"}, "B": {"name": "THEORY_OF_SERIALIZABILITY", "role": "Definition"}, "relation": "part_of", "justification": "Serializable schedules are a specific type of schedule within the broader theory of serializability.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0007", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n- Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0015", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0023", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n-  Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "gap_lectures": 0}}}
{"A": {"name": "SERIALIZABLE_SCHEDULES", "role": "NA"}, "B": {"name": "TWO_PHASED_LOCKING", "role": "Definition"}, "relation": "depends_on", "justification": "The evidence suggests that Two-Phased Locking (2PL) is a mechanism that ensures serializability of schedules, implying that understanding Two-Phased Locking is a prerequisite for understanding Serializable Schedules.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0007", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n- Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0015", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0023", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n-  Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "gap_lectures": 0}}}
{"A": {"name": "SERIAL_SCHEDULES", "role": "NA"}, "B": {"name": "STRICT_TWO_PHASED_LOCKING", "role": "Definition"}, "relation": "depends_on", "justification": "Strict two-phased locking (S2PL) is a specific locking protocol that ensures serializability, which is a property of serial schedules. Therefore, understanding serial schedules is a prerequisite for understanding S2PL.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0007", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n- Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0015", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0023", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n-  Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0001"}, "gap_lectures": 0}}}
{"A": {"name": "SERIAL_SCHEDULES", "role": "NA"}, "B": {"name": "THEORY_OF_SERIALIZABILITY", "role": "Definition"}, "relation": "part_of", "justification": "The evidence shows that serial schedules are discussed within the context of the theory of serializability, indicating that serial schedules are a component or specific type of the broader concept of serializability theory.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0007", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n- Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0015", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0023", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n-  Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0001"}, "gap_lectures": 0}}}
{"A": {"name": "SERIAL_SCHEDULES", "role": "NA"}, "B": {"name": "TWO_PHASED_LOCKING", "role": "Definition"}, "relation": "depends_on", "justification": "The evidence suggests that Two-Phased Locking (B) is introduced as a theorem and method that is used to ensure serializability, which is related to serial and serializable schedules (A). This implies that understanding Two-Phased Locking is necessary to fully grasp the concept of serializable schedules.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0007", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n- Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0015", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0023", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n-  Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0001"}, "gap_lectures": 0}}}
{"A": {"name": "STRICT_TWO_PHASED_LOCKING", "role": "Definition"}, "B": {"name": "THEORY_OF_SERIALIZABILITY", "role": "Definition"}, "relation": "depends_on", "justification": "Strict two-phased locking (S2PL) is a specific protocol that is discussed within the context of the theory of serializability, indicating that understanding the theory of serializability is a prerequisite for understanding S2PL.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0007", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n- Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0015", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0023", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n-  Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "gap_lectures": 0}}}
{"A": {"name": "STRICT_TWO_PHASED_LOCKING", "role": "Definition"}, "B": {"name": "TWO_PHASED_LOCKING", "role": "Definition"}, "relation": "part_of", "justification": "Strict two-phased locking (S2PL) is a specific type of two-phased locking (2PL), indicating that S2PL is part of the broader concept of 2PL.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0007", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n- Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0015", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0023", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n-  Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "gap_lectures": 0}}}
{"A": {"name": "THEORY_OF_SERIALIZABILITY", "role": "Definition"}, "B": {"name": "TWO_PHASED_LOCKING", "role": "Definition"}, "relation": "part_of", "justification": "The evidence shows that Two-Phased Locking is discussed within the context of the Theory of Serializability, indicating that Two-Phased Locking is a component or specific type within the broader concept of Serializability.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0007", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n- Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0015", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0023", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n-  Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "gap_lectures": 0}}}
{"A": {"name": "TRANSACTION", "role": "NA"}, "B": {"name": "WRITE", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly indicate a 'depends_on' or 'part_of' relationship between 'TRANSACTION' and 'WRITE'. The co-occurrence in the evidence suggests they are used together in the context of transaction management but does not establish a clear prerequisite or part-whole relationship.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0019", "lecture_id": "20-Trxn-Serializability", "text": "T1:        R(A)   W(A)\nR(B)    W(B)\nT2:\nR(A)     W(A)\nR(B)   W(B)"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0021", "lecture_id": "20-Trxn-Serializability", "text": "T1:R(A) W(A), 1 = R(B)W(B). T2: R(A) W(A), 1 = R(B) W(B)"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0026", "lecture_id": "20-Trxn-Serializability", "text": "T1:R(A) W(A), 1 = R(B)W(B). T2: R(A) W(A), 1 = R(B) W(B)"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 3, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 3 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0019"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0022"}, "gap_lectures": -2}}}
{"A": {"name": "ASSERTIONS", "role": "Definition"}, "B": {"name": "FOREIGN_KEY", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly establish a 'depends_on' or 'part_of' relationship between 'ASSERTIONS' and 'FOREIGN_KEY'. Both concepts are mentioned in the context of constraints but are not shown to have a clear prerequisite or component relationship.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "7- ConstraintsTriggers__0002", "lecture_id": "7- ConstraintsTriggers", "text": "- Constraints are used to make sure that the data in the database 'makes sense', that is: important real -world properties are kept valid\n- Via continuous maintenance of 'assertions' (i.e. Constraints)\n- A constraint is a relationship among data elements that the DBMS is required to enforce.\n- Example: key constraints.\n- Keys.\n- Foreign -key, or referential -integrity.\n- Value -based constraints.\n- Constrain values of a particular attribute.\n- Tuple -based constraints.\n- Relationship among components.\n- Assertions: any SQL Boolean expression."}, {"source": "chunk_co_occurrence", "chunk_id": "7- ConstraintsTriggers__0023", "lecture_id": "7- ConstraintsTriggers", "text": "- We can do attribute -based check, why tuple level?\n- Reason 1: If the check involves more than one attribute of the tuple, we need the tuple -level check.\n- Reason 2: Tuple -level constraints are checked more frequently.\n- Whenever there are any inserts or updates to any of the concerned attributes\nI\n- Constraints\n-  Foreign -key, or referential -integrity constraints.\n-  Value -based constraints.\n-  Tuple -based constraints.\n- Assertions.\n- Triggers"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0000"}, "A_first_introduced_at": {"lecture_index": 19, "lecture_id": "7- ConstraintsTriggers", "chunk_id": "7- ConstraintsTriggers__0001"}, "gap_lectures": 19}}}
{"A": {"name": "ASSERTIONS", "role": "Definition"}, "B": {"name": "REFERENTIAL_INTEGRITY", "role": "Definition"}, "relation": null, "justification": "The provided evidence does not clearly indicate a dependency or part_of relationship between 'ASSERTIONS' and 'REFERENTIAL_INTEGRITY'. Both concepts are listed as separate items under 'Constraints' without indicating one depends on the other or is part of the other.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "7- ConstraintsTriggers__0001", "lecture_id": "7- ConstraintsTriggers", "text": "After this lecture, you should be able to:\n- Define Database Constraints, including\n- Referential integrity constraints\n- Attribute -level constraints\n- Tuple -level constraints\n- Assertions\n- Define database triggers\n2\n- Constraints\n- Foreign -key, or referential -integrity constraints.\n- Value -based constraints.\n- Tuple -based constraints.\n- Assertions.\n- Triggers"}, {"source": "chunk_co_occurrence", "chunk_id": "7- ConstraintsTriggers__0023", "lecture_id": "7- ConstraintsTriggers", "text": "- We can do attribute -based check, why tuple level?\n- Reason 1: If the check involves more than one attribute of the tuple, we need the tuple -level check.\n- Reason 2: Tuple -level constraints are checked more frequently.\n- Whenever there are any inserts or updates to any of the concerned attributes\nI\n- Constraints\n-  Foreign -key, or referential -integrity constraints.\n-  Value -based constraints.\n-  Tuple -based constraints.\n- Assertions.\n- Triggers"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0015"}, "A_first_introduced_at": {"lecture_index": 19, "lecture_id": "7- ConstraintsTriggers", "chunk_id": "7- ConstraintsTriggers__0001"}, "gap_lectures": 19}}}
{"A": {"name": "ATTRIBUTES", "role": "Definition"}, "B": {"name": "CARDINALITY", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly establish a 'depends_on' or 'part_of' relationship between 'ATTRIBUTES' and 'CARDINALITY'. Both concepts are mentioned in the context of database design but do not indicate a clear prerequisite or part-of relationship.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0002", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Entities and entity sets with attributes, keys, and domain definitions for attributes\n- Relationships among entities and relationship sets with uniqueness or cardinality constraints"}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0002", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Entities and entity sets with attributes, keys, and domain definitions for attributes\n- Relationships among entities and relationship sets with uniqueness or cardinality constraints"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0012"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0001"}, "gap_lectures": 4}}}
{"A": {"name": "ATTRIBUTES", "role": "Definition"}, "B": {"name": "FOREIGN_KEYS", "role": "NA"}, "relation": null, "justification": "The evidence does not clearly indicate a dependency or part_of relationship between attributes and foreign keys.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0001", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Relational model has:\n- tables (relations) with attributes, keys, foreign keys, domain definitions for attributes"}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0001", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Relational model has:\n- tables (relations) with attributes, keys, foreign keys, domain definitions for attributes"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 2, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0001"}, "gap_lectures": 4}}}
{"A": {"name": "ATTRIBUTES", "role": "Definition"}, "B": {"name": "RELATIONAL_MODEL", "role": "Definition"}, "relation": "part_of", "justification": "Attributes are components of the relational model, as evidenced by their co-occurrence in the provided chunks where attributes are described as part of the relational model's tables (relations).", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0001", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Relational model has:\n- tables (relations) with attributes, keys, foreign keys, domain definitions for attributes"}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0001", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Relational model has:\n- tables (relations) with attributes, keys, foreign keys, domain definitions for attributes"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0000"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0001"}, "gap_lectures": 4}}}
{"A": {"name": "ATTRIBUTES", "role": "NA"}, "B": {"name": "RELATIONSHIP", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly establish a 'depends_on' or 'part_of' relationship between 'ATTRIBUTES' and 'RELATIONSHIP'. Both terms appear in the context of database design but are not shown to have a clear prerequisite or component relationship.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0016", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nWhat are the attributes and what is the key for Assignment?\n```\nProject(P-number, P-name, Due-Date) Employee(SSN, E-Name, Office)\n```\nProject\nP-number P-name Due-Date\nEmployee\nSSN\nE-Name\nOffice\n0..*     Assignment      0..*\n- 0..*        Manager        1..1\nAnswer: Assignment(P-Number, SSN)\nP-Number is a foreign key for Project SSN is a foreign key for Employee\nProject(P-Number, P-Due-Date)\nEmployee(SSN, E-Name, Office)"}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0016", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nWhat are the attributes and what is the key for Assignment?\n```\nProject(P-number, P-name, Due-Date) Employee(SSN, E-Name, Office)\n```\nProject\nP-number P-name Due-Date\nEmployee\nSSN\nE-Name\nOffice\n0..*     Assignment      0..*\n- 0..*        Manager        1..1\nAnswer: Assignment(P-Number, SSN)\nP-Number is a foreign key for Project SSN is a foreign key for Employee\nProject(P-Number, P-Due-Date)\nEmployee(SSN, E-Name, Office)"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0005"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0001"}, "gap_lectures": 0}}}
{"A": {"name": "ATTRIBUTES", "role": "Definition"}, "B": {"name": "RELATIONSHIPS", "role": "Definition"}, "relation": "depends_on", "justification": "Both attributes and relationships are introduced in the context of database design, but the description of relationships among entities and relationship sets with uniqueness or cardinality constraints suggests that understanding attributes is a prerequisite for comprehending relationships.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0002", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Entities and entity sets with attributes, keys, and domain definitions for attributes\n- Relationships among entities and relationship sets with uniqueness or cardinality constraints"}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0002", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Entities and entity sets with attributes, keys, and domain definitions for attributes\n- Relationships among entities and relationship sets with uniqueness or cardinality constraints"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0002"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0001"}, "gap_lectures": 3}}}
{"A": {"name": "CARDINALITY", "role": "NA"}, "B": {"name": "RELATIONSHIPS", "role": "Definition"}, "relation": "depends_on", "justification": "Cardinality is discussed in the context of relationships, indicating that understanding relationships is a prerequisite for understanding cardinality.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0002", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Entities and entity sets with attributes, keys, and domain definitions for attributes\n- Relationships among entities and relationship sets with uniqueness or cardinality constraints"}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0002", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Entities and entity sets with attributes, keys, and domain definitions for attributes\n- Relationships among entities and relationship sets with uniqueness or cardinality constraints"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0002"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0012"}, "gap_lectures": -1}}}
{"A": {"name": "CONCEPTUAL_DESIGN", "role": "NA"}, "B": {"name": "NORMALIZATION", "role": "NA"}, "relation": "depends_on", "justification": "Normalization is a step in the logical design phase that follows conceptual design. The evidence shows that normalization is used for schema refinement after transforming the ER design to a relational schema, which comes after conceptual design.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0001", "lecture_id": "13-NFs-FDs", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "15-NFs-3NF__0017", "lecture_id": "15-NFs-3NF", "text": "- Conceptual design:  (ER & UML Models are used\n- for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\nWe'll discuss indexing next.\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0000"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "gap_lectures": 3}}}
{"A": {"name": "CONDITIONAL_CHECK", "role": "Definition"}, "B": {"name": "DATABASE_TRIGGER", "role": "Definition"}, "relation": "depends_on", "justification": "The evidence shows that a conditional check (IF statement) is used within the definition of a database trigger. This indicates that a conditional check is a necessary component that a database trigger depends on to function properly.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "7- ConstraintsTriggers__0034", "lecture_id": "7- ConstraintsTriggers", "text": "```\nCREATE TRIGGER DrinkTrig AFTER INSERT ON Sells FOR EACH ROW BEGIN SET @drink =(SELECT name FROM Drinks WHERE name = new.drink); IF @drink IS NULL THEN INSERT INTO Drinks(name,manf) VALUES(new.drink,'abdu'); END IF; END;\n```\nI ILLINOIS\n- Any Boolean -valued condition is appropriate.\n- It is evaluated before or after the triggering event, depending on whether BEFORE or AFTER is used in the event.\n- Use new/old to access the new/old tuple (row)."}, {"source": "chunk_co_occurrence", "chunk_id": "7- ConstraintsTriggers__0035", "lecture_id": "7- ConstraintsTriggers", "text": "```\nCREATE TRIGGER DrinkTrig AFTER INSERT ON Sells FOR EACH ROW BEGIN SET @drink =(SELECT name FROM Drinks WHERE name = new.drink); IF @drink IS NULL THEN INSERT INTO Drinks(name,manf) VALUES(new.drink,'abdu'); END IF; END;\n```\nI ILLINOIS\n- There can be more than one SQL statement in the action.\n- But queries make no sense in an action, so we are really limited to modifications."}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 19, "lecture_id": "7- ConstraintsTriggers", "chunk_id": "7- ConstraintsTriggers__0028"}, "A_first_introduced_at": {"lecture_index": 19, "lecture_id": "7- ConstraintsTriggers", "chunk_id": "7- ConstraintsTriggers__0016"}, "gap_lectures": 0}}}
{"A": {"name": "CONSTRAINTS", "role": "Definition"}, "B": {"name": "FOREIGN_KEY", "role": "NA"}, "relation": "part_of", "justification": "FOREIGN_KEY is a specific type of constraint, indicating that it is part of the broader concept of CONSTRAINTS.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "7- ConstraintsTriggers__0013", "lecture_id": "7- ConstraintsTriggers", "text": "```\nCREATE TABLE Sells ( cafe CHAR(20), drink CHAR(20), price REAL, FOREIGN KEY(drink) REFERENCES Drinks(name) ON DELETE SET NULL ON UPDATE CASCADE );\n```\nIILLINOIS\n- Constraints\n-  Foreign -key, or referential -integrity constraints.\n- Value -based constraints.\n- Tuple -based constraints.\n- Assertions.\n- Triggers"}, {"source": "chunk_co_occurrence", "chunk_id": "7- ConstraintsTriggers__0023", "lecture_id": "7- ConstraintsTriggers", "text": "- We can do attribute -based check, why tuple level?\n- Reason 1: If the check involves more than one attribute of the tuple, we need the tuple -level check.\n- Reason 2: Tuple -level constraints are checked more frequently.\n- Whenever there are any inserts or updates to any of the concerned attributes\nI\n- Constraints\n-  Foreign -key, or referential -integrity constraints.\n-  Value -based constraints.\n-  Tuple -based constraints.\n- Assertions.\n- Triggers"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0000"}, "A_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0030"}, "gap_lectures": 6}}}
{"A": {"name": "CONSTRAINTS", "role": "Definition"}, "B": {"name": "REFERENTIAL_INTEGRITY", "role": "NA"}, "relation": "part_of", "justification": "Referential integrity is a specific type of constraint within the broader concept of constraints.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "7- ConstraintsTriggers__0013", "lecture_id": "7- ConstraintsTriggers", "text": "```\nCREATE TABLE Sells ( cafe CHAR(20), drink CHAR(20), price REAL, FOREIGN KEY(drink) REFERENCES Drinks(name) ON DELETE SET NULL ON UPDATE CASCADE );\n```\nIILLINOIS\n- Constraints\n-  Foreign -key, or referential -integrity constraints.\n- Value -based constraints.\n- Tuple -based constraints.\n- Assertions.\n- Triggers"}, {"source": "chunk_co_occurrence", "chunk_id": "7- ConstraintsTriggers__0023", "lecture_id": "7- ConstraintsTriggers", "text": "- We can do attribute -based check, why tuple level?\n- Reason 1: If the check involves more than one attribute of the tuple, we need the tuple -level check.\n- Reason 2: Tuple -level constraints are checked more frequently.\n- Whenever there are any inserts or updates to any of the concerned attributes\nI\n- Constraints\n-  Foreign -key, or referential -integrity constraints.\n-  Value -based constraints.\n-  Tuple -based constraints.\n- Assertions.\n- Triggers"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0015"}, "A_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0030"}, "gap_lectures": 6}}}
{"A": {"name": "CYPHER_LANGUAGE", "role": "Definition"}, "B": {"name": "NODE_PROPERTIES", "role": "Definition"}, "relation": null, "justification": "The provided evidence does not clearly indicate a dependency or part_of relationship between CYPHER_LANGUAGE and NODE_PROPERTIES.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "11-Neo4J-Part2__0010", "lecture_id": "11-Neo4J-Part2", "text": "Source: https://neo4j.com/developer/cypher-query-language/"}, {"source": "chunk_co_occurrence", "chunk_id": "11-Neo4J-Part2__0011", "lecture_id": "11-Neo4J-Part2", "text": "Source: https://neo4j.com/developer/cypher-query-language/"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0027"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0019"}, "gap_lectures": 0}}}
{"A": {"name": "DATABASE_RELATIONS", "role": "Definition"}, "B": {"name": "ENTITY_IDENTIFICATION", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly establish a 'depends_on' or 'part_of' relationship between DATABASE_RELATIONS and ENTITY_IDENTIFICATION.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0019", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "Assignment(P-number, SSN) Project(P-number, P-name, Due-Date) Employee(SSN, E-Name, Office)"}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0019", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "Assignment(P-number, SSN) Project(P-number, P-name, Due-Date) Employee(SSN, E-Name, Office)"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0010"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0011"}, "gap_lectures": 0}}}
{"A": {"name": "DATABASE_SYSTEMS", "role": "Definition"}, "B": {"name": "DATA_MODELING", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly indicate a dependency or part_of relationship between DATABASE_SYSTEMS and DATA_MODELING.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "5- SQL4-AggGrpViews__0000", "lecture_id": "5- SQL4-AggGrpViews", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems\n工"}, {"source": "chunk_co_occurrence", "chunk_id": "7- ConstraintsTriggers__0000", "lecture_id": "7- ConstraintsTriggers", "text": "University of Illinois at Urbana -Champaign CS411: Database Systems\n工"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0006"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0020"}, "gap_lectures": -1}}}
{"A": {"name": "DATABASE_TRIGGER", "role": "Definition"}, "B": {"name": "INSERT_OPERATION", "role": "NA"}, "relation": "depends_on", "justification": "The evidence shows that a database trigger is activated after an insert operation, indicating that the insert operation is a prerequisite for the trigger to be executed.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "7- ConstraintsTriggers__0034", "lecture_id": "7- ConstraintsTriggers", "text": "```\nCREATE TRIGGER DrinkTrig AFTER INSERT ON Sells FOR EACH ROW BEGIN SET @drink =(SELECT name FROM Drinks WHERE name = new.drink); IF @drink IS NULL THEN INSERT INTO Drinks(name,manf) VALUES(new.drink,'abdu'); END IF; END;\n```\nI ILLINOIS\n- Any Boolean -valued condition is appropriate.\n- It is evaluated before or after the triggering event, depending on whether BEFORE or AFTER is used in the event.\n- Use new/old to access the new/old tuple (row)."}, {"source": "chunk_co_occurrence", "chunk_id": "7- ConstraintsTriggers__0035", "lecture_id": "7- ConstraintsTriggers", "text": "```\nCREATE TRIGGER DrinkTrig AFTER INSERT ON Sells FOR EACH ROW BEGIN SET @drink =(SELECT name FROM Drinks WHERE name = new.drink); IF @drink IS NULL THEN INSERT INTO Drinks(name,manf) VALUES(new.drink,'abdu'); END IF; END;\n```\nI ILLINOIS\n- There can be more than one SQL statement in the action.\n- But queries make no sense in an action, so we are really limited to modifications."}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 19, "lecture_id": "7- ConstraintsTriggers", "chunk_id": "7- ConstraintsTriggers__0033"}, "A_first_introduced_at": {"lecture_index": 19, "lecture_id": "7- ConstraintsTriggers", "chunk_id": "7- ConstraintsTriggers__0028"}, "gap_lectures": 0}}}
{"A": {"name": "DATA_MODELING", "role": "NA"}, "B": {"name": "STORAGE_STRUCTURES", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly indicate a dependency or part_of relationship between DATA_MODELING and STORAGE_STRUCTURES.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "5- SQL4-AggGrpViews__0000", "lecture_id": "5- SQL4-AggGrpViews", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems\n工"}, {"source": "chunk_co_occurrence", "chunk_id": "7- ConstraintsTriggers__0000", "lecture_id": "7- ConstraintsTriggers", "text": "University of Illinois at Urbana -Champaign CS411: Database Systems\n工"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0001"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0006"}, "gap_lectures": -8}}}
{"A": {"name": "DATA_MODELING", "role": "NA"}, "B": {"name": "TRANSACTION_MANAGEMENT", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly indicate a dependency or part_of relationship between DATA_MODELING and TRANSACTION_MANAGEMENT.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "5- SQL4-AggGrpViews__0000", "lecture_id": "5- SQL4-AggGrpViews", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems\n工"}, {"source": "chunk_co_occurrence", "chunk_id": "7- ConstraintsTriggers__0000", "lecture_id": "7- ConstraintsTriggers", "text": "University of Illinois at Urbana -Champaign CS411: Database Systems\n工"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0001"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0006"}, "gap_lectures": -8}}}
{"A": {"name": "DATA_NORMALIZATION", "role": "NA"}, "B": {"name": "FUNCTIONAL_DEPENDENCIES", "role": "NA"}, "relation": null, "justification": "No decision (LLM output invalid).", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0016", "lecture_id": "13-NFs-FDs", "text": "EMP(name, SSN, birthdate, address, dnum, dname, dmgr)\nJohn 111 June 3 123 St.      D1     sales     222\nSue 222 May 15 455 St.     D1     sales     222\nMax       333 Mar. 5 678 St.     D2    research 333\nWei 444 May 2 999 St.     D2    research 333\nTom 555 June 22 888 St.     D2    research 333\ndname and dmgr are stored redundantly - whenever there are multiple employees in a department.\nThis redundancy is caused by what we informally call 'troublesome' FDs. The FDs shown in blue are 'troublesome'."}, {"source": "chunk_co_occurrence", "chunk_id": "15-NFs-3NF__0003", "lecture_id": "15-NFs-3NF", "text": "1234, Address = 10 Downing. 1234, Phone = 1234. 1234, Name = John. 5678, Address = 10 Downing. 5678, Phone = 5678. 5678, Name = John\nFD '\ns:  Phone \nAddress;      Address, Name  Phone\nNo problem so far. All\nlocal FD ' s are satisfied.\nLet's put all the data into a single table:\n1234, Address = 10 Downing. 1234, Name = John. 5678, Address = 10 Downing. 5678, Name = John\nViolates the dependency:   Address, Name\n Phone"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0003"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0018"}, "gap_lectures": -2}, "_error": "Unbalanced JSON braces in output."}}
{"A": {"name": "DECOMPOSITION", "role": "Example"}, "B": {"name": "FUNCTIONAL_DEPENDENCIES", "role": "NA"}, "relation": "depends_on", "justification": "The evidence shows that functional dependencies are used as a basis for decomposition in the normalization process, indicating that understanding functional dependencies is a prerequisite for performing decomposition.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "15-NFs-3NF__0013", "lecture_id": "15-NFs-3NF", "text": "- R(A, B, C) with FDs: · A  BC; B  AC; C  AB\nMinimal Basis: A\n B; B  C; C  A\nSo, first cut: R1(A, B), R2(B, C), R3(C, A) Any attributes left? Nope  done\n- R(A, B, C, D, E) with FDs:\n- A  B; CD  B; DA  C\nBCNF Decomp:\n```\n(AB), (ACD), (ADE) or: (BCD), (ACD), (ADE)\n```\nWhich FDs do each of these not preserve?"}, {"source": "chunk_co_occurrence", "chunk_id": "DBDesign_BCNF__0003", "lecture_id": "DBDesign_BCNF", "text": "- X  A is OK, if X is a (super)key\n- X  A is NOT OK, otherwise\n- Need to decompose the table, but how?\nBoyce-Codd Normal Form (BCNF)"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0003"}, "A_first_introduced_at": {"lecture_index": 7, "lecture_id": "15-NFs-3NF", "chunk_id": "15-NFs-3NF__0002"}, "gap_lectures": 1}}}
{"A": {"name": "DOCUMENT_ORIENTED", "role": "Definition"}, "B": {"name": "QUERY_LANGUAGE", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly establish a 'depends_on' or 'part_of' relationship between 'DOCUMENT_ORIENTED' and 'QUERY_LANGUAGE'. The evidence only mentions both concepts in the context of MongoDB but does not indicate a clear prerequisite or component relationship.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "8- NoSQL-MongoDB-Basics__0012", "lecture_id": "8- NoSQL-MongoDB-Basics", "text": "-  NoSQL Introduction\n- MongoDB\n- Model and simple queries\nI IllinoIS\n- MongoDB is an example of a document-oriented NoSQL solution\n- The query language is limited, and oriented around ' collection ' (relation) at a time processing\n- The power of the solution lies in the distributed, parallel nature of query processing\n- Replication and sharding"}, {"source": "chunk_co_occurrence", "chunk_id": "8- NoSQL-MongoDB-Basics__0027", "lecture_id": "8- NoSQL-MongoDB-Basics", "text": "- NoSQL solutions address the needs of modern applications\n- MongoDB is an example of a document-oriented solution\n- The query language is oriented around ' collection ' at a time processing\n- The power of many of these solutions lies in the distributed, parallel nature of query processing\n- Replication and sharding"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0007"}, "A_first_introduced_at": {"lecture_index": 20, "lecture_id": "8- NoSQL-MongoDB-Basics", "chunk_id": "8- NoSQL-MongoDB-Basics__0002"}, "gap_lectures": 19}}}
{"A": {"name": "ENTITIES_RELATIONSHIPS", "role": "NA"}, "B": {"name": "NORMALIZATION", "role": "NA"}, "relation": "depends_on", "justification": "Normalization requires an understanding of entities and relationships in the context of database design, as entities and relationships are part of the conceptual design phase which precedes normalization.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0001", "lecture_id": "13-NFs-FDs", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "15-NFs-3NF__0017", "lecture_id": "15-NFs-3NF", "text": "- Conceptual design:  (ER & UML Models are used\n- for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\nWe'll discuss indexing next.\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0000"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "gap_lectures": 3}}}
{"A": {"name": "ENTITY", "role": "Definition"}, "B": {"name": "ENTITY_SET", "role": "Definition"}, "relation": "part_of", "justification": "The evidence shows that an entity set is a collection of similar entities, indicating that an entity is a component of an entity set.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0005", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Entity: Real-world object distinguishable from  other objects. An entity is described using a set of attributes .\n- Entity Set :  A collection of similar entities.  E.g., all employees. (often referred to as just entity, which blurs the distinction between type and collection)\n- Relationship :  Association among 2 or more entities.  E.g., Kristin's home department is Research & Development.\n- Relationship Set :  Collection of similar relationships.  E.g., Home (often referred to as just relationship)\n- Formal definition:\n- if A, B are sets, then a relation R is a subset of A x B\n- A={1,2,3},   B={a,b,c,d}, R = {(1,a), (1,c), (3,b)}\nSame story w/ entity sets sponsor is a subset of Project x Department :"}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0005", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Entity: Real-world object distinguishable from  other objects. An entity is described using a set of attributes .\n- Entity Set :  A collection of similar entities.  E.g., all employees. (often referred to as just entity, which blurs the distinction between type and collection)\n- Relationship :  Association among 2 or more entities.  E.g., Kristin's home department is Research & Development.\n- Relationship Set :  Collection of similar relationships.  E.g., Home (often referred to as just relationship)\n- Formal definition:\n- if A, B are sets, then a relation R is a subset of A x B\n- A={1,2,3},   B={a,b,c,d}, R = {(1,a), (1,c), (3,b)}\nSame story w/ entity sets sponsor is a subset of Project x Department :"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0005"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0005"}, "gap_lectures": 0}}}
{"A": {"name": "ENTITY", "role": "Definition"}, "B": {"name": "RELATIONSHIP_SET", "role": "Definition"}, "relation": null, "justification": "The evidence does not clearly establish a 'depends_on' or 'part_of' relationship between 'ENTITY' and 'RELATIONSHIP_SET'. Both concepts are defined independently without indicating a clear prerequisite or subset relationship.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0005", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Entity: Real-world object distinguishable from  other objects. An entity is described using a set of attributes .\n- Entity Set :  A collection of similar entities.  E.g., all employees. (often referred to as just entity, which blurs the distinction between type and collection)\n- Relationship :  Association among 2 or more entities.  E.g., Kristin's home department is Research & Development.\n- Relationship Set :  Collection of similar relationships.  E.g., Home (often referred to as just relationship)\n- Formal definition:\n- if A, B are sets, then a relation R is a subset of A x B\n- A={1,2,3},   B={a,b,c,d}, R = {(1,a), (1,c), (3,b)}\nSame story w/ entity sets sponsor is a subset of Project x Department :"}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0005", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Entity: Real-world object distinguishable from  other objects. An entity is described using a set of attributes .\n- Entity Set :  A collection of similar entities.  E.g., all employees. (often referred to as just entity, which blurs the distinction between type and collection)\n- Relationship :  Association among 2 or more entities.  E.g., Kristin's home department is Research & Development.\n- Relationship Set :  Collection of similar relationships.  E.g., Home (often referred to as just relationship)\n- Formal definition:\n- if A, B are sets, then a relation R is a subset of A x B\n- A={1,2,3},   B={a,b,c,d}, R = {(1,a), (1,c), (3,b)}\nSame story w/ entity sets sponsor is a subset of Project x Department :"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0005"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0005"}, "gap_lectures": 0}}}
{"A": {"name": "ENTITY_IDENTIFICATION", "role": "NA"}, "B": {"name": "REFERENTIAL_INTEGRITY", "role": "Definition"}, "relation": "depends_on", "justification": "Referential integrity constraints depend on the identification of entities, as they ensure relationships between entities are valid and consistent.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0010", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "Finding constraints is part of the modeling process. Commonly used constraints:\n-  Keys: attributes that identify entities in an entity set e.g., social security number uniquely identifies a person.\n- \n- Referential integrity constraints: relationship-based constraints\n- e.g., if you work for a company, it must exist in the database.\n-  Domain constraints:  peoples ' ages are between 0 and 150.\n-  General constraints: all others (at most 50 students enroll in a class)"}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0010", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "Finding constraints is part of the modeling process. Commonly used constraints:\n-  Keys: attributes that identify entities in an entity set e.g., social security number uniquely identifies a person.\n- \n- Referential integrity constraints: relationship-based constraints\n- e.g., if you work for a company, it must exist in the database.\n-  Domain constraints:  peoples ' ages are between 0 and 150.\n-  General constraints: all others (at most 50 students enroll in a class)"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0015"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0010"}, "gap_lectures": 4}}}
{"A": {"name": "ENTITY_SET", "role": "Definition"}, "B": {"name": "RELATIONSHIP", "role": "Definition"}, "relation": null, "justification": "The evidence does not clearly indicate a dependency or a part_of relationship between ENTITY_SET and RELATIONSHIP. Both concepts are defined independently without one being a prerequisite or a component of the other.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0005", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Entity: Real-world object distinguishable from  other objects. An entity is described using a set of attributes .\n- Entity Set :  A collection of similar entities.  E.g., all employees. (often referred to as just entity, which blurs the distinction between type and collection)\n- Relationship :  Association among 2 or more entities.  E.g., Kristin's home department is Research & Development.\n- Relationship Set :  Collection of similar relationships.  E.g., Home (often referred to as just relationship)\n- Formal definition:\n- if A, B are sets, then a relation R is a subset of A x B\n- A={1,2,3},   B={a,b,c,d}, R = {(1,a), (1,c), (3,b)}\nSame story w/ entity sets sponsor is a subset of Project x Department :"}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0005", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Entity: Real-world object distinguishable from  other objects. An entity is described using a set of attributes .\n- Entity Set :  A collection of similar entities.  E.g., all employees. (often referred to as just entity, which blurs the distinction between type and collection)\n- Relationship :  Association among 2 or more entities.  E.g., Kristin's home department is Research & Development.\n- Relationship Set :  Collection of similar relationships.  E.g., Home (often referred to as just relationship)\n- Formal definition:\n- if A, B are sets, then a relation R is a subset of A x B\n- A={1,2,3},   B={a,b,c,d}, R = {(1,a), (1,c), (3,b)}\nSame story w/ entity sets sponsor is a subset of Project x Department :"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0005"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0005"}, "gap_lectures": 0}}}
{"A": {"name": "FOREIGN_KEY", "role": "NA"}, "B": {"name": "SINGLE_TABLE", "role": "Definition"}, "relation": "depends_on", "justification": "FOREIGN_KEY is used in the context of translating weak entity sets and supporting relationship sets into a single table, indicating that understanding FOREIGN_KEY is a prerequisite for working with SINGLE_TABLE.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0022", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Weak entity sets and supporting relationship sets are translated into a single table.  Must include key of supporting entity set, as a foreign key.\n- When the owner entity is deleted, all owned weak entities must also be deleted.\nCREATE TABLE  Insurance_Policy (\ndep-name\nCHAR(20),\ncost\nREAL,\nssn\nCHAR(11) NOT NULL,\nPRIMARY KEY  (dep-name, ssn),\nFOREIGN KEY (ssn) REFERENCES Employee, ON DELETE CASCADE)"}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0022", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Weak entity sets and supporting relationship sets are translated into a single table.  Must include key of supporting entity set, as a foreign key.\n- When the owner entity is deleted, all owned weak entities must also be deleted.\nCREATE TABLE  Insurance_Policy (\ndep-name\nCHAR(20),\ncost\nREAL,\nssn\nCHAR(11) NOT NULL,\nPRIMARY KEY  (dep-name, ssn),\nFOREIGN KEY (ssn) REFERENCES Employee, ON DELETE CASCADE)"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0022"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0000"}, "gap_lectures": -4}}}
{"A": {"name": "FOREIGN_KEYS", "role": "Definition"}, "B": {"name": "REFERENTIAL_INTEGRITY", "role": "Definition"}, "relation": "depends_on", "justification": "FOREIGN_KEYS are a prerequisite for understanding REFERENTIAL_INTEGRITY, as REFERENTIAL_INTEGRITY relies on the concept of FOREIGN_KEYS to enforce constraints.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "1-RelationalModel__0015", "lecture_id": "1-RelationalModel", "text": ", Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. , Number = 102. , Owner = W. Wei. , Balance = 2000.00. , Type = checking. , Number = 103. , Owner = J. Smith. , Balance = 5000.00. , Type = savings. , Number = 104. , Owner = M. Jones. , Balance = 1000.00. , Type = checking. , Number = 105. , Owner = H. Martin. , Balance = 10,000.00. , Type = checking. Deposit, Number = AcctNo Transaction-id. Deposit, Owner = Date. Deposit, Balance = Amount. Deposit, Type = . , Number = 102 1. , Owner = 10/22/00. , Balance = 500.00. , Type = . , Number = 102 2. , Owner = 10/29/00. , Balance = 200.00. , Type = . , Number = 104 3. , Owner = 10/29/00. , Balance = 1000.00. , Type = . , Number = 105 4. , Owner = 11/02/00. , Balance = 10,000.00. , Type = . , Number = 106 5. , Owner = 12/05/00. , Balance = 555.00. , Type = \nWe say that Deposit.AcctNo is a foreign key that references Account.Number.  If the DBMS enforces this constraint, we have referential integrity .\n, Foreign keys might or might not be part of the key for the referring table.Number = 101 102 103 104 105. , Foreign keys might or might not be part of the key for the referring table.Owner = J. Smith W. Wei J. Smith M. Jones H. Martin. , Foreign keys might or might not be part of the key for the referring table.Balance = 1000.00 2000.00 5000.00 1000.00 10,000.00. , Foreign keys might or might not be part of the key for the referring table.Type = checking checking savings checking checking. Deposit, Foreign keys might or might not be part of the key for the referring table.Number = AcctNo. Deposit, Foreign keys might or might not be part of the key for the referring table.Owner = Transaction-id. Deposit, Foreign keys might or might not be part of the key for the referring table.Balance = Date. Deposit, Foreign keys might or might not be part of the key for the referring table.Type = Amount. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Number = AcctNo 101 101. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Owner = Check-number 924 925. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Balance = Date 10/23/00 10/24/00. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Type = Amount 125.00 23.98\n-  Data Models\n- Relational Database Model\n-  Basic Concepts and Terminology\n-  Keys and Foreign Keys\n- Schema Specifications"}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0018", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nMgrSSN is a foreign key (referencing the Employee relation)\nvalue of Manager must match an SSN\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nvs.\nProject(P-number, P-name, Due-Date)\nEmployee(SSN, E-Name, Office)\nManager(P-number, SSN)\nWhat are the tradeoffs between these two?\nNote: P-number is the key for Manager"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 2, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0015"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "gap_lectures": 0}}}
{"A": {"name": "FOREIGN_KEYS", "role": "NA"}, "B": {"name": "RELATIONAL_MODEL", "role": "Definition"}, "relation": "part_of", "justification": "Foreign keys are a component of the relational model, as they are listed alongside other elements such as tables, attributes, and keys within the relational model's definition.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0001", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Relational model has:\n- tables (relations) with attributes, keys, foreign keys, domain definitions for attributes"}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0001", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Relational model has:\n- tables (relations) with attributes, keys, foreign keys, domain definitions for attributes"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0000"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "gap_lectures": 0}}}
{"A": {"name": "FROM_CLAUSE", "role": "NA"}, "B": {"name": "WHERE_CLAUSE", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly indicate a dependency or part-of relationship between FROM_CLAUSE and WHERE_CLAUSE. Both clauses are used in SQL queries but are not shown to depend on or be part of each other in a clear hierarchical manner.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "2-SQL-Basics__0005", "lecture_id": "2-SQL-Basics", "text": "Account, 1 = Number. Account, 2 = Owner. Account, 3 = Balance. Account, 4 = T\\pe. , 1 = 101. , 2 = J. Smith. , 3 = 1000.00. , 4 = checking. , 1 = 102. , 2 = W. Wei. , 3 = 2000.00. , 4 = checking. , 1 = 103. , 2 = J. Smith. , 3 = 5000.00. , 4 = savings. , 1 = 104. , 2 = M. Jones. , 3 = 1000.00. , 4 = checking. , 1 = 105. , 2 = H. Martin. , 3 = 10,000.00. , 4 = checking\nSELECT, 1 = Number, Owner. FROM, 1 = Account. WHERE, 1 = T\\pe = \" savings \" ;\nNumber, 1 = Owner\n103\nJ. Smith"}, {"source": "chunk_co_occurrence", "chunk_id": "4-AdvSQL-SubqueriesSetOps__0002", "lecture_id": "4-AdvSQL-SubqueriesSetOps", "text": "- A parenthesized SELECT-FROM-WHERE statement ( subquery ) can be used as a value in a number of places, including FROM and WHERE clauses.\n```\nSELECT * FROM (SELECT * FROM Customer WHERE name LIKE 'A%') as temp WHERE temp.phone LIKE '5%';\n```"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 10, "lecture_id": "2-SQL-Basics", "chunk_id": "2-SQL-Basics__0005"}, "A_first_introduced_at": {"lecture_index": 10, "lecture_id": "2-SQL-Basics", "chunk_id": "2-SQL-Basics__0005"}, "gap_lectures": 0}}}
{"A": {"name": "FUNCTIONAL_DEPENDENCIES", "role": "NA"}, "B": {"name": "SUPERKEY", "role": "NA"}, "relation": "depends_on", "justification": "The evidence shows that understanding superkeys is necessary to determine if a functional dependency is valid or needs decomposition, indicating that functional dependencies depend on the concept of superkeys.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "15-NFs-3NF__0012", "lecture_id": "15-NFs-3NF", "text": "1. Get a ' minimal basis ' G of given FDs\n2. For each FD A  B in the minimal basis G , use AB as the schema of a new relation.\n3. If none of the schemas from Step 2 is a superkey, add another relation whose schema is a key for the original relation.\nResult will be lossless, will be dependency-preserving, 3NF; might not be BCNF\n1. Get a ' minimal basis ' G of given FDs\n2. For each FD A  B in the minimal basis G , use AB as the schema of a new relation.\n3. If none of the schemas from Step 2 is a superkey, add another relation whose schema is a key for the original relation.\nResult will be lossless, will be dependency-preserving, Basically every minimal FD is preserved somewhere Implicitly this is connecting all the LHSs with the remaining attributes"}, {"source": "chunk_co_occurrence", "chunk_id": "DBDesign_BCNF__0003", "lecture_id": "DBDesign_BCNF", "text": "- X  A is OK, if X is a (super)key\n- X  A is NOT OK, otherwise\n- Need to decompose the table, but how?\nBoyce-Codd Normal Form (BCNF)"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 7, "lecture_id": "15-NFs-3NF", "chunk_id": "15-NFs-3NF__0012"}, "A_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0003"}, "gap_lectures": -1}}}
{"A": {"name": "KEYS", "role": "Definition"}, "B": {"name": "RELATIONAL_MODEL", "role": "Definition"}, "relation": "part_of", "justification": "The evidence shows that keys are components of the relational model, indicating that keys are part of the broader concept of the relational model.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0001", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Relational model has:\n- tables (relations) with attributes, keys, foreign keys, domain definitions for attributes"}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0001", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Relational model has:\n- tables (relations) with attributes, keys, foreign keys, domain definitions for attributes"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0000"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "gap_lectures": 0}}}
{"A": {"name": "KEYS", "role": "Definition"}, "B": {"name": "RELATIONSHIPS", "role": "Definition"}, "relation": "depends_on", "justification": "The evidence suggests that keys are introduced and defined before discussing relationships among entities, indicating that understanding keys is a prerequisite for understanding relationships.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0002", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Entities and entity sets with attributes, keys, and domain definitions for attributes\n- Relationships among entities and relationship sets with uniqueness or cardinality constraints"}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0002", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Entities and entity sets with attributes, keys, and domain definitions for attributes\n- Relationships among entities and relationship sets with uniqueness or cardinality constraints"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0002"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "gap_lectures": -1}}}
{"A": {"name": "LOGICAL_DESIGN", "role": "NA"}, "B": {"name": "NORMALIZATION", "role": "NA"}, "relation": "depends_on", "justification": "Normalization is a step in the logical design process where the relational schema is refined to eliminate redundancies and related anomalies.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0001", "lecture_id": "13-NFs-FDs", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "15-NFs-3NF__0017", "lecture_id": "15-NFs-3NF", "text": "- Conceptual design:  (ER & UML Models are used\n- for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\nWe'll discuss indexing next.\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0000"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "gap_lectures": 3}}}
{"A": {"name": "MEMORY_CONSTRAINT", "role": "NA"}, "B": {"name": "ONE_PASS_ALGORITHM", "role": "NA"}, "relation": "depends_on", "justification": "The evidence shows that the one-pass algorithm is used under the assumption that the memory constraint (B(R) + B(S) <= M(M-1)) is satisfied, indicating that MEMORY_CONSTRAINT is a prerequisite for using the ONE_PASS_ALGORITHM.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "QP__0015", "lecture_id": "QP", "text": "Binary operations: R ∩ S, R U S, R - S\n- Idea: sort R, sort S, then do the right thing\n- What do we sort on?\n- A closer look:\n- Step 1: split R into sorted runs of size M, then split S into sorted runs of size M.  Cost: 2B(R) + 2B(S)\n- Step 2: merge all x runs from R; merge all y runs from S; output a tuple on a case by case basis ( x + y <= M-1)\n- Why do we need all the sorted runs in memory at once?\n- Total cost: ??\n- 3B(R)+3B(S)\n- Assumption: B(R)+B(S)<= M(M-1) < M 2\nJoin R      S. Let's recap what we've seen so far -- extremes  \n- (a) min(B(R), B(S)) <= M-2: Load smaller table to memory and load other table block by block. Cost: B(R)+B(S). This is the one-pass algorithm.\n- (b) Min(B(R), B(S)) > M-2: Load to memory M-2 blocks of S; go over every block of R; repeat. Cost: ~B(R)B(S)/M. This is the nested-loop join algorithm, can operate whenever M >= 3\nNested loop join is the only option if Min(B(R), B(S))>M-2, but is too expensive, quadratic ( B(R)B(S)).\nJoin R       S  \n- Start by writing out runs of R and S on the join attribute:\n- Cost: 2B(R)+2B(S)  (because need to write to disk)\n- 'Merge' runs of both relations in sorted order, match tuples\n- Cost: B(R)+B(S)\n- Total cost: 3B(R)+3B(S)\n- Assumption: B(R) + B(S) <= M (M-1)\n- One difficulty: many tuples in R may match many in S\n- If at least one set of tuples fits in M, we are OK\n- Otherwise need nested loop, higher cost\n- But let's assume that this is not the case; we are in a good situation - can we do even better?\n- See Section 15.4.6."}, {"source": "chunk_co_occurrence", "chunk_id": "QP__0020", "lecture_id": "QP", "text": "R        S  \n- Hash S into (M-1) buckets, using join attribute(s) as hash key\n- Step 1:\n- Send all buckets to disk\n- Hash R into (M-1) buckets, using join attribute(s) as hash key\n- Step 2\n- Send all buckets to disk\n- Join every pair of buckets with the same bucket number. Use the one pass algorithm for this.\n- Step 3\n- Works when for each bucket no. i , either R i or S i fits in memory.\n- min(B(R), B(S))/(M-1) <= (M-2)  min(B(R), B(S)) <= (M-1)(M-2) < M 2\n- Cost = 3(B(R)+B(S))"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 24, "lecture_id": "QP", "chunk_id": "QP__0015"}, "A_first_introduced_at": {"lecture_index": 13, "lecture_id": "21b-IntroPhysicalOperators", "chunk_id": "21b-IntroPhysicalOperators__0008"}, "gap_lectures": -11}}}
{"A": {"name": "NORMALIZATION", "role": "NA"}, "B": {"name": "PHYSICAL_DESIGN", "role": "NA"}, "relation": "depends_on", "justification": "Normalization is a prerequisite step that ensures the logical design of the database is free from redundancies and anomalies, which is necessary before proceeding to the physical design and tuning of the database.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0001", "lecture_id": "13-NFs-FDs", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "15-NFs-3NF__0017", "lecture_id": "15-NFs-3NF", "text": "- Conceptual design:  (ER & UML Models are used\n- for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\nWe'll discuss indexing next.\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0000"}, "gap_lectures": -3}}}
{"A": {"name": "NORMALIZATION", "role": "NA"}, "B": {"name": "RELATIONAL_SCHEMA", "role": "NA"}, "relation": "depends_on", "justification": "Normalization is a process applied to relational schemas to eliminate redundancies and related anomalies, indicating that understanding relational schemas is a prerequisite for normalization.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0001", "lecture_id": "13-NFs-FDs", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "15-NFs-3NF__0017", "lecture_id": "15-NFs-3NF", "text": "- Conceptual design:  (ER & UML Models are used\n- for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\nWe'll discuss indexing next.\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0000"}, "gap_lectures": -3}}}
{"A": {"name": "NORMALIZATION", "role": "NA"}, "B": {"name": "SCHEMA_REFINEMENT", "role": "Definition"}, "relation": "part_of", "justification": "Normalization is described as a component of schema refinement in the provided evidence.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0001", "lecture_id": "13-NFs-FDs", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "chunk_co_occurrence", "chunk_id": "15-NFs-3NF__0017", "lecture_id": "15-NFs-3NF", "text": "- Conceptual design:  (ER & UML Models are used\n- for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\nWe'll discuss indexing next.\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0000"}, "gap_lectures": -3}}}
{"A": {"name": "OVERFLOW_BLOCKS", "role": "NA"}, "B": {"name": "SECONDARY_STORAGE", "role": "NA"}, "relation": "depends_on", "justification": "Overflow blocks are used when secondary storage hash tables need additional space, indicating that understanding secondary storage is a prerequisite for understanding overflow blocks.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "18-HashTables__0001", "lecture_id": "18-HashTables", "text": "- Secondary storage hash tables are much like main memory ones\n- Recall basics:\n- There are B buckets\n- A hash function h(k) maps a key k to {0, 1, …, B-1}\n- Store in bucket h(k) a pointer to record with key k\n- Secondary storage: bucket = block\n- Store in the block of bucket h(k) any record with key k\n- use overflow blocks when needed"}, {"source": "chunk_co_occurrence", "chunk_id": "18-HashTables__0005", "lecture_id": "18-HashTables", "text": "- Fixed number of buckets\n- Excellent, if no overflow blocks\n- Degrades considerably when there are many overflow blocks.\n- Might need to go through a chain of overflow blocks\nCan improve this by allowing the number of buckets to grow\n- Hash Tables\n-  Secondary storage HT\n- Extensible HT\n- Linear HT"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 2, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 8, "lecture_id": "18-HashTables", "chunk_id": "18-HashTables__0000"}, "A_first_introduced_at": {"lecture_index": 8, "lecture_id": "18-HashTables", "chunk_id": "18-HashTables__0001"}, "gap_lectures": 0}}}
{"A": {"name": "PROJECTION", "role": "NA"}, "B": {"name": "RELATIONAL_ALGEBRA", "role": "NA"}, "relation": "part_of", "justification": "The evidence shows that projection is used as an operation within the context of relational algebra, indicating that projection is a component of relational algebra.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "21-RA__0016", "lecture_id": "21-RA", "text": "- Using Sells(cafe, drink, price), find the cafes that sell two different drinks at the same price.\n- R1:=  Sells1(cafe, drink1, price) Sells\n- R2:=  NOT (drink1 = drink) (R1         Sells)\n- R3:=  cafe R2"}, {"source": "chunk_co_occurrence", "chunk_id": "21-RA__0019", "lecture_id": "21-RA", "text": "- Using Sells(cafe, drink, price), find the cafes that sell two different drinks at the same price.\n- R1:=  Sells1(cafe, drink1, price) Sells\n- R2:=  NOT (drink1 = drink) R1         Sells\n- R3:=  cafe R2"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0002"}, "A_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0004"}, "gap_lectures": 0}}}
{"A": {"name": "READ_OPERATION", "role": "NA"}, "B": {"name": "TRANSACTION_ISOLATION", "role": "NA"}, "relation": null, "justification": "No decision (LLM output invalid).", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0020", "lecture_id": "20-Trxn-Serializability", "text": "T1:, 1 = R(A),. T1:, 2 = R(C). T1:, 3 = W(B). T2: T3:, 1 = R(B). T2: T3:, 2 = . T2: T3:, 3 = R(B)\n```\nS1(A); R1(A); S2(B) R2(B); S3(A); R3(A); X2(C); W2(C); REL2(C); S1(C); R1(C); R2(B); REL2(B); X1(B); W1(B); REL1(A,B,C); S3(B); R3(B); REL3(A,B);\n```"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0025", "lecture_id": "20-Trxn-Serializability", "text": "T1:, 1 = R(A),. T1:, 2 = R(C). T1:, 3 = W(B). T2: T3:, 1 = R(B). T2: T3:, 2 = . T2: T3:, 3 = R(B)\n```\nS1(A); R1(A); S2(B) R2(B); S3(A); R3(A); X2(C); W2(C); S1(C) <T1 WAIT ON C>; R2(B); COMMIT REL2(B,C); S1(C); R1(C); X1(B); W1(B); COMMIT; REL1(A,B,C); S3(B); R3(B); COMMIT; REL3(A,B);\n```"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0013"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0021"}, "gap_lectures": 0}, "_error": "Expecting ',' delimiter: line 9 column 436 (char 1241)"}}
{"A": {"name": "READ_UNCOMMITTED", "role": "Definition"}, "B": {"name": "REPEATABLE_READ", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly indicate a dependency or part_of relationship between READ_UNCOMMITTED and REPEATABLE_READ. Both concepts are listed as transaction isolation levels but do not show a clear prerequisite or component relationship.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0027", "lecture_id": "19-Trxn-Mgmt", "text": "- To signal to the system that a dirty read is acceptable,\nSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\n- In addition, there are\nSET TRANSACTION ISOLATION LEVEL READ COMMITTED; SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;"}, {"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0030", "lecture_id": "19-Trxn-Mgmt", "text": "READ UN- COMMITTED, Dirty Read = Maybe. READ UN- COMMITTED, Unrepeatable Read = Maybe. READ UN- COMMITTED, Phantoms = Maybe. READ COMMITTED, Dirty Read = No. READ COMMITTED, Unrepeatable Read = Maybe. READ COMMITTED, Phantoms = Maybe. REPEATABLE READ, Dirty Read = No. REPEATABLE READ, Unrepeatable Read = No. REPEATABLE READ, Phantoms = Maybe. SERIALIZABLE, Dirty Read = No. SERIALIZABLE, Unrepeatable Read = No. SERIALIZABLE, Phantoms = No"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0027"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0027"}, "gap_lectures": 0}}}
{"A": {"name": "READ_UNCOMMITTED", "role": "Definition"}, "B": {"name": "TRANSACTION_ISOLATION", "role": "NA"}, "relation": "part_of", "justification": "READ_UNCOMMITTED is a specific level of transaction isolation, indicating it is a part of the broader concept of transaction isolation.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0027", "lecture_id": "19-Trxn-Mgmt", "text": "- To signal to the system that a dirty read is acceptable,\nSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\n- In addition, there are\nSET TRANSACTION ISOLATION LEVEL READ COMMITTED; SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;"}, {"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0036", "lecture_id": "19-Trxn-Mgmt", "text": "READ UNCOMMITTED allows queries in the transaction to read data without acquiring any lock\n- Access mode READ ONLY, no updates are allowed\nREAD COMMITTED requires a read-lock to be obtained for all tuples touched by queries, but it releases the locks immediately after the read\n- Exclusive locks must be obtained for updates and held to end of transaction"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0013"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0027"}, "gap_lectures": 0}}}
{"A": {"name": "REFERENTIAL_INTEGRITY", "role": "Definition"}, "B": {"name": "TRIGGERS", "role": "Definition"}, "relation": "depends_on", "justification": "Referential integrity constraints are introduced as a type of database constraint, and triggers are introduced as a separate concept. The evidence suggests that triggers can be used to enforce referential integrity, implying that understanding triggers is necessary to fully understand how referential integrity can be maintained.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "7- ConstraintsTriggers__0001", "lecture_id": "7- ConstraintsTriggers", "text": "After this lecture, you should be able to:\n- Define Database Constraints, including\n- Referential integrity constraints\n- Attribute -level constraints\n- Tuple -level constraints\n- Assertions\n- Define database triggers\n2\n- Constraints\n- Foreign -key, or referential -integrity constraints.\n- Value -based constraints.\n- Tuple -based constraints.\n- Assertions.\n- Triggers"}, {"source": "chunk_co_occurrence", "chunk_id": "7- ConstraintsTriggers__0023", "lecture_id": "7- ConstraintsTriggers", "text": "- We can do attribute -based check, why tuple level?\n- Reason 1: If the check involves more than one attribute of the tuple, we need the tuple -level check.\n- Reason 2: Tuple -level constraints are checked more frequently.\n- Whenever there are any inserts or updates to any of the concerned attributes\nI\n- Constraints\n-  Foreign -key, or referential -integrity constraints.\n-  Value -based constraints.\n-  Tuple -based constraints.\n- Assertions.\n- Triggers"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 19, "lecture_id": "7- ConstraintsTriggers", "chunk_id": "7- ConstraintsTriggers__0001"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0015"}, "gap_lectures": -19}}}
{"A": {"name": "RELATIONAL_ALGEBRA", "role": "NA"}, "B": {"name": "RENAME", "role": "NA"}, "relation": "part_of", "justification": "RENAME is a specific operation within the broader concept of RELATIONAL_ALGEBRA, as evidenced by its use in the provided relational algebra examples.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "21-RA__0016", "lecture_id": "21-RA", "text": "- Using Sells(cafe, drink, price), find the cafes that sell two different drinks at the same price.\n- R1:=  Sells1(cafe, drink1, price) Sells\n- R2:=  NOT (drink1 = drink) (R1         Sells)\n- R3:=  cafe R2"}, {"source": "chunk_co_occurrence", "chunk_id": "21-RA__0019", "lecture_id": "21-RA", "text": "- Using Sells(cafe, drink, price), find the cafes that sell two different drinks at the same price.\n- R1:=  Sells1(cafe, drink1, price) Sells\n- R2:=  NOT (drink1 = drink) R1         Sells\n- R3:=  cafe R2"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0004"}, "A_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0002"}, "gap_lectures": 0}}}
{"A": {"name": "RELATIONAL_ALGEBRA", "role": "NA"}, "B": {"name": "SELECTION", "role": "NA"}, "relation": "depends_on", "justification": "The evidence shows that SELECTION is used as an operation within RELATIONAL_ALGEBRA to filter rows based on certain conditions, indicating that SELECTION is a prerequisite operation in the context of RELATIONAL_ALGEBRA.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "21-RA__0016", "lecture_id": "21-RA", "text": "- Using Sells(cafe, drink, price), find the cafes that sell two different drinks at the same price.\n- R1:=  Sells1(cafe, drink1, price) Sells\n- R2:=  NOT (drink1 = drink) (R1         Sells)\n- R3:=  cafe R2"}, {"source": "chunk_co_occurrence", "chunk_id": "21-RA__0019", "lecture_id": "21-RA", "text": "- Using Sells(cafe, drink, price), find the cafes that sell two different drinks at the same price.\n- R1:=  Sells1(cafe, drink1, price) Sells\n- R2:=  NOT (drink1 = drink) R1         Sells\n- R3:=  cafe R2"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0004"}, "A_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0002"}, "gap_lectures": 0}}}
{"A": {"name": "RELATIONSHIP", "role": "Definition"}, "B": {"name": "RELATIONSHIP_SET", "role": "Definition"}, "relation": "part_of", "justification": "The evidence shows that a relationship is a specific instance within a collection of similar relationships, which is a relationship set.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0005", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Entity: Real-world object distinguishable from  other objects. An entity is described using a set of attributes .\n- Entity Set :  A collection of similar entities.  E.g., all employees. (often referred to as just entity, which blurs the distinction between type and collection)\n- Relationship :  Association among 2 or more entities.  E.g., Kristin's home department is Research & Development.\n- Relationship Set :  Collection of similar relationships.  E.g., Home (often referred to as just relationship)\n- Formal definition:\n- if A, B are sets, then a relation R is a subset of A x B\n- A={1,2,3},   B={a,b,c,d}, R = {(1,a), (1,c), (3,b)}\nSame story w/ entity sets sponsor is a subset of Project x Department :"}, {"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0005", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Entity: Real-world object distinguishable from  other objects. An entity is described using a set of attributes .\n- Entity Set :  A collection of similar entities.  E.g., all employees. (often referred to as just entity, which blurs the distinction between type and collection)\n- Relationship :  Association among 2 or more entities.  E.g., Kristin's home department is Research & Development.\n- Relationship Set :  Collection of similar relationships.  E.g., Home (often referred to as just relationship)\n- Formal definition:\n- if A, B are sets, then a relation R is a subset of A x B\n- A={1,2,3},   B={a,b,c,d}, R = {(1,a), (1,c), (3,b)}\nSame story w/ entity sets sponsor is a subset of Project x Department :"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0005"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0005"}, "gap_lectures": 0}}}
{"A": {"name": "REPEATABLE_READ", "role": "NA"}, "B": {"name": "TRANSACTION_ISOLATION", "role": "NA"}, "relation": "part_of", "justification": "REPEATABLE_READ is a specific level of TRANSACTION_ISOLATION, indicating that it is a component or subtype of the broader concept of transaction isolation levels.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0027", "lecture_id": "19-Trxn-Mgmt", "text": "- To signal to the system that a dirty read is acceptable,\nSET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;\n- In addition, there are\nSET TRANSACTION ISOLATION LEVEL READ COMMITTED; SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;"}, {"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0040", "lecture_id": "19-Trxn-Mgmt", "text": "- Now suppose that T1 is REPEATABLE READ:\nT1: SET TRANSACTION READ WRITE ISOLATION LEVEL REPEATABLE READ;\nSQL code that translates to: R1(A), R1(B) W1(B) W1(C)\nT2: SET TRANSACTION READ WRITE ISOLATION LEVEL READ COMMITTED;\nSQL code that translates to: R2(C), R2(A) W2(A)\nOne possible interleaved execution of the transactions above: R1(A) R2(C) R2(A) R1(B) W1(B) W1(C) W2(A)\nS1(A) R1(A) S2(C) R2(C) REL2(C) S2(A) R2(A) Rel2(A) S1(B) R1(B) X1(B) W1(B) X1(C) W1(C)  REL1(A, B,C) X2(A) W2(A) REL2(A)"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0013"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0027"}, "gap_lectures": 0}}}
{"A": {"name": "TRANSACTION_ISOLATION", "role": "NA"}, "B": {"name": "WRITE_OPERATION", "role": "NA"}, "relation": "depends_on", "justification": "Transaction isolation is a concept that ensures consistency and correctness in concurrent transactions, which requires understanding write operations to manage conflicts and ensure data integrity.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0020", "lecture_id": "20-Trxn-Serializability", "text": "T1:, 1 = R(A),. T1:, 2 = R(C). T1:, 3 = W(B). T2: T3:, 1 = R(B). T2: T3:, 2 = . T2: T3:, 3 = R(B)\n```\nS1(A); R1(A); S2(B) R2(B); S3(A); R3(A); X2(C); W2(C); REL2(C); S1(C); R1(C); R2(B); REL2(B); X1(B); W1(B); REL1(A,B,C); S3(B); R3(B); REL3(A,B);\n```"}, {"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0025", "lecture_id": "20-Trxn-Serializability", "text": "T1:, 1 = R(A),. T1:, 2 = R(C). T1:, 3 = W(B). T2: T3:, 1 = R(B). T2: T3:, 2 = . T2: T3:, 3 = R(B)\n```\nS1(A); R1(A); S2(B) R2(B); S3(A); R3(A); X2(C); W2(C); S1(C) <T1 WAIT ON C>; R2(B); COMMIT REL2(B,C); S1(C); R1(C); X1(B); W1(B); COMMIT; REL1(A,B,C); S3(B); R3(B); COMMIT; REL3(A,B);\n```"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 2, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 2 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0004"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0013"}, "gap_lectures": -2}}}
{"A": {"name": "ACCOUNT_NUMBER", "role": "NA"}, "B": {"name": "FROM_CLAUSE", "role": "NA"}, "relation": null, "justification": "There is no clear dependency or part-of relationship between ACCOUNT_NUMBER and FROM_CLAUSE based on the provided evidence.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "2-SQL-Basics__0005", "lecture_id": "2-SQL-Basics", "text": "Account, 1 = Number. Account, 2 = Owner. Account, 3 = Balance. Account, 4 = T\\pe. , 1 = 101. , 2 = J. Smith. , 3 = 1000.00. , 4 = checking. , 1 = 102. , 2 = W. Wei. , 3 = 2000.00. , 4 = checking. , 1 = 103. , 2 = J. Smith. , 3 = 5000.00. , 4 = savings. , 1 = 104. , 2 = M. Jones. , 3 = 1000.00. , 4 = checking. , 1 = 105. , 2 = H. Martin. , 3 = 10,000.00. , 4 = checking\nSELECT, 1 = Number, Owner. FROM, 1 = Account. WHERE, 1 = T\\pe = \" savings \" ;\nNumber, 1 = Owner\n103\nJ. Smith"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 10, "lecture_id": "2-SQL-Basics", "chunk_id": "2-SQL-Basics__0005"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0013"}, "gap_lectures": -10}}}
{"A": {"name": "ACCOUNT_NUMBER", "role": "NA"}, "B": {"name": "WHERE_CLAUSE", "role": "NA"}, "relation": "depends_on", "justification": "The WHERE_CLAUSE is used to filter records based on specific conditions, including the ACCOUNT_NUMBER. Therefore, understanding WHERE_CLAUSE is necessary to effectively use ACCOUNT_NUMBER in SQL queries.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "2-SQL-Basics__0005", "lecture_id": "2-SQL-Basics", "text": "Account, 1 = Number. Account, 2 = Owner. Account, 3 = Balance. Account, 4 = T\\pe. , 1 = 101. , 2 = J. Smith. , 3 = 1000.00. , 4 = checking. , 1 = 102. , 2 = W. Wei. , 3 = 2000.00. , 4 = checking. , 1 = 103. , 2 = J. Smith. , 3 = 5000.00. , 4 = savings. , 1 = 104. , 2 = M. Jones. , 3 = 1000.00. , 4 = checking. , 1 = 105. , 2 = H. Martin. , 3 = 10,000.00. , 4 = checking\nSELECT, 1 = Number, Owner. FROM, 1 = Account. WHERE, 1 = T\\pe = \" savings \" ;\nNumber, 1 = Owner\n103\nJ. Smith"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 10, "lecture_id": "2-SQL-Basics", "chunk_id": "2-SQL-Basics__0005"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0013"}, "gap_lectures": -10}}}
{"A": {"name": "ACCOUNT_TYPE", "role": "NA"}, "B": {"name": "FROM_CLAUSE", "role": "NA"}, "relation": null, "justification": "There is no clear connection between 'ACCOUNT_TYPE' and 'FROM_CLAUSE' based on the provided evidence.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "2-SQL-Basics__0005", "lecture_id": "2-SQL-Basics", "text": "Account, 1 = Number. Account, 2 = Owner. Account, 3 = Balance. Account, 4 = T\\pe. , 1 = 101. , 2 = J. Smith. , 3 = 1000.00. , 4 = checking. , 1 = 102. , 2 = W. Wei. , 3 = 2000.00. , 4 = checking. , 1 = 103. , 2 = J. Smith. , 3 = 5000.00. , 4 = savings. , 1 = 104. , 2 = M. Jones. , 3 = 1000.00. , 4 = checking. , 1 = 105. , 2 = H. Martin. , 3 = 10,000.00. , 4 = checking\nSELECT, 1 = Number, Owner. FROM, 1 = Account. WHERE, 1 = T\\pe = \" savings \" ;\nNumber, 1 = Owner\n103\nJ. Smith"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 10, "lecture_id": "2-SQL-Basics", "chunk_id": "2-SQL-Basics__0005"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0009"}, "gap_lectures": -10}}}
{"A": {"name": "ACCOUNT_TYPE", "role": "NA"}, "B": {"name": "WHERE_CLAUSE", "role": "NA"}, "relation": "depends_on", "justification": "The WHERE_CLAUSE is used to filter records based on specific conditions, such as the ACCOUNT_TYPE. Therefore, understanding ACCOUNT_TYPE is a prerequisite for using WHERE_CLAUSE effectively.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "2-SQL-Basics__0005", "lecture_id": "2-SQL-Basics", "text": "Account, 1 = Number. Account, 2 = Owner. Account, 3 = Balance. Account, 4 = T\\pe. , 1 = 101. , 2 = J. Smith. , 3 = 1000.00. , 4 = checking. , 1 = 102. , 2 = W. Wei. , 3 = 2000.00. , 4 = checking. , 1 = 103. , 2 = J. Smith. , 3 = 5000.00. , 4 = savings. , 1 = 104. , 2 = M. Jones. , 3 = 1000.00. , 4 = checking. , 1 = 105. , 2 = H. Martin. , 3 = 10,000.00. , 4 = checking\nSELECT, 1 = Number, Owner. FROM, 1 = Account. WHERE, 1 = T\\pe = \" savings \" ;\nNumber, 1 = Owner\n103\nJ. Smith"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 10, "lecture_id": "2-SQL-Basics", "chunk_id": "2-SQL-Basics__0005"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0009"}, "gap_lectures": -10}}}
{"A": {"name": "ACID_PROPERTIES", "role": "Definition"}, "B": {"name": "CONCURRENT_EXECUTION", "role": "NA"}, "relation": "depends_on", "justification": "The evidence suggests that understanding concurrent execution is a prerequisite for discussing ACID properties, as concurrent execution issues are mentioned in the context of transaction management.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0002", "lecture_id": "19-Trxn-Mgmt", "text": "- Describe transactions, ACID properties and issues related to concurrent exaction of transactions.\n- Describe how database systems implement isolation levels"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0002"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0002"}, "gap_lectures": 0}}}
{"A": {"name": "ALGEBRAIC_LAWS", "role": "Definition"}, "B": {"name": "QUERY_OPTIMIZATION", "role": "NA"}, "relation": "depends_on", "justification": "The evidence shows that algebraic laws are used as a foundational ingredient in query optimization, suggesting that understanding algebraic laws is a prerequisite for query optimization.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "23-Rule-basedOpt__0002", "lecture_id": "23-Rule-basedOpt", "text": "- Now we have one logical plan. Let's try to make it better.\n- Ingredient 1: Algebraic laws : what are the ways in which an expression or tree may be rewritten without changing the meaning\n- Ingredient 2: Optimizations : if there are multiple ways to write the same query, which one to choose.\n- Rule-based (heuristics): apply laws that seem to result in cheaper plans\n- Cost-based: estimate size and cost of intermediate results, search systematically for best plan\nI"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0022"}, "A_first_introduced_at": {"lecture_index": 14, "lecture_id": "23-Rule-basedOpt", "chunk_id": "23-Rule-basedOpt__0002"}, "gap_lectures": 2}}}
{"A": {"name": "ASSERTIONS", "role": "NA"}, "B": {"name": "CONSTRAINTS", "role": "NA"}, "relation": "part_of", "justification": "Assertions are listed as a specific type within the broader category of constraints.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "7- ConstraintsTriggers__0023", "lecture_id": "7- ConstraintsTriggers", "text": "- We can do attribute -based check, why tuple level?\n- Reason 1: If the check involves more than one attribute of the tuple, we need the tuple -level check.\n- Reason 2: Tuple -level constraints are checked more frequently.\n- Whenever there are any inserts or updates to any of the concerned attributes\nI\n- Constraints\n-  Foreign -key, or referential -integrity constraints.\n-  Value -based constraints.\n-  Tuple -based constraints.\n- Assertions.\n- Triggers"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0030"}, "A_first_introduced_at": {"lecture_index": 19, "lecture_id": "7- ConstraintsTriggers", "chunk_id": "7- ConstraintsTriggers__0001"}, "gap_lectures": 13}}}
{"A": {"name": "ASSERTIONS", "role": "NA"}, "B": {"name": "FOREIGN_KEY_CONSTRAINT", "role": "NA"}, "relation": null, "justification": "The provided evidence does not establish a clear dependency or part_of relationship between 'ASSERTIONS' and 'FOREIGN_KEY_CONSTRAINT'. Both concepts are listed as separate types of constraints but no direct relationship is specified.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "7- ConstraintsTriggers__0019", "lecture_id": "7- ConstraintsTriggers", "text": "- An attribute -based check is checked only when a value for that attribute is inserted or updated.\n- Example: CHECK (price <= 5.00) checks every new price and rejects it if it is more than $5.\n- Example: CHECK (drink IN (SELECT name FROM Drinks)) not checked if a drink is deleted from Drinks or updated (unlike foreign -keys).\n- Only checked during inserts/updates of that attribute\nI ILLINOIS\n- Constraints\n-  Foreign -key, or referential -integrity constraints.\n-  Value -based constraints.\n- Tuple -based constraints.\n- Assertions.\n- Triggers"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 19, "lecture_id": "7- ConstraintsTriggers", "chunk_id": "7- ConstraintsTriggers__0004"}, "A_first_introduced_at": {"lecture_index": 19, "lecture_id": "7- ConstraintsTriggers", "chunk_id": "7- ConstraintsTriggers__0001"}, "gap_lectures": 0}}}
{"A": {"name": "ATTRIBUTES", "role": "NA"}, "B": {"name": "ENTITY", "role": "NA"}, "relation": "part_of", "justification": "Attributes are specific properties of an entity, indicating that attributes are part of the broader concept of an entity.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0016", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nWhat are the attributes and what is the key for Assignment?\n```\nProject(P-number, P-name, Due-Date) Employee(SSN, E-Name, Office)\n```\nProject\nP-number P-name Due-Date\nEmployee\nSSN\nE-Name\nOffice\n0..*     Assignment      0..*\n- 0..*        Manager        1..1\nAnswer: Assignment(P-Number, SSN)\nP-Number is a foreign key for Project SSN is a foreign key for Employee\nProject(P-Number, P-Due-Date)\nEmployee(SSN, E-Name, Office)"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0005"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0001"}, "gap_lectures": 0}}}
{"A": {"name": "ATTRIBUTES", "role": "NA"}, "B": {"name": "FOREIGN_KEY", "role": "NA"}, "relation": "depends_on", "justification": "The evidence shows that understanding foreign keys is necessary to identify attributes in a database design, indicating that attributes depend on the concept of foreign keys.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0016", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nWhat are the attributes and what is the key for Assignment?\n```\nProject(P-number, P-name, Due-Date) Employee(SSN, E-Name, Office)\n```\nProject\nP-number P-name Due-Date\nEmployee\nSSN\nE-Name\nOffice\n0..*     Assignment      0..*\n- 0..*        Manager        1..1\nAnswer: Assignment(P-Number, SSN)\nP-Number is a foreign key for Project SSN is a foreign key for Employee\nProject(P-Number, P-Due-Date)\nEmployee(SSN, E-Name, Office)"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 2, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0000"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0001"}, "gap_lectures": 4}}}
{"A": {"name": "AVERAGE_PRICE", "role": "Example"}, "B": {"name": "DATABASE_QUERY", "role": "NA"}, "relation": "depends_on", "justification": "The evidence shows that calculating the average price requires executing a database query, indicating that AVERAGE_PRICE depends on DATABASE_QUERY.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "5- SQL4-AggGrpViews__0003", "lecture_id": "5- SQL4-AggGrpViews", "text": "- From Sells(cafe, drink, price), find the average price of Mocha:\n```\nSELECT AVG(price) FROM Sells WHERE drink = ' Mocha ' ;\n```"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 2, "lecture_id": "11-Neo4J-Part2", "chunk_id": "11-Neo4J-Part2__0012"}, "A_first_introduced_at": {"lecture_index": 17, "lecture_id": "5- SQL4-AggGrpViews", "chunk_id": "5- SQL4-AggGrpViews__0003"}, "gap_lectures": 15}}}
{"A": {"name": "AVERAGE_PRICE", "role": "NA"}, "B": {"name": "GROUP_BY", "role": "NA"}, "relation": "depends_on", "justification": "The evidence shows that the GROUP BY clause is used to group data before calculating the average price, indicating that GROUP BY is a prerequisite for calculating AVERAGE_PRICE.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "5- SQL4-AggGrpViews__0007", "lecture_id": "5- SQL4-AggGrpViews", "text": "- From Sells(cafe, drink, price), find the average price for each drink:\n```\nSELECT drink, AVG(price) FROM Sells GROUP BY drink;\n```\n工\n- From Sells(cafe, drink, price) and Frequents(customer, cafe), find for each customer the average price of Mocha at the cafes they frequent:\nI ILLINOIS"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 14, "lecture_id": "23-Rule-basedOpt", "chunk_id": "23-Rule-basedOpt__0001"}, "A_first_introduced_at": {"lecture_index": 17, "lecture_id": "5- SQL4-AggGrpViews", "chunk_id": "5- SQL4-AggGrpViews__0003"}, "gap_lectures": 3}}}
{"A": {"name": "BUCKET_STORAGE", "role": "NA"}, "B": {"name": "MEMORY_CONSTRAINT", "role": "NA"}, "relation": "depends_on", "justification": "The evidence suggests that bucket storage (A) depends on memory constraints (B) because the text mentions that the bucket storage process works under the condition that each bucket fits within memory constraints.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "QP__0020", "lecture_id": "QP", "text": "R        S  \n- Hash S into (M-1) buckets, using join attribute(s) as hash key\n- Step 1:\n- Send all buckets to disk\n- Hash R into (M-1) buckets, using join attribute(s) as hash key\n- Step 2\n- Send all buckets to disk\n- Join every pair of buckets with the same bucket number. Use the one pass algorithm for this.\n- Step 3\n- Works when for each bucket no. i , either R i or S i fits in memory.\n- min(B(R), B(S))/(M-1) <= (M-2)  min(B(R), B(S)) <= (M-1)(M-2) < M 2\n- Cost = 3(B(R)+B(S))"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 13, "lecture_id": "21b-IntroPhysicalOperators", "chunk_id": "21b-IntroPhysicalOperators__0008"}, "A_first_introduced_at": {"lecture_index": 8, "lecture_id": "18-HashTables", "chunk_id": "18-HashTables__0001"}, "gap_lectures": -5}}}
{"A": {"name": "BUCKET_STORAGE", "role": "NA"}, "B": {"name": "ONE_PASS_ALGORITHM", "role": "NA"}, "relation": "depends_on", "justification": "The evidence suggests that bucket storage is used as a prerequisite for the one-pass algorithm, as the one-pass algorithm operates on pairs of buckets with the same bucket number.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "QP__0020", "lecture_id": "QP", "text": "R        S  \n- Hash S into (M-1) buckets, using join attribute(s) as hash key\n- Step 1:\n- Send all buckets to disk\n- Hash R into (M-1) buckets, using join attribute(s) as hash key\n- Step 2\n- Send all buckets to disk\n- Join every pair of buckets with the same bucket number. Use the one pass algorithm for this.\n- Step 3\n- Works when for each bucket no. i , either R i or S i fits in memory.\n- min(B(R), B(S))/(M-1) <= (M-2)  min(B(R), B(S)) <= (M-1)(M-2) < M 2\n- Cost = 3(B(R)+B(S))"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 24, "lecture_id": "QP", "chunk_id": "QP__0015"}, "A_first_introduced_at": {"lecture_index": 8, "lecture_id": "18-HashTables", "chunk_id": "18-HashTables__0001"}, "gap_lectures": -16}}}
{"A": {"name": "BUCKET_STORAGE", "role": "NA"}, "B": {"name": "OVERFLOW_BLOCKS", "role": "NA"}, "relation": "depends_on", "justification": "Bucket storage (A) depends on overflow blocks (B) because overflow blocks are used when bucket storage needs additional space for records.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "18-HashTables__0001", "lecture_id": "18-HashTables", "text": "- Secondary storage hash tables are much like main memory ones\n- Recall basics:\n- There are B buckets\n- A hash function h(k) maps a key k to {0, 1, …, B-1}\n- Store in bucket h(k) a pointer to record with key k\n- Secondary storage: bucket = block\n- Store in the block of bucket h(k) any record with key k\n- use overflow blocks when needed"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 8, "lecture_id": "18-HashTables", "chunk_id": "18-HashTables__0001"}, "A_first_introduced_at": {"lecture_index": 8, "lecture_id": "18-HashTables", "chunk_id": "18-HashTables__0001"}, "gap_lectures": 0}}}
{"A": {"name": "BUCKET_STORAGE", "role": "NA"}, "B": {"name": "SECONDARY_STORAGE", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly establish a 'depends_on' or 'part_of' relationship between BUCKET_STORAGE and SECONDARY_STORAGE.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "18-HashTables__0001", "lecture_id": "18-HashTables", "text": "- Secondary storage hash tables are much like main memory ones\n- Recall basics:\n- There are B buckets\n- A hash function h(k) maps a key k to {0, 1, …, B-1}\n- Store in bucket h(k) a pointer to record with key k\n- Secondary storage: bucket = block\n- Store in the block of bucket h(k) any record with key k\n- use overflow blocks when needed"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 8, "lecture_id": "18-HashTables", "chunk_id": "18-HashTables__0000"}, "A_first_introduced_at": {"lecture_index": 8, "lecture_id": "18-HashTables", "chunk_id": "18-HashTables__0001"}, "gap_lectures": 0}}}
{"A": {"name": "CARDINALITY", "role": "Definition"}, "B": {"name": "FOREIGN_KEYS", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly establish a 'depends_on' or 'part_of' relationship between CARDINALITY and FOREIGN_KEYS. The evidence only shows co-occurrence in the same chunk without indicating a clear prerequisite or component relationship.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "1-RelationalModel__0012", "lecture_id": "1-RelationalModel", "text": "The intension of the table\n101, Owner = J. Smith. 101, Balance = 1000.00. 101, Type = checking. 102, Owner = W. Wei. 102, Balance = 2000.00. 102, Type = checking. 103, Owner = J. Smith. 103, Balance = 5000.00. 103, Type = savings. 104, Owner = M. Jones. 104, Balance = 1000.00. 104, Type = checking. 105, Owner = H. Martin. 105, Balance = 10,000.00. 105, Type = checking\nThe extension of the table.  Also called the extent .\n, Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. Cardinality, Number = 102. Cardinality, Owner = W. Wei. Cardinality, Balance = 2000.00. Cardinality, Type = checking. of this instance is 5 (because, Number = 103. of this instance is 5 (because, Owner = J. Smith. of this instance is 5 (because, Balance = 5000.00. of this instance is 5 (because, Type = savings. there are 5, Number = 104. there are 5, Owner = M. Jones. there are 5, Balance = 1000.00. there are 5, Type = checking. rows), Number = 105. rows), Owner = H. Martin. rows), Balance = 10,000.00. rows), Type = checking\n-  Data Models\n- Relational Database Model\n-  Basic Concepts and Terminology\n- Keys and Foreign Keys\n- Schema Specifications"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0012"}, "gap_lectures": 0}}}
{"A": {"name": "CARDINALITY", "role": "Definition"}, "B": {"name": "SCHEMA_SPECIFICATIONS", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly establish a 'depends_on' or 'part_of' relationship between CARDINALITY and SCHEMA_SPECIFICATIONS. The terms co-occur in the same chunk but do not indicate a clear prerequisite or component relationship.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "1-RelationalModel__0012", "lecture_id": "1-RelationalModel", "text": "The intension of the table\n101, Owner = J. Smith. 101, Balance = 1000.00. 101, Type = checking. 102, Owner = W. Wei. 102, Balance = 2000.00. 102, Type = checking. 103, Owner = J. Smith. 103, Balance = 5000.00. 103, Type = savings. 104, Owner = M. Jones. 104, Balance = 1000.00. 104, Type = checking. 105, Owner = H. Martin. 105, Balance = 10,000.00. 105, Type = checking\nThe extension of the table.  Also called the extent .\n, Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. Cardinality, Number = 102. Cardinality, Owner = W. Wei. Cardinality, Balance = 2000.00. Cardinality, Type = checking. of this instance is 5 (because, Number = 103. of this instance is 5 (because, Owner = J. Smith. of this instance is 5 (because, Balance = 5000.00. of this instance is 5 (because, Type = savings. there are 5, Number = 104. there are 5, Owner = M. Jones. there are 5, Balance = 1000.00. there are 5, Type = checking. rows), Number = 105. rows), Owner = H. Martin. rows), Balance = 10,000.00. rows), Type = checking\n-  Data Models\n- Relational Database Model\n-  Basic Concepts and Terminology\n- Keys and Foreign Keys\n- Schema Specifications"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0012"}, "gap_lectures": 0}}}
{"A": {"name": "CONCEPTUAL_DESIGN", "role": "NA"}, "B": {"name": "INDEXING", "role": "NA"}, "relation": "depends_on", "justification": "The evidence suggests that indexing is discussed after the conceptual design, indicating that indexing builds upon the foundational design work.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "15-NFs-3NF__0017", "lecture_id": "15-NFs-3NF", "text": "- Conceptual design:  (ER & UML Models are used\n- for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\nWe'll discuss indexing next.\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 2, "lecture_id": "11-Neo4J-Part2", "chunk_id": "11-Neo4J-Part2__0005"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "gap_lectures": 2}}}
{"A": {"name": "CONCURRENT_EXECUTION", "role": "NA"}, "B": {"name": "ISOLATION_LEVELS", "role": "Definition"}, "relation": "depends_on", "justification": "Concurrent execution is a broader concept that involves managing how transactions are executed simultaneously. Isolation levels are a specific mechanism used to control the visibility of transactions to each other during concurrent execution, thus concurrent execution must be understood before isolation levels can be effectively taught.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0002", "lecture_id": "19-Trxn-Mgmt", "text": "- Describe transactions, ACID properties and issues related to concurrent exaction of transactions.\n- Describe how database systems implement isolation levels"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0002"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0002"}, "gap_lectures": 0}}}
{"A": {"name": "CONCURRENT_EXECUTION", "role": "NA"}, "B": {"name": "TRANSACTIONS", "role": "Definition"}, "relation": "depends_on", "justification": "The evidence shows that concurrent execution is discussed in the context of transactions, indicating that understanding transactions is a prerequisite for discussing concurrent execution.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "19-Trxn-Mgmt__0002", "lecture_id": "19-Trxn-Mgmt", "text": "- Describe transactions, ACID properties and issues related to concurrent exaction of transactions.\n- Describe how database systems implement isolation levels"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0000"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0002"}, "gap_lectures": 8}}}
{"A": {"name": "CONSTRAINTS", "role": "NA"}, "B": {"name": "DATABASE_DESIGN", "role": "NA"}, "relation": "depends_on", "justification": "Constraints are required as input to the database design process and need to be enforced, indicating that database design depends on constraints.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0030", "lecture_id": "13-NFs-FDs", "text": "- We need to know if keys and FDs (always) hold in the application.\n- We need to consult a domain expert to find out what the keys and FDs are.  The keys and FDs serve as input to the database design process.\n- We would like to enforce the keys and FDs constraints.\nI"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0004"}, "A_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0030"}, "gap_lectures": 2}}}
{"A": {"name": "CONSTRAINTS", "role": "NA"}, "B": {"name": "KEYS", "role": "NA"}, "relation": "depends_on", "justification": "The evidence suggests that keys are part of the constraints that need to be enforced in the database design process, implying that understanding keys is a prerequisite for understanding constraints.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0030", "lecture_id": "13-NFs-FDs", "text": "- We need to know if keys and FDs (always) hold in the application.\n- We need to consult a domain expert to find out what the keys and FDs are.  The keys and FDs serve as input to the database design process.\n- We would like to enforce the keys and FDs constraints.\nI"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "A_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0030"}, "gap_lectures": 6}}}
{"A": {"name": "CONSTRAINTS", "role": "NA"}, "B": {"name": "TRIGGERS", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly establish a dependency or part-of relationship between 'CONSTRAINTS' and 'TRIGGERS'. They are mentioned in the same context but without a clear hierarchical or prerequisite relationship.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "7- ConstraintsTriggers__0023", "lecture_id": "7- ConstraintsTriggers", "text": "- We can do attribute -based check, why tuple level?\n- Reason 1: If the check involves more than one attribute of the tuple, we need the tuple -level check.\n- Reason 2: Tuple -level constraints are checked more frequently.\n- Whenever there are any inserts or updates to any of the concerned attributes\nI\n- Constraints\n-  Foreign -key, or referential -integrity constraints.\n-  Value -based constraints.\n-  Tuple -based constraints.\n- Assertions.\n- Triggers"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 19, "lecture_id": "7- ConstraintsTriggers", "chunk_id": "7- ConstraintsTriggers__0001"}, "A_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0030"}, "gap_lectures": -13}}}
{"A": {"name": "COST_CALCULATION", "role": "NA"}, "B": {"name": "JOIN_OPERATION", "role": "NA"}, "relation": "depends_on", "justification": "The evidence shows that cost calculation is used to determine the cost of performing a join operation, indicating that understanding join operations is a prerequisite for cost calculation.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "QP__0023", "lecture_id": "QP", "text": "- R       S  \n- Assume S has an index on the join attribute\n- Iterate over R, for each tuple fetch corresponding tuple(s) from S\n- Assume R is clustered. Cost:\n- If index (on S) is clustered:  B(R) + T(R)B(S)/V(S,a)\n- If index (on S) is unclustered: B(R) + T(R)T(S)/V(S,a)\n- Looks useless (Example 15.12), but see text (paragraph following the example)."}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0005"}, "A_first_introduced_at": {"lecture_index": 24, "lecture_id": "QP", "chunk_id": "QP__0003"}, "gap_lectures": 12}}}
{"A": {"name": "CYPHER_LANGUAGE", "role": "Definition"}, "B": {"name": "GRAPH_DATABASE", "role": "Definition"}, "relation": null, "justification": "The provided evidence does not clearly indicate a dependency or part_of relationship between CYPHER_LANGUAGE and GRAPH_DATABASE.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "11-Neo4J-Part2__0010", "lecture_id": "11-Neo4J-Part2", "text": "Source: https://neo4j.com/developer/cypher-query-language/"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 2, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0008"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0019"}, "gap_lectures": 0}}}
{"A": {"name": "CYPHER_LANGUAGE", "role": "Definition"}, "B": {"name": "GRAPH_DATABASES", "role": "NA"}, "relation": "depends_on", "justification": "CYPHER_LANGUAGE is used to query and manipulate data in GRAPH_DATABASES, indicating that knowledge of GRAPH_DATABASES is a prerequisite for understanding and using CYPHER_LANGUAGE.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "11-Neo4J-Part2__0011", "lecture_id": "11-Neo4J-Part2", "text": "Source: https://neo4j.com/developer/cypher-query-language/"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 2, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0002"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0019"}, "gap_lectures": 0}}}
{"A": {"name": "CYPHER_QUERY", "role": "Example"}, "B": {"name": "DATABASE_QUERY", "role": "NA"}, "relation": "depends_on", "justification": "The evidence shows that Cypher queries are used to query a graph database, which is a specific type of database. This implies that understanding general database queries (B) is a prerequisite for understanding Cypher queries (A).", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "11-Neo4J-Part2__0012", "lecture_id": "11-Neo4J-Part2", "text": "- Select everything from the products table\nSELECT p.* FROM products as p;\nSQL\nMATCH (p:Product) RETURN p;\nCypher"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 2, "lecture_id": "11-Neo4J-Part2", "chunk_id": "11-Neo4J-Part2__0012"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0010"}, "gap_lectures": -1}}}
{"A": {"name": "CYPHER_QUERY", "role": "NA"}, "B": {"name": "GRAPH_DATABASES", "role": "NA"}, "relation": "part_of", "justification": "CYPHER_QUERY is a specific query language used within GRAPH_DATABASES, indicating that it is a component or part of the broader concept of GRAPH_DATABASES.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "11-Neo4J-Part2__0019", "lecture_id": "11-Neo4J-Part2", "text": "1. Neo4j Tutorial:\nhttps://www.tutorialspoint.com/neo4j/index.htm\n2. Video Tutorials: https://neo4j.com/blog/neo4j-videotutorials/?_ga=2.57983406.580712586.1555337212902296776.1553382068\n3. GraphGists are teaching tools which allow you to explore how data in a particular domain would be modeled as a graph and see some example queries of that graph data\n- https://neo4j.com/graphgists/\n4. Awesome user-defined procedures: https://github.com/neo4jcontrib/neo4j-apoc-procedures"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0002"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0010"}, "gap_lectures": 0}}}
{"A": {"name": "DATABASE_DESIGN", "role": "NA"}, "B": {"name": "FOREIGN_KEY", "role": "NA"}, "relation": "depends_on", "justification": "FOREIGN_KEY is a fundamental concept that must be understood before delving into DATABASE_DESIGN, as evidenced by the text mentioning FOREIGN_KEY in the context of database relations.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0018", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nMgrSSN is a foreign key (referencing the Employee relation)\nvalue of Manager must match an SSN\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nvs.\nProject(P-number, P-name, Due-Date)\nEmployee(SSN, E-Name, Office)\nManager(P-number, SSN)\nWhat are the tradeoffs between these two?\nNote: P-number is the key for Manager"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0000"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0004"}, "gap_lectures": 4}}}
{"A": {"name": "DATABASE_DESIGN", "role": "NA"}, "B": {"name": "FUNCTIONAL_DEPENDENCIES", "role": "NA"}, "relation": "depends_on", "justification": "Functional dependencies are a fundamental concept in database design, as they help in understanding and normalizing the structure of a database. Therefore, DATABASE_DESIGN depends_on FUNCTIONAL_DEPENDENCIES.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0017", "lecture_id": "13-NFs-FDs", "text": "caused by 'troublesome' FDs\nEMP(name, SSN, birthdate, address, dnum, dname, dmgr)"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0003"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0004"}, "gap_lectures": -2}}}
{"A": {"name": "DATABASE_DESIGN", "role": "NA"}, "B": {"name": "KEYS", "role": "NA"}, "relation": "depends_on", "justification": "The evidence shows that keys are an essential input to the database design process, indicating that understanding keys is a prerequisite for database design.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0030", "lecture_id": "13-NFs-FDs", "text": "- We need to know if keys and FDs (always) hold in the application.\n- We need to consult a domain expert to find out what the keys and FDs are.  The keys and FDs serve as input to the database design process.\n- We would like to enforce the keys and FDs constraints.\nI"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0004"}, "gap_lectures": 4}}}
{"A": {"name": "DATABASE_DESIGN", "role": "NA"}, "B": {"name": "NORMALIZATION", "role": "NA"}, "relation": "depends_on", "justification": "Normalization is a foundational concept in database design that helps in structuring the database efficiently. The evidence shows that normalization (B) is discussed before and is a prerequisite for understanding advanced database design (A).", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0017", "lecture_id": "13-NFs-FDs", "text": "caused by 'troublesome' FDs\nEMP(name, SSN, birthdate, address, dnum, dname, dmgr)"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0000"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0004"}, "gap_lectures": 3}}}
{"A": {"name": "DATABASE_DESIGN", "role": "NA"}, "B": {"name": "REFERENTIAL_INTEGRITY", "role": "NA"}, "relation": "depends_on", "justification": "REFERENTIAL_INTEGRITY is a prerequisite concept for DATABASE_DESIGN as it ensures data consistency and integrity in database design.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0018", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nMgrSSN is a foreign key (referencing the Employee relation)\nvalue of Manager must match an SSN\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nvs.\nProject(P-number, P-name, Due-Date)\nEmployee(SSN, E-Name, Office)\nManager(P-number, SSN)\nWhat are the tradeoffs between these two?\nNote: P-number is the key for Manager"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0015"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0004"}, "gap_lectures": 4}}}
{"A": {"name": "DATABASE_NORMALIZATION", "role": "NA"}, "B": {"name": "DATA_MODELING", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly indicate a dependency or part_of relationship between DATABASE_NORMALIZATION and DATA_MODELING.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "10-Neo4J-Part 1__0006", "lecture_id": "10-Neo4J-Part 1", "text": "- No need to define schema upfront"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0006"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0006"}, "gap_lectures": 0}}}
{"A": {"name": "DATABASE_NORMALIZATION", "role": "NA"}, "B": {"name": "FUNCTIONAL_DEPENDENCIES", "role": "NA"}, "relation": "depends_on", "justification": "Functional dependencies are a foundational concept required for understanding database normalization. The evidence shows that functional dependencies are introduced and used in the context of normalization, indicating that B (FUNCTIONAL_DEPENDENCIES) is a prerequisite for A (DATABASE_NORMALIZATION).", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "DBDesign_BCNF__0007", "lecture_id": "DBDesign_BCNF", "text": "- Person (Name, SSN, Age, EyeColor, Phone, HairColor)\n- FD 1: SSN  Name, Age, EyeColor\n- FD 2: Age  HairColor"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0003"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0006"}, "gap_lectures": -5}}}
{"A": {"name": "DATABASE_NORMALIZATION", "role": "NA"}, "B": {"name": "REDUNDANCY_REDUCTION", "role": "NA"}, "relation": "depends_on", "justification": "Redundancy reduction is a key objective of database normalization, indicating that understanding redundancy reduction is a prerequisite for learning about database normalization.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0022", "lecture_id": "13-NFs-FDs", "text": "New-EMP(name, SSN, birthdate, address, dnum)\nInsert anomalies: No Problem\n```\nJohn    111 June 3     123 St.      D1 Sue     222 May 15    455 St.       D1 Max    333 Mar. 5      678 St.      D2 Wei     444 May 2      999 St.      D2 Tom    555 June 22   888 St.      D2\n```\nDept(dnum,  dname,  dmgr)\nD1         sales        222\nD2        research  333\nLess redundancy!\nDelete anomalies: No Problem"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0019"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0006"}, "gap_lectures": -5}}}
{"A": {"name": "DATABASE_QUERY", "role": "NA"}, "B": {"name": "PROJECTION", "role": "NA"}, "relation": "depends_on", "justification": "The evidence shows that projection is used within the context of database queries, indicating that understanding projection is necessary to fully grasp and execute database queries.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "8- NoSQL-MongoDB-Basics__0024", "lecture_id": "8- NoSQL-MongoDB-Basics", "text": "- db.posts.find({tags: ' tech ' })\n- Print complete information about posts which are tagged ' tech '\n- db.posts.find({tags: {$all: [ ' tech ' , ' databases ' ]}}, {author:1, tags:1})\n- Print author and tags of posts which are tagged with both ' tech ' and ' databases ' (among other things)\n- Contrast this with:\n```\ndb.posts.find({tags: [ ' databases ' , ' tech ' ]})\n```\nI ILLINOIS\nA. Alawini"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0004"}, "A_first_introduced_at": {"lecture_index": 2, "lecture_id": "11-Neo4J-Part2", "chunk_id": "11-Neo4J-Part2__0012"}, "gap_lectures": -10}}}
{"A": {"name": "DATABASE_QUERY", "role": "NA"}, "B": {"name": "STORED_PROCEDURE", "role": "Definition"}, "relation": "depends_on", "justification": "A stored procedure can contain a database query as part of its logic, indicating that understanding database queries is a prerequisite for creating stored procedures.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "6- SQL5-DBUpdatesSPs__0020", "lecture_id": "6- SQL5-DBUpdatesSPs", "text": "Define a stored procedure that takes a department and returns the total number of students in that department.\n```\nDELIMITER // CREATE PROCEDURE GetTotalStds ( IN dept VARCHAR(30), OUT total INT) BEGIN SELECT COUNT(*) INTO total FROM Students WHERE Department= dept; END // DELIMITER ;\n```\nA. Alawini\nCalling the procedure:\nCALL GetTotalStds('CS',@total);\nGetting the result:\nSELECT @total;\n21"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 18, "lecture_id": "6- SQL5-DBUpdatesSPs", "chunk_id": "6- SQL5-DBUpdatesSPs__0017"}, "A_first_introduced_at": {"lecture_index": 2, "lecture_id": "11-Neo4J-Part2", "chunk_id": "11-Neo4J-Part2__0012"}, "gap_lectures": -16}}}
{"A": {"name": "DATABASE_RELATIONS", "role": "NA"}, "B": {"name": "DATA_NORMALIZATION", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly establish a 'depends_on' or 'part_of' relationship between DATABASE_RELATIONS and DATA_NORMALIZATION.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0018", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nMgrSSN is a foreign key (referencing the Employee relation)\nvalue of Manager must match an SSN\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nvs.\nProject(P-number, P-name, Due-Date)\nEmployee(SSN, E-Name, Office)\nManager(P-number, SSN)\nWhat are the tradeoffs between these two?\nNote: P-number is the key for Manager"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0018"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0011"}, "gap_lectures": 0}}}
{"A": {"name": "DATABASE_RELATIONS", "role": "NA"}, "B": {"name": "FOREIGN_KEYS", "role": "NA"}, "relation": "depends_on", "justification": "The evidence shows that foreign keys are used within the context of database relations, indicating that understanding foreign keys is a prerequisite for comprehending database relations.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0018", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nMgrSSN is a foreign key (referencing the Employee relation)\nvalue of Manager must match an SSN\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nvs.\nProject(P-number, P-name, Due-Date)\nEmployee(SSN, E-Name, Office)\nManager(P-number, SSN)\nWhat are the tradeoffs between these two?\nNote: P-number is the key for Manager"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0011"}, "gap_lectures": 4}}}
{"A": {"name": "DATABASE_RELATIONS", "role": "NA"}, "B": {"name": "REFERENTIAL_INTEGRITY", "role": "NA"}, "relation": "depends_on", "justification": "REFERENTIAL_INTEGRITY is a concept that ensures the integrity of relationships between database tables, which is crucial for understanding and implementing DATABASE_RELATIONS.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0018", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nMgrSSN is a foreign key (referencing the Employee relation)\nvalue of Manager must match an SSN\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nvs.\nProject(P-number, P-name, Due-Date)\nEmployee(SSN, E-Name, Office)\nManager(P-number, SSN)\nWhat are the tradeoffs between these two?\nNote: P-number is the key for Manager"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0015"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0011"}, "gap_lectures": 4}}}
{"A": {"name": "DATABASE_SCHEMA", "role": "NA"}, "B": {"name": "FUNCTIONAL_DEPENDENCIES", "role": "NA"}, "relation": "depends_on", "justification": "The evidence shows that functional dependencies are identified from the original database schema, indicating that understanding functional dependencies is a prerequisite for working with database schemas.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0003", "lecture_id": "13-NFs-FDs", "text": "- Start with the original db schema R\n- From ER translation or otherwise\n- Identify its functional dependencies\n- Use them to transform R until we get a good design R*"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0003"}, "A_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0003"}, "gap_lectures": 0}}}
{"A": {"name": "DATABASE_SCHEMA", "role": "NA"}, "B": {"name": "NORMALIZATION", "role": "NA"}, "relation": "depends_on", "justification": "The evidence shows that normalization is used to transform the original database schema into a better design, indicating that understanding normalization is a prerequisite for working with database schemas.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0003", "lecture_id": "13-NFs-FDs", "text": "- Start with the original db schema R\n- From ER translation or otherwise\n- Identify its functional dependencies\n- Use them to transform R until we get a good design R*"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0000"}, "A_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0003"}, "gap_lectures": 5}}}
{"A": {"name": "DATABASE_SCHEMA", "role": "NA"}, "B": {"name": "REFERENTIAL_INTEGRITY", "role": "NA"}, "relation": "depends_on", "justification": "Referential integrity is a constraint that is part of the database schema, and understanding the schema is necessary to comprehend and implement referential integrity.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "7- ConstraintsTriggers__0024", "lecture_id": "7- ConstraintsTriggers", "text": "- These are database -schema elements, like relations or views.\n- Defined by:\nCREATE ASSERTION <name>\n- CHECK ( <condition> );\n- Condition may refer to any relation or attribute in the database schema.\n- Must be true at all times\nI ILLINOIS"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0015"}, "A_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0003"}, "gap_lectures": 6}}}
{"A": {"name": "DATABASE_SYSTEMS", "role": "NA"}, "B": {"name": "NORMALIZATION", "role": "Definition"}, "relation": null, "justification": "The provided evidence does not clearly establish a 'depends_on' or 'part_of' relationship between DATABASE_SYSTEMS and NORMALIZATION.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "10-Neo4J-Part 1__0000", "lecture_id": "10-Neo4J-Part 1", "text": "University of Illinois at Urbana -Champaign CS411: Database Systems"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0000"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0020"}, "gap_lectures": -1}}}
{"A": {"name": "DATABASE_SYSTEMS", "role": "Definition"}, "B": {"name": "QUERY_OPTIMIZATION", "role": "NA"}, "relation": "depends_on", "justification": "QUERY_OPTIMIZATION is a more advanced topic that builds upon the foundational understanding of DATABASE_SYSTEMS. It is introduced later in the course and relies on the prior knowledge of database systems.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "5- SQL4-AggGrpViews__0000", "lecture_id": "5- SQL4-AggGrpViews", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems\n工"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0022"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0020"}, "gap_lectures": -12}}}
{"A": {"name": "DATABASE_SYSTEMS", "role": "NA"}, "B": {"name": "RELATIONAL_MODEL", "role": "NA"}, "relation": "part_of", "justification": "The evidence indicates that database systems use the relational model, suggesting that the relational model is a broader concept that includes specific database systems as its components.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "1-RelationalModel__0020", "lecture_id": "1-RelationalModel", "text": "- Most popular database systems use the relational model.\n- Oracle\n- MS SQL Server\n- MySQL\n- PostgreSQL\n- IBM DB2\n- SQLLite\n- Microsoft Access\n- Check: https://db-engines.com/en/ranking\n- Learning about the relational model (and SQL) is a wise investment."}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0000"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0020"}, "gap_lectures": 0}}}
{"A": {"name": "DATABASE_SYSTEMS", "role": "NA"}, "B": {"name": "TRANSACTIONS", "role": "Definition"}, "relation": null, "justification": "The provided evidence does not clearly establish a 'depends_on' or 'part_of' relationship between DATABASE_SYSTEMS and TRANSACTIONS.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "10-Neo4J-Part 1__0000", "lecture_id": "10-Neo4J-Part 1", "text": "University of Illinois at Urbana -Champaign CS411: Database Systems"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0000"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0020"}, "gap_lectures": -1}}}
{"A": {"name": "DATABASE_TUNING", "role": "NA"}, "B": {"name": "NORMALIZATION", "role": "NA"}, "relation": "depends_on", "justification": "Normalization is a prerequisite step in the logical design phase, which precedes the physical database design and tuning phase where DATABASE_TUNING occurs.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0001", "lecture_id": "13-NFs-FDs", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0000"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "gap_lectures": 3}}}
{"A": {"name": "DATA_MANAGEMENT", "role": "NA"}, "B": {"name": "RELATIONAL_MODEL", "role": "NA"}, "relation": "depends_on", "justification": "The evidence suggests that the relational model is foundational and was introduced before data management concepts, implying that data management depends on understanding the relational model.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "21-RA__0001", "lecture_id": "21-RA", "text": "It all began with a breakthrough paper, by E.F. Codd in 1970: \"A relational model of data for large shared data banks\". Communications of the ACM 13 (6): 377"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0000"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0001"}, "gap_lectures": 9}}}
{"A": {"name": "DATA_MODELING", "role": "NA"}, "B": {"name": "QUERY_OPTIMIZATION", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly indicate a dependency or part_of relationship between DATA_MODELING and QUERY_OPTIMIZATION.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "5- SQL4-AggGrpViews__0000", "lecture_id": "5- SQL4-AggGrpViews", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems\n工"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0022"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0006"}, "gap_lectures": -11}}}
{"A": {"name": "DATA_MODELING", "role": "NA"}, "B": {"name": "QUERY_PROCESSING", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly indicate a dependency or part_of relationship between DATA_MODELING and QUERY_PROCESSING.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "7- ConstraintsTriggers__0000", "lecture_id": "7- ConstraintsTriggers", "text": "University of Illinois at Urbana -Champaign CS411: Database Systems\n工"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0001"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0006"}, "gap_lectures": -8}}}
{"A": {"name": "DATA_NORMALIZATION", "role": "NA"}, "B": {"name": "FOREIGN_KEYS", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly establish a 'depends_on' or 'part_of' relationship between DATA_NORMALIZATION and FOREIGN_KEYS. The evidence only mentions FOREIGN_KEYS in the context of database design and does not relate it to DATA_NORMALIZATION.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0018", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nMgrSSN is a foreign key (referencing the Employee relation)\nvalue of Manager must match an SSN\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nvs.\nProject(P-number, P-name, Due-Date)\nEmployee(SSN, E-Name, Office)\nManager(P-number, SSN)\nWhat are the tradeoffs between these two?\nNote: P-number is the key for Manager"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0018"}, "gap_lectures": 4}}}
{"A": {"name": "DATA_NORMALIZATION", "role": "NA"}, "B": {"name": "REFERENTIAL_INTEGRITY", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly establish a 'depends_on' or 'part_of' relationship between DATA_NORMALIZATION and REFERENTIAL_INTEGRITY.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design__0018", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nMgrSSN is a foreign key (referencing the Employee relation)\nvalue of Manager must match an SSN\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nvs.\nProject(P-number, P-name, Due-Date)\nEmployee(SSN, E-Name, Office)\nManager(P-number, SSN)\nWhat are the tradeoffs between these two?\nNote: P-number is the key for Manager"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0015"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0018"}, "gap_lectures": 4}}}
{"A": {"name": "DECOMPOSITION", "role": "Example"}, "B": {"name": "MINIMAL_BASIS", "role": "NA"}, "relation": "depends_on", "justification": "The evidence shows that minimal basis is used as a prerequisite step in the decomposition process, indicating that decomposition depends on the concept of minimal basis.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "15-NFs-3NF__0013", "lecture_id": "15-NFs-3NF", "text": "- R(A, B, C) with FDs: · A  BC; B  AC; C  AB\nMinimal Basis: A\n B; B  C; C  A\nSo, first cut: R1(A, B), R2(B, C), R3(C, A) Any attributes left? Nope  done\n- R(A, B, C, D, E) with FDs:\n- A  B; CD  B; DA  C\nBCNF Decomp:\n```\n(AB), (ACD), (ADE) or: (BCD), (ACD), (ADE)\n```\nWhich FDs do each of these not preserve?"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 7, "lecture_id": "15-NFs-3NF", "chunk_id": "15-NFs-3NF__0007"}, "A_first_introduced_at": {"lecture_index": 7, "lecture_id": "15-NFs-3NF", "chunk_id": "15-NFs-3NF__0002"}, "gap_lectures": 0}}}
{"A": {"name": "DECOMPOSITION", "role": "Example"}, "B": {"name": "NORMAL_FORM", "role": "NA"}, "relation": "depends_on", "justification": "The evidence suggests that decomposition is applied in the context of normal forms, indicating that understanding normal forms is a prerequisite for decomposition.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "15-NFs-3NF__0014", "lecture_id": "15-NFs-3NF", "text": "```\nA  B; CD  B; DA  C 3NF Decomp: (AB), (BCD), (ACD), ( ADE )\n```"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 2, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 7, "lecture_id": "15-NFs-3NF", "chunk_id": "15-NFs-3NF__0001"}, "A_first_introduced_at": {"lecture_index": 7, "lecture_id": "15-NFs-3NF", "chunk_id": "15-NFs-3NF__0002"}, "gap_lectures": 0}}}
{"A": {"name": "DECOMPOSITION", "role": "NA"}, "B": {"name": "SUPERKEY", "role": "NA"}, "relation": "depends_on", "justification": "The evidence suggests that understanding superkeys is necessary before decomposing a table, as the text mentions conditions involving superkeys for decomposition.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "DBDesign_BCNF__0003", "lecture_id": "DBDesign_BCNF", "text": "- X  A is OK, if X is a (super)key\n- X  A is NOT OK, otherwise\n- Need to decompose the table, but how?\nBoyce-Codd Normal Form (BCNF)"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 7, "lecture_id": "15-NFs-3NF", "chunk_id": "15-NFs-3NF__0012"}, "A_first_introduced_at": {"lecture_index": 7, "lecture_id": "15-NFs-3NF", "chunk_id": "15-NFs-3NF__0002"}, "gap_lectures": 0}}}
{"A": {"name": "DISTINCT_RESULTS", "role": "Example"}, "B": {"name": "STUDENT_DATA", "role": "NA"}, "relation": "depends_on", "justification": "The evidence shows that DISTINCT_RESULTS is used in a query that retrieves unique results from STUDENT_DATA, indicating that DISTINCT_RESULTS depends on the existence of STUDENT_DATA.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "21-RA__0008", "lecture_id": "21-RA", "text": "- Products are hardly ever used alone; they are typically used in conjunction with a selection. Example:\n<!-- formula-not-decoded -->\nSELECT DISTINCT * FROM Student s JOIN Takes t On s.sid=t.sid\nSELECT DISTINCT * FROM Student s, Takes t WHERE s.sid=t.sid\n1, name = Jill. 1, sid:2 = 1. 1, exp-grade = A. 1, cid = 550-001. 1, sem = F14. 1, name = Jill. 1, sid:2 = 1. 1, exp-grade = C. 1, cid = 502-001. 1, sem = F14. 3, name = Maya. 3, sid:2 = 3. 3, exp-grade = A. 3, cid = 555-001. 3, sem = S15. 3, name = Maya. 3, sid:2 = 3. 3, exp-grade = B. 3, cid = 550-001. 3, sem = F14"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0008"}, "A_first_introduced_at": {"lecture_index": 2, "lecture_id": "11-Neo4J-Part2", "chunk_id": "11-Neo4J-Part2__0016"}, "gap_lectures": -10}}}
{"A": {"name": "DOCUMENT_ORIENTED", "role": "NA"}, "B": {"name": "NOSQL_SOLUTIONS", "role": "Definition"}, "relation": "part_of", "justification": "The evidence shows that MongoDB, which is described as a document-oriented solution, is an example of a NoSQL solution. This indicates that document-oriented is a specific type within the broader category of NoSQL solutions.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "8- NoSQL-MongoDB-Basics__0027", "lecture_id": "8- NoSQL-MongoDB-Basics", "text": "- NoSQL solutions address the needs of modern applications\n- MongoDB is an example of a document-oriented solution\n- The query language is oriented around ' collection ' at a time processing\n- The power of many of these solutions lies in the distributed, parallel nature of query processing\n- Replication and sharding"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 20, "lecture_id": "8- NoSQL-MongoDB-Basics", "chunk_id": "8- NoSQL-MongoDB-Basics__0008"}, "A_first_introduced_at": {"lecture_index": 20, "lecture_id": "8- NoSQL-MongoDB-Basics", "chunk_id": "8- NoSQL-MongoDB-Basics__0002"}, "gap_lectures": 0}}}
{"A": {"name": "EMPLOYEE_DEPARTMENT", "role": "NA"}, "B": {"name": "JOIN_OPERATION", "role": "NA"}, "relation": "depends_on", "justification": "The evidence shows that the JOIN_OPERATION is used to retrieve data from both the Employee and Department tables, indicating that JOIN_OPERATION is a prerequisite for understanding how EMPLOYEE_DEPARTMENT relationships are formed and queried.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "3-SQL2-JOINS_Nulls__0004", "lecture_id": "3-SQL2-JOINS_Nulls", "text": "Employee Department\nEmployee.DeptID = Department.DeptID\nSELECT *\nFROM Employee emp JOIN Department dept\nON emp.DepartmentID = dept.DepartmentID\nRobinson,  = 34. Robinson, Employee.LastName Employee.DepartmentiDDepartment.DepartmentName Department.DepartmentID = Clerical. Robinson,  = 34. Jones,  = 33. Jones, Employee.LastName Employee.DepartmentiDDepartment.DepartmentName Department.DepartmentID = Engineering. Jones,  = 33. Smith,  = 34. Smith, Employee.LastName Employee.DepartmentiDDepartment.DepartmentName Department.DepartmentID = Clerical. Smith,  = . Steinberg,  = 33. Steinberg, Employee.LastName Employee.DepartmentiDDepartment.DepartmentName Department.DepartmentID = Engineering. Steinberg,  = 33. Rafferty,  = 31. Rafferty, Employee.LastName Employee.DepartmentiDDepartment.DepartmentName Department.DepartmentID = Sales. Rafferty,  = 31\n34,  = Smith. 34, DepartmentiD Employee.LastName Department.DepartmentName = Clerical. 33,  = Jones. 33, DepartmentiD Employee.LastName Department.DepartmentName = Engineering. 34,  = Robinson. 34, DepartmentiD Employee.LastName Department.DepartmentName = Clerical. 33,  = Steinberg. 33, DepartmentiD Employee.LastName Department.DepartmentName = Engineering. 31,  = Rafferty. 31, DepartmentiD Employee.LastName Department.DepartmentName = Sales"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0005"}, "A_first_introduced_at": {"lecture_index": 15, "lecture_id": "3-SQL2-JOINS_Nulls", "chunk_id": "3-SQL2-JOINS_Nulls__0004"}, "gap_lectures": 3}}}
{"A": {"name": "ENTITIES_RELATIONSHIPS", "role": "NA"}, "B": {"name": "INDEXING", "role": "NA"}, "relation": "depends_on", "justification": "The evidence suggests that understanding entities and relationships is a prerequisite for discussing indexing, as indexing is introduced after the logical design phase which includes entities and relationships.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "15-NFs-3NF__0017", "lecture_id": "15-NFs-3NF", "text": "- Conceptual design:  (ER & UML Models are used\n- for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\nWe'll discuss indexing next.\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 2, "lecture_id": "11-Neo4J-Part2", "chunk_id": "11-Neo4J-Part2__0005"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "gap_lectures": 2}}}
{"A": {"name": "ENTITY", "role": "NA"}, "B": {"name": "FOREIGN_KEY", "role": "NA"}, "relation": "depends_on", "justification": "The evidence shows that understanding foreign keys is necessary to identify the attributes and keys for the Assignment entity, indicating that ENTITY depends on FOREIGN_KEY.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0016", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nWhat are the attributes and what is the key for Assignment?\n```\nProject(P-number, P-name, Due-Date) Employee(SSN, E-Name, Office)\n```\nProject\nP-number P-name Due-Date\nEmployee\nSSN\nE-Name\nOffice\n0..*     Assignment      0..*\n- 0..*        Manager        1..1\nAnswer: Assignment(P-Number, SSN)\nP-Number is a foreign key for Project SSN is a foreign key for Employee\nProject(P-Number, P-Due-Date)\nEmployee(SSN, E-Name, Office)"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0000"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0005"}, "gap_lectures": 4}}}
{"A": {"name": "ENTITY_IDENTIFICATION", "role": "Definition"}, "B": {"name": "MANY_ONE_RELATIONSHIP", "role": "NA"}, "relation": "depends_on", "justification": "The evidence shows that understanding many-one relationships is necessary to identify entities uniquely, indicating that entity identification depends on the concept of many-one relationships.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0012", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Occasionally, entities of an entity set need 'help' to identify them uniquely.\n- Entity set E is weak if in order to identify entities of E uniquely, we need to follow one or more many-one relationships from E and include the key of the related entity sets.\n- Note: not an is-a relationship because E is not a 'subclass' of F: Univ and Team"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0006"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0010"}, "gap_lectures": 0}}}
{"A": {"name": "FOREIGN_KEY", "role": "Definition"}, "B": {"name": "RELATIONAL_MODEL", "role": "Definition"}, "relation": "part_of", "justification": "FOREIGN_KEY is a specific terminology within the relational data model, indicating it is a part of the broader concept RELATIONAL_MODEL.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "1-RelationalModel__0000", "lecture_id": "1-RelationalModel", "text": "- Define a data model\n- Define the relational data model\n- Articulate the basic terminologies of the relational data model (from a practical perspective)\n- Define Primary and Foreign keys"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0000"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0000"}, "gap_lectures": 0}}}
{"A": {"name": "FOREIGN_KEY", "role": "NA"}, "B": {"name": "RELATIONSHIP", "role": "NA"}, "relation": "depends_on", "justification": "The evidence shows that FOREIGN_KEY is used to establish relationships between tables, indicating that understanding FOREIGN_KEY is a prerequisite for understanding RELATIONSHIP.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0016", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nWhat are the attributes and what is the key for Assignment?\n```\nProject(P-number, P-name, Due-Date) Employee(SSN, E-Name, Office)\n```\nProject\nP-number P-name Due-Date\nEmployee\nSSN\nE-Name\nOffice\n0..*     Assignment      0..*\n- 0..*        Manager        1..1\nAnswer: Assignment(P-Number, SSN)\nP-Number is a foreign key for Project SSN is a foreign key for Employee\nProject(P-Number, P-Due-Date)\nEmployee(SSN, E-Name, Office)"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0005"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0000"}, "gap_lectures": -4}}}
{"A": {"name": "FOREIGN_KEY", "role": "NA"}, "B": {"name": "TRIGGERS", "role": "NA"}, "relation": null, "justification": "The evidence does not clearly indicate a dependency or part_of relationship between FOREIGN_KEY and TRIGGERS.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "7- ConstraintsTriggers__0023", "lecture_id": "7- ConstraintsTriggers", "text": "- We can do attribute -based check, why tuple level?\n- Reason 1: If the check involves more than one attribute of the tuple, we need the tuple -level check.\n- Reason 2: Tuple -level constraints are checked more frequently.\n- Whenever there are any inserts or updates to any of the concerned attributes\nI\n- Constraints\n-  Foreign -key, or referential -integrity constraints.\n-  Value -based constraints.\n-  Tuple -based constraints.\n- Assertions.\n- Triggers"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 19, "lecture_id": "7- ConstraintsTriggers", "chunk_id": "7- ConstraintsTriggers__0001"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0000"}, "gap_lectures": -19}}}
{"A": {"name": "FOREIGN_KEYS", "role": "NA"}, "B": {"name": "FUNCTIONAL_DEPENDENCIES", "role": "NA"}, "relation": "depends_on", "justification": "The evidence shows that foreign keys are used to enforce functional dependencies, indicating that understanding functional dependencies is a prerequisite for defining foreign keys.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0021", "lecture_id": "13-NFs-FDs", "text": "Dept(dnum, dname, dmgr)\n1. Lift the 'troublesome' FD into its own table with dnum as the key.  Now they will be enforced.\nEMP(name, ssn, birthdate, address, dnum, dname, dmgr)\nNew-Emp(name, ssn, birthdate, address, dnum)\n2. Leave the LHS of the 'troublesome' FDs behind. Define a foreign key where New-Emp.dnum REFERENCES Dept.dnum"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0003"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "gap_lectures": -6}}}
{"A": {"name": "FOREIGN_KEY_CONSTRAINT", "role": "NA"}, "B": {"name": "REFERENTIAL_INTEGRITY", "role": "NA"}, "relation": "depends_on", "justification": "The evidence shows that foreign key constraints are used to enforce referential integrity, indicating that referential integrity is a prerequisite concept for understanding foreign key constraints.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "7- ConstraintsTriggers__0007", "lecture_id": "7- ConstraintsTriggers", "text": "If there is a foreign -key constraint from attributes of relation R to the primary key of relation S , two violations are possible:\n1. An insert or update to R introduces values not found in S .\n2. A deletion or update to S causes some tuples of R to 'dangle.'\nWhy are the other two cases (insert to S and delete of R) not important?\nIILLINOIS"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0015"}, "A_first_introduced_at": {"lecture_index": 19, "lecture_id": "7- ConstraintsTriggers", "chunk_id": "7- ConstraintsTriggers__0004"}, "gap_lectures": 19}}}
{"A": {"name": "FOREIGN_KEY_CONSTRAINT", "role": "NA"}, "B": {"name": "TRIGGERS", "role": "NA"}, "relation": null, "justification": "The provided evidence does not establish a clear dependency or part_of relationship between FOREIGN_KEY_CONSTRAINT and TRIGGERS.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "7- ConstraintsTriggers__0019", "lecture_id": "7- ConstraintsTriggers", "text": "- An attribute -based check is checked only when a value for that attribute is inserted or updated.\n- Example: CHECK (price <= 5.00) checks every new price and rejects it if it is more than $5.\n- Example: CHECK (drink IN (SELECT name FROM Drinks)) not checked if a drink is deleted from Drinks or updated (unlike foreign -keys).\n- Only checked during inserts/updates of that attribute\nI ILLINOIS\n- Constraints\n-  Foreign -key, or referential -integrity constraints.\n-  Value -based constraints.\n- Tuple -based constraints.\n- Assertions.\n- Triggers"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 19, "lecture_id": "7- ConstraintsTriggers", "chunk_id": "7- ConstraintsTriggers__0001"}, "A_first_introduced_at": {"lecture_index": 19, "lecture_id": "7- ConstraintsTriggers", "chunk_id": "7- ConstraintsTriggers__0004"}, "gap_lectures": 0}}}
{"A": {"name": "FROM_CLAUSE", "role": "NA"}, "B": {"name": "WHERE_CONDITION", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly establish a 'depends_on' or 'part_of' relationship between FROM_CLAUSE and WHERE_CONDITION. Both clauses are part of SQL syntax but are used independently without one being a prerequisite or a component of the other.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "2-SQL-Basics__0007", "lecture_id": "2-SQL-Basics", "text": "-  If you want the result to have different attribute names, use 'AS ώnew nameϏ' to rename an attribute.\n-  Example based on Account(number, owner, balance, typeȌ:\nSELECT NXPbeU AS Acc_NXP, OZQeU\n```\nFROM AccRXQWV WHERE T\\Se = \"VaYLQgV\";\n```\nAcc_Num, 1 = Owner. 103, 1 = J. Smith"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 10, "lecture_id": "2-SQL-Basics", "chunk_id": "2-SQL-Basics__0004"}, "A_first_introduced_at": {"lecture_index": 10, "lecture_id": "2-SQL-Basics", "chunk_id": "2-SQL-Basics__0005"}, "gap_lectures": 0}}}
{"A": {"name": "FUNCTIONAL_DEPENDENCIES", "role": "NA"}, "B": {"name": "UPDATE_ANOMALIES", "role": "NA"}, "relation": "depends_on", "justification": "Functional dependencies are necessary to understand the concept of update anomalies, as the presence of certain functional dependencies can lead to redundancy and update anomalies in a database.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0020", "lecture_id": "13-NFs-FDs", "text": "EMP(name, ssn, birthdate, address, dnum, dname, dmgr)\nWe have a problem! dnum is NOT the key for this table!\nSo these blue FDs will not be enforced automatically by the DBMS (using only keys). And there can be redundancy and update anomalies"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 2, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0014"}, "A_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0003"}, "gap_lectures": 0}}}
{"A": {"name": "FUNCTIONAL_DEPENDENCY", "role": "NA"}, "B": {"name": "PRIMARY_KEY", "role": "NA"}, "relation": "depends_on", "justification": "The evidence suggests that understanding the concept of a primary key is necessary to comprehend how functional dependencies work in the context of preventing anomalies in a database table.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0012", "lecture_id": "13-NFs-FDs", "text": "Consider this table:\nEmp(ssn, name, phone, dnum, dept-name)\nSuppose there is an FD from dnum → dept-name\nBut ssn is the key for this table.\nWhat will prevent two names for one dept?"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0000"}, "A_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0012"}, "gap_lectures": 6}}}
{"A": {"name": "FUNCTIONAL_DEPENDENCY", "role": "NA"}, "B": {"name": "SUPERKEY", "role": "Definition"}, "relation": "depends_on", "justification": "The evidence shows that a functional dependency's left side must be a superkey, indicating that understanding superkeys is a prerequisite for understanding functional dependencies.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "DBDesign_BCNF__0004", "lecture_id": "DBDesign_BCNF", "text": "Whenever there is a nontrivial FD: A 1 A2 …A n  B, then A 1 A2 …A n is a superkey for R.\nThere are no 'bad' FDs: whenever there is a nontrivial FD, its left side must be a superkey"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 7, "lecture_id": "15-NFs-3NF", "chunk_id": "15-NFs-3NF__0012"}, "A_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0012"}, "gap_lectures": -1}}}
{"A": {"name": "GRAPH_DATABASE", "role": "NA"}, "B": {"name": "NODES", "role": "NA"}, "relation": "part_of", "justification": "The evidence shows that nodes are a fundamental component of graph databases, indicating that nodes are part of the broader concept of graph databases.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "10-Neo4J-Part 1__0022", "lecture_id": "10-Neo4J-Part 1", "text": "```\n{name:\"Lamya\"}) MATCH (a:Person {name:\"Devin\"}) MATCH (b:Person \"Vidisha\"}) MATCH (c:Person {name: CREATE (a)-[:Friends]->(b)<-[:Friends]-(c) RETURN a,b,c\n```"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0002"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0008"}, "gap_lectures": 0}}}
{"A": {"name": "GRAPH_DATABASE", "role": "Definition"}, "B": {"name": "NODE_PROPERTIES", "role": "Definition"}, "relation": "part_of", "justification": "NODE_PROPERTIES are a component of GRAPH_DATABASE, as they define properties of nodes within the database.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "11-Neo4J-Part2__0010", "lecture_id": "11-Neo4J-Part2", "text": "Source: https://neo4j.com/developer/cypher-query-language/"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0027"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0008"}, "gap_lectures": 0}}}
{"A": {"name": "GRAPH_DATABASE", "role": "NA"}, "B": {"name": "PATTERN_MATCHING", "role": "Definition"}, "relation": "depends_on", "justification": "The evidence shows that pattern matching is used to query a graph database to find specific patterns, indicating that pattern matching is a prerequisite for effectively using a graph database.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "10-Neo4J-Part 1__0008", "lecture_id": "10-Neo4J-Part 1", "text": "- SQL -like syntax\n- Declarative pattern -matching graph query language\n- Query a graph DB to find data (Nodes, Relationships, subgraphs) that matches a specific pattern\n- uses ASCII to specify a patterns"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0008"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0008"}, "gap_lectures": 0}}}
{"A": {"name": "GRAPH_DATABASE", "role": "NA"}, "B": {"name": "QUERY_LANGUAGE", "role": "NA"}, "relation": "depends_on", "justification": "The evidence shows that a query language is used to interact with a graph database, indicating that understanding the query language is necessary to effectively use the graph database.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "10-Neo4J-Part 1__0018", "lecture_id": "10-Neo4J-Part 1", "text": "```\nMATCH (p:Person)-[:ACTED_IN]->(m:Movie)<-[:DIRECTED]-Cp) RETURN I p.name, m.title;\n```\nTom Hanks, m.title = That Thing You Do. Clint Eastwood, m.title = Unforgiven. Danny DeVito, m.title = Hoffa"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 2, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0007"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0008"}, "gap_lectures": 0}}}
{"A": {"name": "GRAPH_DATABASE", "role": "NA"}, "B": {"name": "RELATIONSHIPS", "role": "NA"}, "relation": "part_of", "justification": "The evidence shows that relationships are used within the context of a graph database, indicating that relationships are a component of graph databases.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "10-Neo4J-Part 1__0022", "lecture_id": "10-Neo4J-Part 1", "text": "```\n{name:\"Lamya\"}) MATCH (a:Person {name:\"Devin\"}) MATCH (b:Person \"Vidisha\"}) MATCH (c:Person {name: CREATE (a)-[:Friends]->(b)<-[:Friends]-(c) RETURN a,b,c\n```"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0002"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0008"}, "gap_lectures": 0}}}
{"A": {"name": "GRAPH_DATABASES", "role": "Definition"}, "B": {"name": "NODES", "role": "NA"}, "relation": "part_of", "justification": "Graph databases are a type of database that stores data in a graph structure, where nodes are a fundamental component of this structure.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "10-Neo4J-Part 1__0002", "lecture_id": "10-Neo4J-Part 1", "text": "- Many types of data can be represented as graphs\n- Road networks, with intersections as nodes and road segments as edges\n- Computer networks, with computers as nodes and connections as edges\n- Social networks, with people/postings as nodes and edges as relationship (e.g. friends, likes, created, …)\n- Graph databases store relationships and connections as first -class entities: 'Property Graph Model'\nRoad Nodes\n非\nSingle Direction Road Links\nDouble Direction Road Links"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0002"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0002"}, "gap_lectures": 0}}}
{"A": {"name": "GRAPH_DATABASES", "role": "NA"}, "B": {"name": "NODE_PROPERTIES", "role": "Definition"}, "relation": "part_of", "justification": "NODE_PROPERTIES are a component of GRAPH_DATABASES, as they define properties of nodes within the graph database structure.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "11-Neo4J-Part2__0011", "lecture_id": "11-Neo4J-Part2", "text": "Source: https://neo4j.com/developer/cypher-query-language/"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0027"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0002"}, "gap_lectures": 0}}}
{"A": {"name": "GRAPH_DATABASES", "role": "Definition"}, "B": {"name": "RELATIONSHIPS", "role": "Definition"}, "relation": "part_of", "justification": "Graph databases are described as storing relationships and connections as first-class entities, indicating that relationships are a component of the broader concept of graph databases.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "10-Neo4J-Part 1__0002", "lecture_id": "10-Neo4J-Part 1", "text": "- Many types of data can be represented as graphs\n- Road networks, with intersections as nodes and road segments as edges\n- Computer networks, with computers as nodes and connections as edges\n- Social networks, with people/postings as nodes and edges as relationship (e.g. friends, likes, created, …)\n- Graph databases store relationships and connections as first -class entities: 'Property Graph Model'\nRoad Nodes\n非\nSingle Direction Road Links\nDouble Direction Road Links"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0002"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0002"}, "gap_lectures": 0}}}
{"A": {"name": "GROUP_BY", "role": "NA"}, "B": {"name": "RELATIONAL_ALGEBRA", "role": "NA"}, "relation": "part_of", "justification": "GROUP_BY is a specific operation within the broader concept of RELATIONAL_ALGEBRA.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "23-Rule-basedOpt__0001", "lecture_id": "23-Rule-basedOpt", "text": "Need to start someplace..\nThe easy cases:\n```\nSelect a1, …, an From R1, …, Rk Where C\n```\n<!-- formula-not-decoded -->\n```\nSelect a1, …, an, aggs From R1, …, Rk Where C Group by b1, …, bl\n```\nUses 'extended' relational algebra, with gamma and delta\n<!-- formula-not-decoded -->\nIn most of these cases, the x will be a"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0002"}, "A_first_introduced_at": {"lecture_index": 14, "lecture_id": "23-Rule-basedOpt", "chunk_id": "23-Rule-basedOpt__0001"}, "gap_lectures": 2}}}
{"A": {"name": "INDEXING", "role": "NA"}, "B": {"name": "LOGICAL_DESIGN", "role": "NA"}, "relation": "depends_on", "justification": "The evidence suggests that indexing is discussed after logical design, indicating that logical design is a prerequisite for understanding indexing.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "15-NFs-3NF__0017", "lecture_id": "15-NFs-3NF", "text": "- Conceptual design:  (ER & UML Models are used\n- for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\nWe'll discuss indexing next.\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "A_first_introduced_at": {"lecture_index": 2, "lecture_id": "11-Neo4J-Part2", "chunk_id": "11-Neo4J-Part2__0005"}, "gap_lectures": -2}}}
{"A": {"name": "INDEXING", "role": "NA"}, "B": {"name": "NORMALIZATION", "role": "NA"}, "relation": "depends_on", "justification": "The evidence suggests that normalization is discussed before indexing, indicating that normalization is a prerequisite for understanding indexing.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "15-NFs-3NF__0017", "lecture_id": "15-NFs-3NF", "text": "- Conceptual design:  (ER & UML Models are used\n- for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\nWe'll discuss indexing next.\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0000"}, "A_first_introduced_at": {"lecture_index": 2, "lecture_id": "11-Neo4J-Part2", "chunk_id": "11-Neo4J-Part2__0005"}, "gap_lectures": 1}}}
{"A": {"name": "INDEXING", "role": "NA"}, "B": {"name": "PHYSICAL_DESIGN", "role": "NA"}, "relation": "depends_on", "justification": "The evidence suggests that indexing is discussed after physical database design, indicating that indexing relies on the understanding of physical design.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "15-NFs-3NF__0017", "lecture_id": "15-NFs-3NF", "text": "- Conceptual design:  (ER & UML Models are used\n- for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\nWe'll discuss indexing next.\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "A_first_introduced_at": {"lecture_index": 2, "lecture_id": "11-Neo4J-Part2", "chunk_id": "11-Neo4J-Part2__0005"}, "gap_lectures": -2}}}
{"A": {"name": "INDEXING", "role": "NA"}, "B": {"name": "RELATIONAL_SCHEMA", "role": "NA"}, "relation": "depends_on", "justification": "The evidence suggests that indexing is discussed after the relational schema, indicating that understanding the relational schema is a prerequisite for discussing indexing.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "15-NFs-3NF__0017", "lecture_id": "15-NFs-3NF", "text": "- Conceptual design:  (ER & UML Models are used\n- for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\nWe'll discuss indexing next.\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "A_first_introduced_at": {"lecture_index": 2, "lecture_id": "11-Neo4J-Part2", "chunk_id": "11-Neo4J-Part2__0005"}, "gap_lectures": -2}}}
{"A": {"name": "INDEXING", "role": "NA"}, "B": {"name": "SCHEMA_REFINEMENT", "role": "Definition"}, "relation": "depends_on", "justification": "The evidence suggests that schema refinement is discussed before indexing, indicating that indexing relies on the understanding of schema refinement.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "15-NFs-3NF__0017", "lecture_id": "15-NFs-3NF", "text": "- Conceptual design:  (ER & UML Models are used\n- for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\nWe'll discuss indexing next.\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "A_first_introduced_at": {"lecture_index": 2, "lecture_id": "11-Neo4J-Part2", "chunk_id": "11-Neo4J-Part2__0005"}, "gap_lectures": -2}}}
{"A": {"name": "JOIN_OPERATION", "role": "Example"}, "B": {"name": "LEFT_OUTER_JOIN", "role": "Definition"}, "relation": "part_of", "justification": "LEFT_OUTER_JOIN is a specific type of JOIN_OPERATION, indicating that JOIN_OPERATION is the broader concept that includes LEFT_OUTER_JOIN as a component.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "3-SQL2-JOINS_Nulls__0010", "lecture_id": "3-SQL2-JOINS_Nulls", "text": "Rafferty, Employeetable.LastName DepartmentID = 31. Jones, Employeetable.LastName DepartmentID = 33. Steinberg, Employeetable.LastName DepartmentID = 33. Robinson, Employeetable.LastName DepartmentID = 34. Smith, Employeetable.LastName DepartmentID = 34. John, Employeetable.LastName DepartmentID = NULL\nSELECT  *\nFROM Employee emp LEFT OUTER JOIN Department dept ON emp.DepartmentID = dept.DepartmentID\nJones,  = 33. Jones, Employee.LastName Employee.DepartmentIDDepartment.DepartmentName Department.DepartmentID = Engineering. Jones,  = 33. Rafferty,  = 31. Rafferty, Employee.LastName Employee.DepartmentIDDepartment.DepartmentName Department.DepartmentID = Sales. Rafferty,  = 31. Robinson,  = . Robinson, Employee.LastName Employee.DepartmentIDDepartment.DepartmentName Department.DepartmentID = Clerical. Robinson,  = . Smith,  = 34. Smith, Employee.LastName Employee.DepartmentIDDepartment.DepartmentName Department.DepartmentID = Clerical. Smith,  = . John,  = NULL. John, Employee.LastName Employee.DepartmentIDDepartment.DepartmentName Department.DepartmentID = NULL. John,  = TTON. Steinberg,  = 33. Steinberg, Employee.LastName Employee.DepartmentIDDepartment.DepartmentName Department.DepartmentID = Engineering. Steinberg,  = 33\n31, Departmenttable.DepartmentiD DepartmentName = Sales. 33, Departmenttable.DepartmentiD DepartmentName = Engineering. , Departmenttable.DepartmentiD DepartmentName = Clerical. 35, Departmenttable.DepartmentiD DepartmentName = Marketing"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 15, "lecture_id": "3-SQL2-JOINS_Nulls", "chunk_id": "3-SQL2-JOINS_Nulls__0009"}, "A_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0005"}, "gap_lectures": -3}}}
{"A": {"name": "KEYS", "role": "NA"}, "B": {"name": "REFERENTIAL_INTEGRITY", "role": "Definition"}, "relation": "depends_on", "justification": "Referential integrity depends on the concept of keys, as foreign keys are used to enforce referential integrity between tables.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "1-RelationalModel__0015", "lecture_id": "1-RelationalModel", "text": ", Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. , Number = 102. , Owner = W. Wei. , Balance = 2000.00. , Type = checking. , Number = 103. , Owner = J. Smith. , Balance = 5000.00. , Type = savings. , Number = 104. , Owner = M. Jones. , Balance = 1000.00. , Type = checking. , Number = 105. , Owner = H. Martin. , Balance = 10,000.00. , Type = checking. Deposit, Number = AcctNo Transaction-id. Deposit, Owner = Date. Deposit, Balance = Amount. Deposit, Type = . , Number = 102 1. , Owner = 10/22/00. , Balance = 500.00. , Type = . , Number = 102 2. , Owner = 10/29/00. , Balance = 200.00. , Type = . , Number = 104 3. , Owner = 10/29/00. , Balance = 1000.00. , Type = . , Number = 105 4. , Owner = 11/02/00. , Balance = 10,000.00. , Type = . , Number = 106 5. , Owner = 12/05/00. , Balance = 555.00. , Type = \nWe say that Deposit.AcctNo is a foreign key that references Account.Number.  If the DBMS enforces this constraint, we have referential integrity .\n, Foreign keys might or might not be part of the key for the referring table.Number = 101 102 103 104 105. , Foreign keys might or might not be part of the key for the referring table.Owner = J. Smith W. Wei J. Smith M. Jones H. Martin. , Foreign keys might or might not be part of the key for the referring table.Balance = 1000.00 2000.00 5000.00 1000.00 10,000.00. , Foreign keys might or might not be part of the key for the referring table.Type = checking checking savings checking checking. Deposit, Foreign keys might or might not be part of the key for the referring table.Number = AcctNo. Deposit, Foreign keys might or might not be part of the key for the referring table.Owner = Transaction-id. Deposit, Foreign keys might or might not be part of the key for the referring table.Balance = Date. Deposit, Foreign keys might or might not be part of the key for the referring table.Type = Amount. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Number = AcctNo 101 101. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Owner = Check-number 924 925. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Balance = Date 10/23/00 10/24/00. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Type = Amount 125.00 23.98\n-  Data Models\n- Relational Database Model\n-  Basic Concepts and Terminology\n-  Keys and Foreign Keys\n- Schema Specifications"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0015"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "gap_lectures": 0}}}
{"A": {"name": "MINIMAL_BASIS", "role": "NA"}, "B": {"name": "SUPERKEY", "role": "NA"}, "relation": "depends_on", "justification": "The evidence shows that the concept of a 'minimal basis' is used to derive new relations, and the concept of 'superkey' is used to check if these new relations are valid. The process of checking if a schema is a superkey depends on the minimal basis derived from the FDs.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "15-NFs-3NF__0012", "lecture_id": "15-NFs-3NF", "text": "1. Get a ' minimal basis ' G of given FDs\n2. For each FD A  B in the minimal basis G , use AB as the schema of a new relation.\n3. If none of the schemas from Step 2 is a superkey, add another relation whose schema is a key for the original relation.\nResult will be lossless, will be dependency-preserving, 3NF; might not be BCNF\n1. Get a ' minimal basis ' G of given FDs\n2. For each FD A  B in the minimal basis G , use AB as the schema of a new relation.\n3. If none of the schemas from Step 2 is a superkey, add another relation whose schema is a key for the original relation.\nResult will be lossless, will be dependency-preserving, Basically every minimal FD is preserved somewhere Implicitly this is connecting all the LHSs with the remaining attributes"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 7, "lecture_id": "15-NFs-3NF", "chunk_id": "15-NFs-3NF__0012"}, "A_first_introduced_at": {"lecture_index": 7, "lecture_id": "15-NFs-3NF", "chunk_id": "15-NFs-3NF__0007"}, "gap_lectures": 0}}}
{"A": {"name": "NORMALIZATION", "role": "Definition"}, "B": {"name": "REDUNDANCY_REDUCTION", "role": "NA"}, "relation": "depends_on", "justification": "Normalization is described as a process that reduces redundancy, indicating that redundancy reduction is a prerequisite or outcome of normalization.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0019", "lecture_id": "13-NFs-FDs", "text": "Normalization by decomposition, based on FDs (where 'troublesome' FDs are lifted into a separate table), reduces redundancy and update anomalies."}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0019"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0000"}, "gap_lectures": -5}}}
{"A": {"name": "NORMALIZATION", "role": "Definition"}, "B": {"name": "TRANSACTIONS", "role": "Definition"}, "relation": null, "justification": "The provided evidence does not establish any clear relationship between 'NORMALIZATION' and 'TRANSACTIONS'. The text does not provide enough context to determine if one depends on the other or if one is part of the other.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "10-Neo4J-Part 1__0000", "lecture_id": "10-Neo4J-Part 1", "text": "University of Illinois at Urbana -Champaign CS411: Database Systems"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0000"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0000"}, "gap_lectures": 0}}}
{"A": {"name": "NORMALIZATION", "role": "Definition"}, "B": {"name": "UPDATE_ANOMALIES", "role": "NA"}, "relation": "depends_on", "justification": "Normalization is a process that reduces redundancy and update anomalies, implying that understanding update anomalies is a prerequisite for normalization.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0019", "lecture_id": "13-NFs-FDs", "text": "Normalization by decomposition, based on FDs (where 'troublesome' FDs are lifted into a separate table), reduces redundancy and update anomalies."}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0014"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0000"}, "gap_lectures": -5}}}
{"A": {"name": "NOSQL_SOLUTIONS", "role": "Definition"}, "B": {"name": "QUERY_LANGUAGE", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly establish a 'depends_on' or 'part_of' relationship between NOSQL solutions and query language.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "8- NoSQL-MongoDB-Basics__0027", "lecture_id": "8- NoSQL-MongoDB-Basics", "text": "- NoSQL solutions address the needs of modern applications\n- MongoDB is an example of a document-oriented solution\n- The query language is oriented around ' collection ' at a time processing\n- The power of many of these solutions lies in the distributed, parallel nature of query processing\n- Replication and sharding"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0007"}, "A_first_introduced_at": {"lecture_index": 20, "lecture_id": "8- NoSQL-MongoDB-Basics", "chunk_id": "8- NoSQL-MongoDB-Basics__0008"}, "gap_lectures": 19}}}
{"A": {"name": "QUERY_OPTIMIZATION", "role": "NA"}, "B": {"name": "RELATIONAL_ALGEBRA", "role": "NA"}, "relation": "depends_on", "justification": "The evidence shows that relational algebra is used in query optimization to find the most efficient representation, indicating that query optimization depends on understanding relational algebra.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "21-RA__0022", "lecture_id": "21-RA", "text": "- The relational algebra is a set of mathematical operators that compose, modify, and combine tuples within different relations\n- Basic SQL expressions can be expressed in this form\n- Relational algebra has laws of commutativity, associativity, etc. that imply certain expressions are equivalent in semantics\n- This is used in query optimization to find the most efficient representation to evaluate (or one that's not bad)"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0002"}, "A_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0022"}, "gap_lectures": 0}}}
{"A": {"name": "QUERY_OPTIMIZATION", "role": "NA"}, "B": {"name": "STORAGE_STRUCTURES", "role": "NA"}, "relation": "depends_on", "justification": "Query optimization likely depends on understanding storage structures, as the optimization process needs to consider how data is stored and accessed.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "5- SQL4-AggGrpViews__0000", "lecture_id": "5- SQL4-AggGrpViews", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems\n工"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0001"}, "A_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0022"}, "gap_lectures": 3}}}
{"A": {"name": "QUERY_OPTIMIZATION", "role": "NA"}, "B": {"name": "TRANSACTION_MANAGEMENT", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly indicate a dependency or part_of relationship between QUERY_OPTIMIZATION and TRANSACTION_MANAGEMENT.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "5- SQL4-AggGrpViews__0000", "lecture_id": "5- SQL4-AggGrpViews", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems\n工"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0001"}, "A_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0022"}, "gap_lectures": 3}}}
{"A": {"name": "READ_OPERATION", "role": "NA"}, "B": {"name": "SERIAL_SCHEDULE", "role": "NA"}, "relation": "depends_on", "justification": "The evidence suggests that understanding read operations is necessary to comprehend serial schedules, as serial schedules involve specific read operations to maintain view equivalence.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0014", "lecture_id": "20-Trxn-Serializability", "text": "Two schedules S1 and S2 are view equivalent if:\n- If ௜ reads an initial value of A in S1, then ௜ reads the initial value of A in S2\n- If ௜ reads a value of A written by ௝ in S1, then ௜ reads a value of A written by ௝ in S2\n- If ௜ writes the final value of A in S1, then ௜ writes the final value of A in S2\nA schedule is view serializable if it is view-equivalent to a serial schedule"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0005"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0021"}, "gap_lectures": -2}}}
{"A": {"name": "REDUNDANCY_REDUCTION", "role": "NA"}, "B": {"name": "UPDATE_ANOMALIES", "role": "NA"}, "relation": "depends_on", "justification": "The evidence suggests that normalization by decomposition reduces redundancy and update anomalies together, implying that understanding update anomalies is necessary to fully grasp redundancy reduction.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "13-NFs-FDs__0019", "lecture_id": "13-NFs-FDs", "text": "Normalization by decomposition, based on FDs (where 'troublesome' FDs are lifted into a separate table), reduces redundancy and update anomalies."}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0014"}, "A_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0019"}, "gap_lectures": 0}}}
{"A": {"name": "REFERENTIAL_INTEGRITY", "role": "Definition"}, "B": {"name": "SCHEMA_SPECIFICATIONS", "role": "NA"}, "relation": "part_of", "justification": "Referential integrity is a specific constraint that is part of the broader concept of schema specifications.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "1-RelationalModel__0015", "lecture_id": "1-RelationalModel", "text": ", Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. , Number = 102. , Owner = W. Wei. , Balance = 2000.00. , Type = checking. , Number = 103. , Owner = J. Smith. , Balance = 5000.00. , Type = savings. , Number = 104. , Owner = M. Jones. , Balance = 1000.00. , Type = checking. , Number = 105. , Owner = H. Martin. , Balance = 10,000.00. , Type = checking. Deposit, Number = AcctNo Transaction-id. Deposit, Owner = Date. Deposit, Balance = Amount. Deposit, Type = . , Number = 102 1. , Owner = 10/22/00. , Balance = 500.00. , Type = . , Number = 102 2. , Owner = 10/29/00. , Balance = 200.00. , Type = . , Number = 104 3. , Owner = 10/29/00. , Balance = 1000.00. , Type = . , Number = 105 4. , Owner = 11/02/00. , Balance = 10,000.00. , Type = . , Number = 106 5. , Owner = 12/05/00. , Balance = 555.00. , Type = \nWe say that Deposit.AcctNo is a foreign key that references Account.Number.  If the DBMS enforces this constraint, we have referential integrity .\n, Foreign keys might or might not be part of the key for the referring table.Number = 101 102 103 104 105. , Foreign keys might or might not be part of the key for the referring table.Owner = J. Smith W. Wei J. Smith M. Jones H. Martin. , Foreign keys might or might not be part of the key for the referring table.Balance = 1000.00 2000.00 5000.00 1000.00 10,000.00. , Foreign keys might or might not be part of the key for the referring table.Type = checking checking savings checking checking. Deposit, Foreign keys might or might not be part of the key for the referring table.Number = AcctNo. Deposit, Foreign keys might or might not be part of the key for the referring table.Owner = Transaction-id. Deposit, Foreign keys might or might not be part of the key for the referring table.Balance = Date. Deposit, Foreign keys might or might not be part of the key for the referring table.Type = Amount. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Number = AcctNo 101 101. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Owner = Check-number 924 925. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Balance = Date 10/23/00 10/24/00. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Type = Amount 125.00 23.98\n-  Data Models\n- Relational Database Model\n-  Basic Concepts and Terminology\n-  Keys and Foreign Keys\n- Schema Specifications"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0015"}, "gap_lectures": 0}}}
{"A": {"name": "SERIALIZABILITY", "role": "Definition"}, "B": {"name": "SERIAL_SCHEDULE", "role": "NA"}, "relation": "depends_on", "justification": "The evidence shows that a schedule is serializable if it is equivalent to a serial schedule, indicating that understanding serial schedules is a prerequisite for understanding serializability.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0005", "lecture_id": "20-Trxn-Serializability", "text": "A schedule is serializable if it is equivalent to a serial schedule.\nFinal state must be the same as the state produced by one of the serial schedules.\nT1\nT2\nREAD(A, t)\nt := t+100\nWRITE(A, t)\nREAD(A, s)\ns := s*2\nWRITE(A,s)\nREAD(B, t)\nt := t+100\nWRITE(B,t)\nREAD(B,s)\ns := s*2\nWRITE(B,s)"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0005"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0006"}, "gap_lectures": -2}}}
{"A": {"name": "SERIALIZABILITY", "role": "NA"}, "B": {"name": "TRANSACTION_MANAGEMENT", "role": "NA"}, "relation": "depends_on", "justification": "The evidence shows that serializability is discussed in the context of transaction management, indicating that understanding transaction management is a prerequisite for understanding serializability.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0017", "lecture_id": "20-Trxn-Serializability", "text": "If all transactions are well-formed and two-phase, then any schedule in which conflicting locks are never granted ensures serializability"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0001"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0006"}, "gap_lectures": 0}}}
{"A": {"name": "SERIAL_SCHEDULE", "role": "NA"}, "B": {"name": "WRITE_OPERATION", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly establish a 'depends_on' or 'part_of' relationship between SERIAL_SCHEDULE and WRITE_OPERATION.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "20-Trxn-Serializability__0014", "lecture_id": "20-Trxn-Serializability", "text": "Two schedules S1 and S2 are view equivalent if:\n- If ௜ reads an initial value of A in S1, then ௜ reads the initial value of A in S2\n- If ௜ reads a value of A written by ௝ in S1, then ௜ reads a value of A written by ௝ in S2\n- If ௜ writes the final value of A in S1, then ௜ writes the final value of A in S2\nA schedule is view serializable if it is view-equivalent to a serial schedule"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 1, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0004"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0005"}, "gap_lectures": 0}}}
{"A": {"name": "STORED_PROCEDURE", "role": "Example"}, "B": {"name": "STUDENT_DATA", "role": "NA"}, "relation": "depends_on", "justification": "The evidence shows that the stored procedure operates on student data to return specific information such as FirstName, LastName, and Average GPA, indicating that understanding student data is a prerequisite for writing the stored procedure.", "evidence_chunks": [{"source": "chunk_co_occurrence", "chunk_id": "6- SQL5-DBUpdatesSPs__0017", "lecture_id": "6- SQL5-DBUpdatesSPs", "text": "Write a Stored Procedure that returns the FirstName, LastName, and Average GPA for each student\n```\nDELIMITER // CREATE PROCEDURE GetAverageScore () BEGIN SELECT s.FirstName, s.LastName, AVG (Score) AS avgScore FROM Enrollments e JOIN Students s ON (e.NetId = s.NetId) GROUP BY s.NetId ; END // DELIMITER ;\n```\nCalling the procedure:\nI ILLINOIS\nCALL GetAverageScore();\nA. Alawini\n18"}], "_meta": {"mode": "CHUNK_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 1, "cluster_co_occurrence_count": 0, "reason": "A and B co-occur in 1 chunk(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0008"}, "A_first_introduced_at": {"lecture_index": 18, "lecture_id": "6- SQL5-DBUpdatesSPs", "chunk_id": "6- SQL5-DBUpdatesSPs__0017"}, "gap_lectures": 6}}}
{"A": {"name": "ACCOUNT_NUMBER", "role": "NA"}, "B": {"name": "CARDINALITY", "role": "NA"}, "relation": null, "justification": "No decision (LLM output invalid).", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0013", "lecture_id": "1-RelationalModel", "text": ", Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. , Number = 102. , Owner = W. Wei. , Balance = 2000.00. , Type = checking. , Number = 103. , Owner = J. Smith. , Balance = 5000.00. , Type = savings. , Number = 104. , Owner = M. Jones. , Balance = 1000.00. , Type = checking. , Number = 105. , Owner = H. Martin. , Balance = 10,000.00. , Type = checking. Deposit, Number = AcctNo. Deposit, Owner = Transaction-id. Deposit, Balance = Date. Deposit, Type = Amount. , Number = 102. , Owner = 1. , Balance = 10/22/00. , Type = 500.00. , Number = 102. , Owner = 2. , Balance = 10/29/00. , Type = 200.00. , Number = 104. , Owner = 3. , Balance = 10/29/00. , Type = 1000.00. , Number = 105. , Owner = 4. , Balance = 11/02/00. , Type = 10,000.00. Check, Number = AcctNo. Check, Owner = Check-number. Check, Balance = Date. Check, Type = Amount. , Number = 101. , Owner = 924. , Balance = 10/23/00. , Type = 125.00. , Number = 101. , Owner = 925. , Balance = 10/24/00. , Type = 23.98"}, {"source": "cluster_A", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0017", "lecture_id": "1-RelationalModel", "text": "Account, 1 = Number. Account, 2 = Owner. Account, 3 = Balance. Account, 4 = Type. , 1 = 101. , 2 = J. Smith. , 3 = 1000.00. , 4 = checking. , 1 = 102. , 2 = W. Wei. , 3 = 2000.00. , 4 = checking\n...\nFor every column of every table, the schema specifies allowable values.  For example,\nNumber must be a 3-digit number\nOwner must be a 30-character string\nType must be 'checking' or 'savings'\nThe set of allowable values for a column is called the domain of the column."}, {"source": "cluster_A", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "2-SQL-Basics__0005", "lecture_id": "2-SQL-Basics", "text": "Account, 1 = Number. Account, 2 = Owner. Account, 3 = Balance. Account, 4 = T\\pe. , 1 = 101. , 2 = J. Smith. , 3 = 1000.00. , 4 = checking. , 1 = 102. , 2 = W. Wei. , 3 = 2000.00. , 4 = checking. , 1 = 103. , 2 = J. Smith. , 3 = 5000.00. , 4 = savings. , 1 = 104. , 2 = M. Jones. , 3 = 1000.00. , 4 = checking. , 1 = 105. , 2 = H. Martin. , 3 = 10,000.00. , 4 = checking\nSELECT, 1 = Number, Owner. FROM, 1 = Account. WHERE, 1 = T\\pe = \" savings \" ;\nNumber, 1 = Owner\n103\nJ. Smith"}, {"source": "cluster_B", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0012", "lecture_id": "1-RelationalModel", "text": "The intension of the table\n101, Owner = J. Smith. 101, Balance = 1000.00. 101, Type = checking. 102, Owner = W. Wei. 102, Balance = 2000.00. 102, Type = checking. 103, Owner = J. Smith. 103, Balance = 5000.00. 103, Type = savings. 104, Owner = M. Jones. 104, Balance = 1000.00. 104, Type = checking. 105, Owner = H. Martin. 105, Balance = 10,000.00. 105, Type = checking\nThe extension of the table.  Also called the extent .\n, Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. Cardinality, Number = 102. Cardinality, Owner = W. Wei. Cardinality, Balance = 2000.00. Cardinality, Type = checking. of this instance is 5 (because, Number = 103. of this instance is 5 (because, Owner = J. Smith. of this instance is 5 (because, Balance = 5000.00. of this instance is 5 (because, Type = savings. there are 5, Number = 104. there are 5, Owner = M. Jones. there are 5, Balance = 1000.00. there are 5, Type = checking. rows), Number = 105. rows), Owner = H. Martin. rows), Balance = 10,000.00. rows), Type = checking\n-  Data Models\n- Relational Database Model\n-  Basic Concepts and Terminology\n- Keys and Foreign Keys\n- Schema Specifications"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0012"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0013"}, "gap_lectures": 0}, "_error": "Unbalanced JSON braces in output."}}
{"A": {"name": "ACCOUNT_NUMBER", "role": "NA"}, "B": {"name": "FOREIGN_KEYS", "role": "NA"}, "relation": null, "justification": "There is no clear evidence that ACCOUNT_NUMBER depends on or is part of FOREIGN_KEYS. The provided evidence does not establish a direct prerequisite or component relationship between the two concepts.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0013", "lecture_id": "1-RelationalModel", "text": ", Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. , Number = 102. , Owner = W. Wei. , Balance = 2000.00. , Type = checking. , Number = 103. , Owner = J. Smith. , Balance = 5000.00. , Type = savings. , Number = 104. , Owner = M. Jones. , Balance = 1000.00. , Type = checking. , Number = 105. , Owner = H. Martin. , Balance = 10,000.00. , Type = checking. Deposit, Number = AcctNo. Deposit, Owner = Transaction-id. Deposit, Balance = Date. Deposit, Type = Amount. , Number = 102. , Owner = 1. , Balance = 10/22/00. , Type = 500.00. , Number = 102. , Owner = 2. , Balance = 10/29/00. , Type = 200.00. , Number = 104. , Owner = 3. , Balance = 10/29/00. , Type = 1000.00. , Number = 105. , Owner = 4. , Balance = 11/02/00. , Type = 10,000.00. Check, Number = AcctNo. Check, Owner = Check-number. Check, Balance = Date. Check, Type = Amount. , Number = 101. , Owner = 924. , Balance = 10/23/00. , Type = 125.00. , Number = 101. , Owner = 925. , Balance = 10/24/00. , Type = 23.98"}, {"source": "cluster_A", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0017", "lecture_id": "1-RelationalModel", "text": "Account, 1 = Number. Account, 2 = Owner. Account, 3 = Balance. Account, 4 = Type. , 1 = 101. , 2 = J. Smith. , 3 = 1000.00. , 4 = checking. , 1 = 102. , 2 = W. Wei. , 3 = 2000.00. , 4 = checking\n...\nFor every column of every table, the schema specifies allowable values.  For example,\nNumber must be a 3-digit number\nOwner must be a 30-character string\nType must be 'checking' or 'savings'\nThe set of allowable values for a column is called the domain of the column."}, {"source": "cluster_A", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "2-SQL-Basics__0005", "lecture_id": "2-SQL-Basics", "text": "Account, 1 = Number. Account, 2 = Owner. Account, 3 = Balance. Account, 4 = T\\pe. , 1 = 101. , 2 = J. Smith. , 3 = 1000.00. , 4 = checking. , 1 = 102. , 2 = W. Wei. , 3 = 2000.00. , 4 = checking. , 1 = 103. , 2 = J. Smith. , 3 = 5000.00. , 4 = savings. , 1 = 104. , 2 = M. Jones. , 3 = 1000.00. , 4 = checking. , 1 = 105. , 2 = H. Martin. , 3 = 10,000.00. , 4 = checking\nSELECT, 1 = Number, Owner. FROM, 1 = Account. WHERE, 1 = T\\pe = \" savings \" ;\nNumber, 1 = Owner\n103\nJ. Smith"}, {"source": "cluster_B", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0012", "lecture_id": "1-RelationalModel", "text": "The intension of the table\n101, Owner = J. Smith. 101, Balance = 1000.00. 101, Type = checking. 102, Owner = W. Wei. 102, Balance = 2000.00. 102, Type = checking. 103, Owner = J. Smith. 103, Balance = 5000.00. 103, Type = savings. 104, Owner = M. Jones. 104, Balance = 1000.00. 104, Type = checking. 105, Owner = H. Martin. 105, Balance = 10,000.00. 105, Type = checking\nThe extension of the table.  Also called the extent .\n, Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. Cardinality, Number = 102. Cardinality, Owner = W. Wei. Cardinality, Balance = 2000.00. Cardinality, Type = checking. of this instance is 5 (because, Number = 103. of this instance is 5 (because, Owner = J. Smith. of this instance is 5 (because, Balance = 5000.00. of this instance is 5 (because, Type = savings. there are 5, Number = 104. there are 5, Owner = M. Jones. there are 5, Balance = 1000.00. there are 5, Type = checking. rows), Number = 105. rows), Owner = H. Martin. rows), Balance = 10,000.00. rows), Type = checking\n-  Data Models\n- Relational Database Model\n-  Basic Concepts and Terminology\n- Keys and Foreign Keys\n- Schema Specifications"}, {"source": "cluster_B", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0015", "lecture_id": "1-RelationalModel", "text": ", Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. , Number = 102. , Owner = W. Wei. , Balance = 2000.00. , Type = checking. , Number = 103. , Owner = J. Smith. , Balance = 5000.00. , Type = savings. , Number = 104. , Owner = M. Jones. , Balance = 1000.00. , Type = checking. , Number = 105. , Owner = H. Martin. , Balance = 10,000.00. , Type = checking. Deposit, Number = AcctNo Transaction-id. Deposit, Owner = Date. Deposit, Balance = Amount. Deposit, Type = . , Number = 102 1. , Owner = 10/22/00. , Balance = 500.00. , Type = . , Number = 102 2. , Owner = 10/29/00. , Balance = 200.00. , Type = . , Number = 104 3. , Owner = 10/29/00. , Balance = 1000.00. , Type = . , Number = 105 4. , Owner = 11/02/00. , Balance = 10,000.00. , Type = . , Number = 106 5. , Owner = 12/05/00. , Balance = 555.00. , Type = \nWe say that Deposit.AcctNo is a foreign key that references Account.Number.  If the DBMS enforces this constraint, we have referential integrity .\n, Foreign keys might or might not be part of the key for the referring table.Number = 101 102 103 104 105. , Foreign keys might or might not be part of the key for the referring table.Owner = J. Smith W. Wei J. Smith M. Jones H. Martin. , Foreign keys might or might not be part of the key for the referring table.Balance = 1000.00 2000.00 5000.00 1000.00 10,000.00. , Foreign keys might or might not be part of the key for the referring table.Type = checking checking savings checking checking. Deposit, Foreign keys might or might not be part of the key for the referring table.Number = AcctNo. Deposit, Foreign keys might or might not be part of the key for the referring table.Owner = Transaction-id. Deposit, Foreign keys might or might not be part of the key for the referring table.Balance = Date. Deposit, Foreign keys might or might not be part of the key for the referring table.Type = Amount. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Number = AcctNo 101 101. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Owner = Check-number 924 925. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Balance = Date 10/23/00 10/24/00. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Type = Amount 125.00 23.98\n-  Data Models\n- Relational Database Model\n-  Basic Concepts and Terminology\n-  Keys and Foreign Keys\n- Schema Specifications"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0013"}, "gap_lectures": 0}}}
{"A": {"name": "ACCOUNT_NUMBER", "role": "NA"}, "B": {"name": "KEYS", "role": "NA"}, "relation": null, "justification": "There is no clear evidence that ACCOUNT_NUMBER depends_on or is part_of KEYS based on the provided text.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0013", "lecture_id": "1-RelationalModel", "text": ", Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. , Number = 102. , Owner = W. Wei. , Balance = 2000.00. , Type = checking. , Number = 103. , Owner = J. Smith. , Balance = 5000.00. , Type = savings. , Number = 104. , Owner = M. Jones. , Balance = 1000.00. , Type = checking. , Number = 105. , Owner = H. Martin. , Balance = 10,000.00. , Type = checking. Deposit, Number = AcctNo. Deposit, Owner = Transaction-id. Deposit, Balance = Date. Deposit, Type = Amount. , Number = 102. , Owner = 1. , Balance = 10/22/00. , Type = 500.00. , Number = 102. , Owner = 2. , Balance = 10/29/00. , Type = 200.00. , Number = 104. , Owner = 3. , Balance = 10/29/00. , Type = 1000.00. , Number = 105. , Owner = 4. , Balance = 11/02/00. , Type = 10,000.00. Check, Number = AcctNo. Check, Owner = Check-number. Check, Balance = Date. Check, Type = Amount. , Number = 101. , Owner = 924. , Balance = 10/23/00. , Type = 125.00. , Number = 101. , Owner = 925. , Balance = 10/24/00. , Type = 23.98"}, {"source": "cluster_A", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0017", "lecture_id": "1-RelationalModel", "text": "Account, 1 = Number. Account, 2 = Owner. Account, 3 = Balance. Account, 4 = Type. , 1 = 101. , 2 = J. Smith. , 3 = 1000.00. , 4 = checking. , 1 = 102. , 2 = W. Wei. , 3 = 2000.00. , 4 = checking\n...\nFor every column of every table, the schema specifies allowable values.  For example,\nNumber must be a 3-digit number\nOwner must be a 30-character string\nType must be 'checking' or 'savings'\nThe set of allowable values for a column is called the domain of the column."}, {"source": "cluster_A", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "2-SQL-Basics__0005", "lecture_id": "2-SQL-Basics", "text": "Account, 1 = Number. Account, 2 = Owner. Account, 3 = Balance. Account, 4 = T\\pe. , 1 = 101. , 2 = J. Smith. , 3 = 1000.00. , 4 = checking. , 1 = 102. , 2 = W. Wei. , 3 = 2000.00. , 4 = checking. , 1 = 103. , 2 = J. Smith. , 3 = 5000.00. , 4 = savings. , 1 = 104. , 2 = M. Jones. , 3 = 1000.00. , 4 = checking. , 1 = 105. , 2 = H. Martin. , 3 = 10,000.00. , 4 = checking\nSELECT, 1 = Number, Owner. FROM, 1 = Account. WHERE, 1 = T\\pe = \" savings \" ;\nNumber, 1 = Owner\n103\nJ. Smith"}, {"source": "cluster_B", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0012", "lecture_id": "1-RelationalModel", "text": "The intension of the table\n101, Owner = J. Smith. 101, Balance = 1000.00. 101, Type = checking. 102, Owner = W. Wei. 102, Balance = 2000.00. 102, Type = checking. 103, Owner = J. Smith. 103, Balance = 5000.00. 103, Type = savings. 104, Owner = M. Jones. 104, Balance = 1000.00. 104, Type = checking. 105, Owner = H. Martin. 105, Balance = 10,000.00. 105, Type = checking\nThe extension of the table.  Also called the extent .\n, Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. Cardinality, Number = 102. Cardinality, Owner = W. Wei. Cardinality, Balance = 2000.00. Cardinality, Type = checking. of this instance is 5 (because, Number = 103. of this instance is 5 (because, Owner = J. Smith. of this instance is 5 (because, Balance = 5000.00. of this instance is 5 (because, Type = savings. there are 5, Number = 104. there are 5, Owner = M. Jones. there are 5, Balance = 1000.00. there are 5, Type = checking. rows), Number = 105. rows), Owner = H. Martin. rows), Balance = 10,000.00. rows), Type = checking\n-  Data Models\n- Relational Database Model\n-  Basic Concepts and Terminology\n- Keys and Foreign Keys\n- Schema Specifications"}, {"source": "cluster_B", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0015", "lecture_id": "1-RelationalModel", "text": ", Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. , Number = 102. , Owner = W. Wei. , Balance = 2000.00. , Type = checking. , Number = 103. , Owner = J. Smith. , Balance = 5000.00. , Type = savings. , Number = 104. , Owner = M. Jones. , Balance = 1000.00. , Type = checking. , Number = 105. , Owner = H. Martin. , Balance = 10,000.00. , Type = checking. Deposit, Number = AcctNo Transaction-id. Deposit, Owner = Date. Deposit, Balance = Amount. Deposit, Type = . , Number = 102 1. , Owner = 10/22/00. , Balance = 500.00. , Type = . , Number = 102 2. , Owner = 10/29/00. , Balance = 200.00. , Type = . , Number = 104 3. , Owner = 10/29/00. , Balance = 1000.00. , Type = . , Number = 105 4. , Owner = 11/02/00. , Balance = 10,000.00. , Type = . , Number = 106 5. , Owner = 12/05/00. , Balance = 555.00. , Type = \nWe say that Deposit.AcctNo is a foreign key that references Account.Number.  If the DBMS enforces this constraint, we have referential integrity .\n, Foreign keys might or might not be part of the key for the referring table.Number = 101 102 103 104 105. , Foreign keys might or might not be part of the key for the referring table.Owner = J. Smith W. Wei J. Smith M. Jones H. Martin. , Foreign keys might or might not be part of the key for the referring table.Balance = 1000.00 2000.00 5000.00 1000.00 10,000.00. , Foreign keys might or might not be part of the key for the referring table.Type = checking checking savings checking checking. Deposit, Foreign keys might or might not be part of the key for the referring table.Number = AcctNo. Deposit, Foreign keys might or might not be part of the key for the referring table.Owner = Transaction-id. Deposit, Foreign keys might or might not be part of the key for the referring table.Balance = Date. Deposit, Foreign keys might or might not be part of the key for the referring table.Type = Amount. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Number = AcctNo 101 101. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Owner = Check-number 924 925. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Balance = Date 10/23/00 10/24/00. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Type = Amount 125.00 23.98\n-  Data Models\n- Relational Database Model\n-  Basic Concepts and Terminology\n-  Keys and Foreign Keys\n- Schema Specifications"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0013"}, "gap_lectures": 0}}}
{"A": {"name": "ACCOUNT_NUMBER", "role": "NA"}, "B": {"name": "REFERENTIAL_INTEGRITY", "role": "NA"}, "relation": null, "justification": "No decision (LLM output invalid).", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0013", "lecture_id": "1-RelationalModel", "text": ", Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. , Number = 102. , Owner = W. Wei. , Balance = 2000.00. , Type = checking. , Number = 103. , Owner = J. Smith. , Balance = 5000.00. , Type = savings. , Number = 104. , Owner = M. Jones. , Balance = 1000.00. , Type = checking. , Number = 105. , Owner = H. Martin. , Balance = 10,000.00. , Type = checking. Deposit, Number = AcctNo. Deposit, Owner = Transaction-id. Deposit, Balance = Date. Deposit, Type = Amount. , Number = 102. , Owner = 1. , Balance = 10/22/00. , Type = 500.00. , Number = 102. , Owner = 2. , Balance = 10/29/00. , Type = 200.00. , Number = 104. , Owner = 3. , Balance = 10/29/00. , Type = 1000.00. , Number = 105. , Owner = 4. , Balance = 11/02/00. , Type = 10,000.00. Check, Number = AcctNo. Check, Owner = Check-number. Check, Balance = Date. Check, Type = Amount. , Number = 101. , Owner = 924. , Balance = 10/23/00. , Type = 125.00. , Number = 101. , Owner = 925. , Balance = 10/24/00. , Type = 23.98"}, {"source": "cluster_A", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0017", "lecture_id": "1-RelationalModel", "text": "Account, 1 = Number. Account, 2 = Owner. Account, 3 = Balance. Account, 4 = Type. , 1 = 101. , 2 = J. Smith. , 3 = 1000.00. , 4 = checking. , 1 = 102. , 2 = W. Wei. , 3 = 2000.00. , 4 = checking\n...\nFor every column of every table, the schema specifies allowable values.  For example,\nNumber must be a 3-digit number\nOwner must be a 30-character string\nType must be 'checking' or 'savings'\nThe set of allowable values for a column is called the domain of the column."}, {"source": "cluster_A", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "2-SQL-Basics__0005", "lecture_id": "2-SQL-Basics", "text": "Account, 1 = Number. Account, 2 = Owner. Account, 3 = Balance. Account, 4 = T\\pe. , 1 = 101. , 2 = J. Smith. , 3 = 1000.00. , 4 = checking. , 1 = 102. , 2 = W. Wei. , 3 = 2000.00. , 4 = checking. , 1 = 103. , 2 = J. Smith. , 3 = 5000.00. , 4 = savings. , 1 = 104. , 2 = M. Jones. , 3 = 1000.00. , 4 = checking. , 1 = 105. , 2 = H. Martin. , 3 = 10,000.00. , 4 = checking\nSELECT, 1 = Number, Owner. FROM, 1 = Account. WHERE, 1 = T\\pe = \" savings \" ;\nNumber, 1 = Owner\n103\nJ. Smith"}, {"source": "cluster_B", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0015", "lecture_id": "1-RelationalModel", "text": ", Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. , Number = 102. , Owner = W. Wei. , Balance = 2000.00. , Type = checking. , Number = 103. , Owner = J. Smith. , Balance = 5000.00. , Type = savings. , Number = 104. , Owner = M. Jones. , Balance = 1000.00. , Type = checking. , Number = 105. , Owner = H. Martin. , Balance = 10,000.00. , Type = checking. Deposit, Number = AcctNo Transaction-id. Deposit, Owner = Date. Deposit, Balance = Amount. Deposit, Type = . , Number = 102 1. , Owner = 10/22/00. , Balance = 500.00. , Type = . , Number = 102 2. , Owner = 10/29/00. , Balance = 200.00. , Type = . , Number = 104 3. , Owner = 10/29/00. , Balance = 1000.00. , Type = . , Number = 105 4. , Owner = 11/02/00. , Balance = 10,000.00. , Type = . , Number = 106 5. , Owner = 12/05/00. , Balance = 555.00. , Type = \nWe say that Deposit.AcctNo is a foreign key that references Account.Number.  If the DBMS enforces this constraint, we have referential integrity .\n, Foreign keys might or might not be part of the key for the referring table.Number = 101 102 103 104 105. , Foreign keys might or might not be part of the key for the referring table.Owner = J. Smith W. Wei J. Smith M. Jones H. Martin. , Foreign keys might or might not be part of the key for the referring table.Balance = 1000.00 2000.00 5000.00 1000.00 10,000.00. , Foreign keys might or might not be part of the key for the referring table.Type = checking checking savings checking checking. Deposit, Foreign keys might or might not be part of the key for the referring table.Number = AcctNo. Deposit, Foreign keys might or might not be part of the key for the referring table.Owner = Transaction-id. Deposit, Foreign keys might or might not be part of the key for the referring table.Balance = Date. Deposit, Foreign keys might or might not be part of the key for the referring table.Type = Amount. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Number = AcctNo 101 101. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Owner = Check-number 924 925. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Balance = Date 10/23/00 10/24/00. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Type = Amount 125.00 23.98\n-  Data Models\n- Relational Database Model\n-  Basic Concepts and Terminology\n-  Keys and Foreign Keys\n- Schema Specifications"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0015"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0013"}, "gap_lectures": 0}, "_error": "Unbalanced JSON braces in output."}}
{"A": {"name": "ACCOUNT_NUMBER", "role": "NA"}, "B": {"name": "SCHEMA_SPECIFICATIONS", "role": "NA"}, "relation": "depends_on", "justification": "The schema specifications define the allowable values for the account number, indicating that understanding schema specifications is a prerequisite for understanding account numbers.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0013", "lecture_id": "1-RelationalModel", "text": ", Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. , Number = 102. , Owner = W. Wei. , Balance = 2000.00. , Type = checking. , Number = 103. , Owner = J. Smith. , Balance = 5000.00. , Type = savings. , Number = 104. , Owner = M. Jones. , Balance = 1000.00. , Type = checking. , Number = 105. , Owner = H. Martin. , Balance = 10,000.00. , Type = checking. Deposit, Number = AcctNo. Deposit, Owner = Transaction-id. Deposit, Balance = Date. Deposit, Type = Amount. , Number = 102. , Owner = 1. , Balance = 10/22/00. , Type = 500.00. , Number = 102. , Owner = 2. , Balance = 10/29/00. , Type = 200.00. , Number = 104. , Owner = 3. , Balance = 10/29/00. , Type = 1000.00. , Number = 105. , Owner = 4. , Balance = 11/02/00. , Type = 10,000.00. Check, Number = AcctNo. Check, Owner = Check-number. Check, Balance = Date. Check, Type = Amount. , Number = 101. , Owner = 924. , Balance = 10/23/00. , Type = 125.00. , Number = 101. , Owner = 925. , Balance = 10/24/00. , Type = 23.98"}, {"source": "cluster_A", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0017", "lecture_id": "1-RelationalModel", "text": "Account, 1 = Number. Account, 2 = Owner. Account, 3 = Balance. Account, 4 = Type. , 1 = 101. , 2 = J. Smith. , 3 = 1000.00. , 4 = checking. , 1 = 102. , 2 = W. Wei. , 3 = 2000.00. , 4 = checking\n...\nFor every column of every table, the schema specifies allowable values.  For example,\nNumber must be a 3-digit number\nOwner must be a 30-character string\nType must be 'checking' or 'savings'\nThe set of allowable values for a column is called the domain of the column."}, {"source": "cluster_A", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "2-SQL-Basics__0005", "lecture_id": "2-SQL-Basics", "text": "Account, 1 = Number. Account, 2 = Owner. Account, 3 = Balance. Account, 4 = T\\pe. , 1 = 101. , 2 = J. Smith. , 3 = 1000.00. , 4 = checking. , 1 = 102. , 2 = W. Wei. , 3 = 2000.00. , 4 = checking. , 1 = 103. , 2 = J. Smith. , 3 = 5000.00. , 4 = savings. , 1 = 104. , 2 = M. Jones. , 3 = 1000.00. , 4 = checking. , 1 = 105. , 2 = H. Martin. , 3 = 10,000.00. , 4 = checking\nSELECT, 1 = Number, Owner. FROM, 1 = Account. WHERE, 1 = T\\pe = \" savings \" ;\nNumber, 1 = Owner\n103\nJ. Smith"}, {"source": "cluster_B", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0012", "lecture_id": "1-RelationalModel", "text": "The intension of the table\n101, Owner = J. Smith. 101, Balance = 1000.00. 101, Type = checking. 102, Owner = W. Wei. 102, Balance = 2000.00. 102, Type = checking. 103, Owner = J. Smith. 103, Balance = 5000.00. 103, Type = savings. 104, Owner = M. Jones. 104, Balance = 1000.00. 104, Type = checking. 105, Owner = H. Martin. 105, Balance = 10,000.00. 105, Type = checking\nThe extension of the table.  Also called the extent .\n, Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. Cardinality, Number = 102. Cardinality, Owner = W. Wei. Cardinality, Balance = 2000.00. Cardinality, Type = checking. of this instance is 5 (because, Number = 103. of this instance is 5 (because, Owner = J. Smith. of this instance is 5 (because, Balance = 5000.00. of this instance is 5 (because, Type = savings. there are 5, Number = 104. there are 5, Owner = M. Jones. there are 5, Balance = 1000.00. there are 5, Type = checking. rows), Number = 105. rows), Owner = H. Martin. rows), Balance = 10,000.00. rows), Type = checking\n-  Data Models\n- Relational Database Model\n-  Basic Concepts and Terminology\n- Keys and Foreign Keys\n- Schema Specifications"}, {"source": "cluster_B", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0015", "lecture_id": "1-RelationalModel", "text": ", Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. , Number = 102. , Owner = W. Wei. , Balance = 2000.00. , Type = checking. , Number = 103. , Owner = J. Smith. , Balance = 5000.00. , Type = savings. , Number = 104. , Owner = M. Jones. , Balance = 1000.00. , Type = checking. , Number = 105. , Owner = H. Martin. , Balance = 10,000.00. , Type = checking. Deposit, Number = AcctNo Transaction-id. Deposit, Owner = Date. Deposit, Balance = Amount. Deposit, Type = . , Number = 102 1. , Owner = 10/22/00. , Balance = 500.00. , Type = . , Number = 102 2. , Owner = 10/29/00. , Balance = 200.00. , Type = . , Number = 104 3. , Owner = 10/29/00. , Balance = 1000.00. , Type = . , Number = 105 4. , Owner = 11/02/00. , Balance = 10,000.00. , Type = . , Number = 106 5. , Owner = 12/05/00. , Balance = 555.00. , Type = \nWe say that Deposit.AcctNo is a foreign key that references Account.Number.  If the DBMS enforces this constraint, we have referential integrity .\n, Foreign keys might or might not be part of the key for the referring table.Number = 101 102 103 104 105. , Foreign keys might or might not be part of the key for the referring table.Owner = J. Smith W. Wei J. Smith M. Jones H. Martin. , Foreign keys might or might not be part of the key for the referring table.Balance = 1000.00 2000.00 5000.00 1000.00 10,000.00. , Foreign keys might or might not be part of the key for the referring table.Type = checking checking savings checking checking. Deposit, Foreign keys might or might not be part of the key for the referring table.Number = AcctNo. Deposit, Foreign keys might or might not be part of the key for the referring table.Owner = Transaction-id. Deposit, Foreign keys might or might not be part of the key for the referring table.Balance = Date. Deposit, Foreign keys might or might not be part of the key for the referring table.Type = Amount. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Number = AcctNo 101 101. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Owner = Check-number 924 925. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Balance = Date 10/23/00 10/24/00. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Type = Amount 125.00 23.98\n-  Data Models\n- Relational Database Model\n-  Basic Concepts and Terminology\n-  Keys and Foreign Keys\n- Schema Specifications"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0013"}, "gap_lectures": 0}}}
{"A": {"name": "ACCOUNT_TYPE", "role": "NA"}, "B": {"name": "CARDINALITY", "role": "NA"}, "relation": null, "justification": "There is no clear connection or dependency between ACCOUNT_TYPE and CARDINALITY based on the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0009", "lecture_id": "1-RelationalModel", "text": "Account\n101 102 103 104 105, Owner = J. Smith W. Wei J. Smith M. Jones H. Martin. 101 102 103 104 105, Balance = 1000.00 2000.00 5000.00 1000.00 10,000.00. 101 102 103 104 105, Type = checking checking savings checking checking\nImagine that this table (or relation) has been defined to help keep track of bank accounts."}, {"source": "cluster_A", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0010", "lecture_id": "1-RelationalModel", "text": "The name of the table\nThe name of the columns ( attributes )\nAccount\n101, Owner = J. Smith. 101, Balance = 1000.00. 101, Type = checking. 102, Owner = W. Wei. 102, Balance = 2000.00. 102, Type = checking. 103, Owner = J. Smith. 103, Balance = 5000.00. 103, Type = savings. 104, Owner = M. Jones. 104, Balance = 1000.00. 104, Type = checking. 105, Owner = H. Martin. 105, Balance = 10,000.00. 105, Type = checking"}, {"source": "cluster_A", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0013", "lecture_id": "1-RelationalModel", "text": ", Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. , Number = 102. , Owner = W. Wei. , Balance = 2000.00. , Type = checking. , Number = 103. , Owner = J. Smith. , Balance = 5000.00. , Type = savings. , Number = 104. , Owner = M. Jones. , Balance = 1000.00. , Type = checking. , Number = 105. , Owner = H. Martin. , Balance = 10,000.00. , Type = checking. Deposit, Number = AcctNo. Deposit, Owner = Transaction-id. Deposit, Balance = Date. Deposit, Type = Amount. , Number = 102. , Owner = 1. , Balance = 10/22/00. , Type = 500.00. , Number = 102. , Owner = 2. , Balance = 10/29/00. , Type = 200.00. , Number = 104. , Owner = 3. , Balance = 10/29/00. , Type = 1000.00. , Number = 105. , Owner = 4. , Balance = 11/02/00. , Type = 10,000.00. Check, Number = AcctNo. Check, Owner = Check-number. Check, Balance = Date. Check, Type = Amount. , Number = 101. , Owner = 924. , Balance = 10/23/00. , Type = 125.00. , Number = 101. , Owner = 925. , Balance = 10/24/00. , Type = 23.98"}, {"source": "cluster_B", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0012", "lecture_id": "1-RelationalModel", "text": "The intension of the table\n101, Owner = J. Smith. 101, Balance = 1000.00. 101, Type = checking. 102, Owner = W. Wei. 102, Balance = 2000.00. 102, Type = checking. 103, Owner = J. Smith. 103, Balance = 5000.00. 103, Type = savings. 104, Owner = M. Jones. 104, Balance = 1000.00. 104, Type = checking. 105, Owner = H. Martin. 105, Balance = 10,000.00. 105, Type = checking\nThe extension of the table.  Also called the extent .\n, Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. Cardinality, Number = 102. Cardinality, Owner = W. Wei. Cardinality, Balance = 2000.00. Cardinality, Type = checking. of this instance is 5 (because, Number = 103. of this instance is 5 (because, Owner = J. Smith. of this instance is 5 (because, Balance = 5000.00. of this instance is 5 (because, Type = savings. there are 5, Number = 104. there are 5, Owner = M. Jones. there are 5, Balance = 1000.00. there are 5, Type = checking. rows), Number = 105. rows), Owner = H. Martin. rows), Balance = 10,000.00. rows), Type = checking\n-  Data Models\n- Relational Database Model\n-  Basic Concepts and Terminology\n- Keys and Foreign Keys\n- Schema Specifications"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0012"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0009"}, "gap_lectures": 0}}}
{"A": {"name": "ACCOUNT_TYPE", "role": "NA"}, "B": {"name": "FOREIGN_KEYS", "role": "NA"}, "relation": null, "justification": "There is no clear connection or dependency between ACCOUNT_TYPE and FOREIGN_KEYS based on the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0009", "lecture_id": "1-RelationalModel", "text": "Account\n101 102 103 104 105, Owner = J. Smith W. Wei J. Smith M. Jones H. Martin. 101 102 103 104 105, Balance = 1000.00 2000.00 5000.00 1000.00 10,000.00. 101 102 103 104 105, Type = checking checking savings checking checking\nImagine that this table (or relation) has been defined to help keep track of bank accounts."}, {"source": "cluster_A", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0010", "lecture_id": "1-RelationalModel", "text": "The name of the table\nThe name of the columns ( attributes )\nAccount\n101, Owner = J. Smith. 101, Balance = 1000.00. 101, Type = checking. 102, Owner = W. Wei. 102, Balance = 2000.00. 102, Type = checking. 103, Owner = J. Smith. 103, Balance = 5000.00. 103, Type = savings. 104, Owner = M. Jones. 104, Balance = 1000.00. 104, Type = checking. 105, Owner = H. Martin. 105, Balance = 10,000.00. 105, Type = checking"}, {"source": "cluster_A", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0013", "lecture_id": "1-RelationalModel", "text": ", Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. , Number = 102. , Owner = W. Wei. , Balance = 2000.00. , Type = checking. , Number = 103. , Owner = J. Smith. , Balance = 5000.00. , Type = savings. , Number = 104. , Owner = M. Jones. , Balance = 1000.00. , Type = checking. , Number = 105. , Owner = H. Martin. , Balance = 10,000.00. , Type = checking. Deposit, Number = AcctNo. Deposit, Owner = Transaction-id. Deposit, Balance = Date. Deposit, Type = Amount. , Number = 102. , Owner = 1. , Balance = 10/22/00. , Type = 500.00. , Number = 102. , Owner = 2. , Balance = 10/29/00. , Type = 200.00. , Number = 104. , Owner = 3. , Balance = 10/29/00. , Type = 1000.00. , Number = 105. , Owner = 4. , Balance = 11/02/00. , Type = 10,000.00. Check, Number = AcctNo. Check, Owner = Check-number. Check, Balance = Date. Check, Type = Amount. , Number = 101. , Owner = 924. , Balance = 10/23/00. , Type = 125.00. , Number = 101. , Owner = 925. , Balance = 10/24/00. , Type = 23.98"}, {"source": "cluster_B", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0012", "lecture_id": "1-RelationalModel", "text": "The intension of the table\n101, Owner = J. Smith. 101, Balance = 1000.00. 101, Type = checking. 102, Owner = W. Wei. 102, Balance = 2000.00. 102, Type = checking. 103, Owner = J. Smith. 103, Balance = 5000.00. 103, Type = savings. 104, Owner = M. Jones. 104, Balance = 1000.00. 104, Type = checking. 105, Owner = H. Martin. 105, Balance = 10,000.00. 105, Type = checking\nThe extension of the table.  Also called the extent .\n, Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. Cardinality, Number = 102. Cardinality, Owner = W. Wei. Cardinality, Balance = 2000.00. Cardinality, Type = checking. of this instance is 5 (because, Number = 103. of this instance is 5 (because, Owner = J. Smith. of this instance is 5 (because, Balance = 5000.00. of this instance is 5 (because, Type = savings. there are 5, Number = 104. there are 5, Owner = M. Jones. there are 5, Balance = 1000.00. there are 5, Type = checking. rows), Number = 105. rows), Owner = H. Martin. rows), Balance = 10,000.00. rows), Type = checking\n-  Data Models\n- Relational Database Model\n-  Basic Concepts and Terminology\n- Keys and Foreign Keys\n- Schema Specifications"}, {"source": "cluster_B", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0015", "lecture_id": "1-RelationalModel", "text": ", Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. , Number = 102. , Owner = W. Wei. , Balance = 2000.00. , Type = checking. , Number = 103. , Owner = J. Smith. , Balance = 5000.00. , Type = savings. , Number = 104. , Owner = M. Jones. , Balance = 1000.00. , Type = checking. , Number = 105. , Owner = H. Martin. , Balance = 10,000.00. , Type = checking. Deposit, Number = AcctNo Transaction-id. Deposit, Owner = Date. Deposit, Balance = Amount. Deposit, Type = . , Number = 102 1. , Owner = 10/22/00. , Balance = 500.00. , Type = . , Number = 102 2. , Owner = 10/29/00. , Balance = 200.00. , Type = . , Number = 104 3. , Owner = 10/29/00. , Balance = 1000.00. , Type = . , Number = 105 4. , Owner = 11/02/00. , Balance = 10,000.00. , Type = . , Number = 106 5. , Owner = 12/05/00. , Balance = 555.00. , Type = \nWe say that Deposit.AcctNo is a foreign key that references Account.Number.  If the DBMS enforces this constraint, we have referential integrity .\n, Foreign keys might or might not be part of the key for the referring table.Number = 101 102 103 104 105. , Foreign keys might or might not be part of the key for the referring table.Owner = J. Smith W. Wei J. Smith M. Jones H. Martin. , Foreign keys might or might not be part of the key for the referring table.Balance = 1000.00 2000.00 5000.00 1000.00 10,000.00. , Foreign keys might or might not be part of the key for the referring table.Type = checking checking savings checking checking. Deposit, Foreign keys might or might not be part of the key for the referring table.Number = AcctNo. Deposit, Foreign keys might or might not be part of the key for the referring table.Owner = Transaction-id. Deposit, Foreign keys might or might not be part of the key for the referring table.Balance = Date. Deposit, Foreign keys might or might not be part of the key for the referring table.Type = Amount. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Number = AcctNo 101 101. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Owner = Check-number 924 925. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Balance = Date 10/23/00 10/24/00. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Type = Amount 125.00 23.98\n-  Data Models\n- Relational Database Model\n-  Basic Concepts and Terminology\n-  Keys and Foreign Keys\n- Schema Specifications"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0009"}, "gap_lectures": 0}}}
{"A": {"name": "ACCOUNT_TYPE", "role": "NA"}, "B": {"name": "KEYS", "role": "NA"}, "relation": null, "justification": "There is no clear connection between ACCOUNT_TYPE and KEYS based on the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0009", "lecture_id": "1-RelationalModel", "text": "Account\n101 102 103 104 105, Owner = J. Smith W. Wei J. Smith M. Jones H. Martin. 101 102 103 104 105, Balance = 1000.00 2000.00 5000.00 1000.00 10,000.00. 101 102 103 104 105, Type = checking checking savings checking checking\nImagine that this table (or relation) has been defined to help keep track of bank accounts."}, {"source": "cluster_A", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0010", "lecture_id": "1-RelationalModel", "text": "The name of the table\nThe name of the columns ( attributes )\nAccount\n101, Owner = J. Smith. 101, Balance = 1000.00. 101, Type = checking. 102, Owner = W. Wei. 102, Balance = 2000.00. 102, Type = checking. 103, Owner = J. Smith. 103, Balance = 5000.00. 103, Type = savings. 104, Owner = M. Jones. 104, Balance = 1000.00. 104, Type = checking. 105, Owner = H. Martin. 105, Balance = 10,000.00. 105, Type = checking"}, {"source": "cluster_A", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0013", "lecture_id": "1-RelationalModel", "text": ", Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. , Number = 102. , Owner = W. Wei. , Balance = 2000.00. , Type = checking. , Number = 103. , Owner = J. Smith. , Balance = 5000.00. , Type = savings. , Number = 104. , Owner = M. Jones. , Balance = 1000.00. , Type = checking. , Number = 105. , Owner = H. Martin. , Balance = 10,000.00. , Type = checking. Deposit, Number = AcctNo. Deposit, Owner = Transaction-id. Deposit, Balance = Date. Deposit, Type = Amount. , Number = 102. , Owner = 1. , Balance = 10/22/00. , Type = 500.00. , Number = 102. , Owner = 2. , Balance = 10/29/00. , Type = 200.00. , Number = 104. , Owner = 3. , Balance = 10/29/00. , Type = 1000.00. , Number = 105. , Owner = 4. , Balance = 11/02/00. , Type = 10,000.00. Check, Number = AcctNo. Check, Owner = Check-number. Check, Balance = Date. Check, Type = Amount. , Number = 101. , Owner = 924. , Balance = 10/23/00. , Type = 125.00. , Number = 101. , Owner = 925. , Balance = 10/24/00. , Type = 23.98"}, {"source": "cluster_B", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0012", "lecture_id": "1-RelationalModel", "text": "The intension of the table\n101, Owner = J. Smith. 101, Balance = 1000.00. 101, Type = checking. 102, Owner = W. Wei. 102, Balance = 2000.00. 102, Type = checking. 103, Owner = J. Smith. 103, Balance = 5000.00. 103, Type = savings. 104, Owner = M. Jones. 104, Balance = 1000.00. 104, Type = checking. 105, Owner = H. Martin. 105, Balance = 10,000.00. 105, Type = checking\nThe extension of the table.  Also called the extent .\n, Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. Cardinality, Number = 102. Cardinality, Owner = W. Wei. Cardinality, Balance = 2000.00. Cardinality, Type = checking. of this instance is 5 (because, Number = 103. of this instance is 5 (because, Owner = J. Smith. of this instance is 5 (because, Balance = 5000.00. of this instance is 5 (because, Type = savings. there are 5, Number = 104. there are 5, Owner = M. Jones. there are 5, Balance = 1000.00. there are 5, Type = checking. rows), Number = 105. rows), Owner = H. Martin. rows), Balance = 10,000.00. rows), Type = checking\n-  Data Models\n- Relational Database Model\n-  Basic Concepts and Terminology\n- Keys and Foreign Keys\n- Schema Specifications"}, {"source": "cluster_B", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0015", "lecture_id": "1-RelationalModel", "text": ", Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. , Number = 102. , Owner = W. Wei. , Balance = 2000.00. , Type = checking. , Number = 103. , Owner = J. Smith. , Balance = 5000.00. , Type = savings. , Number = 104. , Owner = M. Jones. , Balance = 1000.00. , Type = checking. , Number = 105. , Owner = H. Martin. , Balance = 10,000.00. , Type = checking. Deposit, Number = AcctNo Transaction-id. Deposit, Owner = Date. Deposit, Balance = Amount. Deposit, Type = . , Number = 102 1. , Owner = 10/22/00. , Balance = 500.00. , Type = . , Number = 102 2. , Owner = 10/29/00. , Balance = 200.00. , Type = . , Number = 104 3. , Owner = 10/29/00. , Balance = 1000.00. , Type = . , Number = 105 4. , Owner = 11/02/00. , Balance = 10,000.00. , Type = . , Number = 106 5. , Owner = 12/05/00. , Balance = 555.00. , Type = \nWe say that Deposit.AcctNo is a foreign key that references Account.Number.  If the DBMS enforces this constraint, we have referential integrity .\n, Foreign keys might or might not be part of the key for the referring table.Number = 101 102 103 104 105. , Foreign keys might or might not be part of the key for the referring table.Owner = J. Smith W. Wei J. Smith M. Jones H. Martin. , Foreign keys might or might not be part of the key for the referring table.Balance = 1000.00 2000.00 5000.00 1000.00 10,000.00. , Foreign keys might or might not be part of the key for the referring table.Type = checking checking savings checking checking. Deposit, Foreign keys might or might not be part of the key for the referring table.Number = AcctNo. Deposit, Foreign keys might or might not be part of the key for the referring table.Owner = Transaction-id. Deposit, Foreign keys might or might not be part of the key for the referring table.Balance = Date. Deposit, Foreign keys might or might not be part of the key for the referring table.Type = Amount. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Number = AcctNo 101 101. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Owner = Check-number 924 925. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Balance = Date 10/23/00 10/24/00. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Type = Amount 125.00 23.98\n-  Data Models\n- Relational Database Model\n-  Basic Concepts and Terminology\n-  Keys and Foreign Keys\n- Schema Specifications"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0009"}, "gap_lectures": 0}}}
{"A": {"name": "ACCOUNT_TYPE", "role": "NA"}, "B": {"name": "REFERENTIAL_INTEGRITY", "role": "NA"}, "relation": null, "justification": "There is no clear dependency or part-of relationship between ACCOUNT_TYPE and REFERENTIAL_INTEGRITY based on the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0009", "lecture_id": "1-RelationalModel", "text": "Account\n101 102 103 104 105, Owner = J. Smith W. Wei J. Smith M. Jones H. Martin. 101 102 103 104 105, Balance = 1000.00 2000.00 5000.00 1000.00 10,000.00. 101 102 103 104 105, Type = checking checking savings checking checking\nImagine that this table (or relation) has been defined to help keep track of bank accounts."}, {"source": "cluster_A", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0010", "lecture_id": "1-RelationalModel", "text": "The name of the table\nThe name of the columns ( attributes )\nAccount\n101, Owner = J. Smith. 101, Balance = 1000.00. 101, Type = checking. 102, Owner = W. Wei. 102, Balance = 2000.00. 102, Type = checking. 103, Owner = J. Smith. 103, Balance = 5000.00. 103, Type = savings. 104, Owner = M. Jones. 104, Balance = 1000.00. 104, Type = checking. 105, Owner = H. Martin. 105, Balance = 10,000.00. 105, Type = checking"}, {"source": "cluster_A", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0013", "lecture_id": "1-RelationalModel", "text": ", Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. , Number = 102. , Owner = W. Wei. , Balance = 2000.00. , Type = checking. , Number = 103. , Owner = J. Smith. , Balance = 5000.00. , Type = savings. , Number = 104. , Owner = M. Jones. , Balance = 1000.00. , Type = checking. , Number = 105. , Owner = H. Martin. , Balance = 10,000.00. , Type = checking. Deposit, Number = AcctNo. Deposit, Owner = Transaction-id. Deposit, Balance = Date. Deposit, Type = Amount. , Number = 102. , Owner = 1. , Balance = 10/22/00. , Type = 500.00. , Number = 102. , Owner = 2. , Balance = 10/29/00. , Type = 200.00. , Number = 104. , Owner = 3. , Balance = 10/29/00. , Type = 1000.00. , Number = 105. , Owner = 4. , Balance = 11/02/00. , Type = 10,000.00. Check, Number = AcctNo. Check, Owner = Check-number. Check, Balance = Date. Check, Type = Amount. , Number = 101. , Owner = 924. , Balance = 10/23/00. , Type = 125.00. , Number = 101. , Owner = 925. , Balance = 10/24/00. , Type = 23.98"}, {"source": "cluster_B", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0015", "lecture_id": "1-RelationalModel", "text": ", Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. , Number = 102. , Owner = W. Wei. , Balance = 2000.00. , Type = checking. , Number = 103. , Owner = J. Smith. , Balance = 5000.00. , Type = savings. , Number = 104. , Owner = M. Jones. , Balance = 1000.00. , Type = checking. , Number = 105. , Owner = H. Martin. , Balance = 10,000.00. , Type = checking. Deposit, Number = AcctNo Transaction-id. Deposit, Owner = Date. Deposit, Balance = Amount. Deposit, Type = . , Number = 102 1. , Owner = 10/22/00. , Balance = 500.00. , Type = . , Number = 102 2. , Owner = 10/29/00. , Balance = 200.00. , Type = . , Number = 104 3. , Owner = 10/29/00. , Balance = 1000.00. , Type = . , Number = 105 4. , Owner = 11/02/00. , Balance = 10,000.00. , Type = . , Number = 106 5. , Owner = 12/05/00. , Balance = 555.00. , Type = \nWe say that Deposit.AcctNo is a foreign key that references Account.Number.  If the DBMS enforces this constraint, we have referential integrity .\n, Foreign keys might or might not be part of the key for the referring table.Number = 101 102 103 104 105. , Foreign keys might or might not be part of the key for the referring table.Owner = J. Smith W. Wei J. Smith M. Jones H. Martin. , Foreign keys might or might not be part of the key for the referring table.Balance = 1000.00 2000.00 5000.00 1000.00 10,000.00. , Foreign keys might or might not be part of the key for the referring table.Type = checking checking savings checking checking. Deposit, Foreign keys might or might not be part of the key for the referring table.Number = AcctNo. Deposit, Foreign keys might or might not be part of the key for the referring table.Owner = Transaction-id. Deposit, Foreign keys might or might not be part of the key for the referring table.Balance = Date. Deposit, Foreign keys might or might not be part of the key for the referring table.Type = Amount. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Number = AcctNo 101 101. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Owner = Check-number 924 925. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Balance = Date 10/23/00 10/24/00. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Type = Amount 125.00 23.98\n-  Data Models\n- Relational Database Model\n-  Basic Concepts and Terminology\n-  Keys and Foreign Keys\n- Schema Specifications"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0015"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0009"}, "gap_lectures": 0}}}
{"A": {"name": "ACCOUNT_TYPE", "role": "NA"}, "B": {"name": "SCHEMA_SPECIFICATIONS", "role": "NA"}, "relation": null, "justification": "There is no clear evidence that either 'ACCOUNT_TYPE' depends on 'SCHEMA_SPECIFICATIONS' or that 'ACCOUNT_TYPE' is part of 'SCHEMA_SPECIFICATIONS'. The evidence provided does not establish a clear prerequisite or component relationship between the two concepts.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0009", "lecture_id": "1-RelationalModel", "text": "Account\n101 102 103 104 105, Owner = J. Smith W. Wei J. Smith M. Jones H. Martin. 101 102 103 104 105, Balance = 1000.00 2000.00 5000.00 1000.00 10,000.00. 101 102 103 104 105, Type = checking checking savings checking checking\nImagine that this table (or relation) has been defined to help keep track of bank accounts."}, {"source": "cluster_A", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0010", "lecture_id": "1-RelationalModel", "text": "The name of the table\nThe name of the columns ( attributes )\nAccount\n101, Owner = J. Smith. 101, Balance = 1000.00. 101, Type = checking. 102, Owner = W. Wei. 102, Balance = 2000.00. 102, Type = checking. 103, Owner = J. Smith. 103, Balance = 5000.00. 103, Type = savings. 104, Owner = M. Jones. 104, Balance = 1000.00. 104, Type = checking. 105, Owner = H. Martin. 105, Balance = 10,000.00. 105, Type = checking"}, {"source": "cluster_A", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0013", "lecture_id": "1-RelationalModel", "text": ", Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. , Number = 102. , Owner = W. Wei. , Balance = 2000.00. , Type = checking. , Number = 103. , Owner = J. Smith. , Balance = 5000.00. , Type = savings. , Number = 104. , Owner = M. Jones. , Balance = 1000.00. , Type = checking. , Number = 105. , Owner = H. Martin. , Balance = 10,000.00. , Type = checking. Deposit, Number = AcctNo. Deposit, Owner = Transaction-id. Deposit, Balance = Date. Deposit, Type = Amount. , Number = 102. , Owner = 1. , Balance = 10/22/00. , Type = 500.00. , Number = 102. , Owner = 2. , Balance = 10/29/00. , Type = 200.00. , Number = 104. , Owner = 3. , Balance = 10/29/00. , Type = 1000.00. , Number = 105. , Owner = 4. , Balance = 11/02/00. , Type = 10,000.00. Check, Number = AcctNo. Check, Owner = Check-number. Check, Balance = Date. Check, Type = Amount. , Number = 101. , Owner = 924. , Balance = 10/23/00. , Type = 125.00. , Number = 101. , Owner = 925. , Balance = 10/24/00. , Type = 23.98"}, {"source": "cluster_B", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0012", "lecture_id": "1-RelationalModel", "text": "The intension of the table\n101, Owner = J. Smith. 101, Balance = 1000.00. 101, Type = checking. 102, Owner = W. Wei. 102, Balance = 2000.00. 102, Type = checking. 103, Owner = J. Smith. 103, Balance = 5000.00. 103, Type = savings. 104, Owner = M. Jones. 104, Balance = 1000.00. 104, Type = checking. 105, Owner = H. Martin. 105, Balance = 10,000.00. 105, Type = checking\nThe extension of the table.  Also called the extent .\n, Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. Cardinality, Number = 102. Cardinality, Owner = W. Wei. Cardinality, Balance = 2000.00. Cardinality, Type = checking. of this instance is 5 (because, Number = 103. of this instance is 5 (because, Owner = J. Smith. of this instance is 5 (because, Balance = 5000.00. of this instance is 5 (because, Type = savings. there are 5, Number = 104. there are 5, Owner = M. Jones. there are 5, Balance = 1000.00. there are 5, Type = checking. rows), Number = 105. rows), Owner = H. Martin. rows), Balance = 10,000.00. rows), Type = checking\n-  Data Models\n- Relational Database Model\n-  Basic Concepts and Terminology\n- Keys and Foreign Keys\n- Schema Specifications"}, {"source": "cluster_B", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0015", "lecture_id": "1-RelationalModel", "text": ", Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. , Number = 102. , Owner = W. Wei. , Balance = 2000.00. , Type = checking. , Number = 103. , Owner = J. Smith. , Balance = 5000.00. , Type = savings. , Number = 104. , Owner = M. Jones. , Balance = 1000.00. , Type = checking. , Number = 105. , Owner = H. Martin. , Balance = 10,000.00. , Type = checking. Deposit, Number = AcctNo Transaction-id. Deposit, Owner = Date. Deposit, Balance = Amount. Deposit, Type = . , Number = 102 1. , Owner = 10/22/00. , Balance = 500.00. , Type = . , Number = 102 2. , Owner = 10/29/00. , Balance = 200.00. , Type = . , Number = 104 3. , Owner = 10/29/00. , Balance = 1000.00. , Type = . , Number = 105 4. , Owner = 11/02/00. , Balance = 10,000.00. , Type = . , Number = 106 5. , Owner = 12/05/00. , Balance = 555.00. , Type = \nWe say that Deposit.AcctNo is a foreign key that references Account.Number.  If the DBMS enforces this constraint, we have referential integrity .\n, Foreign keys might or might not be part of the key for the referring table.Number = 101 102 103 104 105. , Foreign keys might or might not be part of the key for the referring table.Owner = J. Smith W. Wei J. Smith M. Jones H. Martin. , Foreign keys might or might not be part of the key for the referring table.Balance = 1000.00 2000.00 5000.00 1000.00 10,000.00. , Foreign keys might or might not be part of the key for the referring table.Type = checking checking savings checking checking. Deposit, Foreign keys might or might not be part of the key for the referring table.Number = AcctNo. Deposit, Foreign keys might or might not be part of the key for the referring table.Owner = Transaction-id. Deposit, Foreign keys might or might not be part of the key for the referring table.Balance = Date. Deposit, Foreign keys might or might not be part of the key for the referring table.Type = Amount. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Number = AcctNo 101 101. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Owner = Check-number 924 925. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Balance = Date 10/23/00 10/24/00. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Type = Amount 125.00 23.98\n-  Data Models\n- Relational Database Model\n-  Basic Concepts and Terminology\n-  Keys and Foreign Keys\n- Schema Specifications"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0009"}, "gap_lectures": 0}}}
{"A": {"name": "ASSERTIONS", "role": "NA"}, "B": {"name": "ENTITY_IDENTIFICATION", "role": "NA"}, "relation": null, "justification": "There is no clear evidence that supports a 'depends_on' or 'part_of' relationship between 'ASSERTIONS' and 'ENTITY_IDENTIFICATION'.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 140, "label_hint": "constraints-and-database-based-assertions", "chunk_id": "7- ConstraintsTriggers__0001", "lecture_id": "7- ConstraintsTriggers", "text": "After this lecture, you should be able to:\n- Define Database Constraints, including\n- Referential integrity constraints\n- Attribute -level constraints\n- Tuple -level constraints\n- Assertions\n- Define database triggers\n2\n- Constraints\n- Foreign -key, or referential -integrity constraints.\n- Value -based constraints.\n- Tuple -based constraints.\n- Assertions.\n- Triggers"}, {"source": "cluster_A", "cluster_id": 140, "label_hint": "constraints-and-database-based-assertions", "chunk_id": "7- ConstraintsTriggers__0002", "lecture_id": "7- ConstraintsTriggers", "text": "- Constraints are used to make sure that the data in the database 'makes sense', that is: important real -world properties are kept valid\n- Via continuous maintenance of 'assertions' (i.e. Constraints)\n- A constraint is a relationship among data elements that the DBMS is required to enforce.\n- Example: key constraints.\n- Keys.\n- Foreign -key, or referential -integrity.\n- Value -based constraints.\n- Constrain values of a particular attribute.\n- Tuple -based constraints.\n- Relationship among components.\n- Assertions: any SQL Boolean expression."}, {"source": "cluster_B", "cluster_id": 140, "label_hint": "constraints-and-database-based-assertions", "chunk_id": "12-Conceptual_Logical_DB_Design__0010", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "Finding constraints is part of the modeling process. Commonly used constraints:\n-  Keys: attributes that identify entities in an entity set e.g., social security number uniquely identifies a person.\n- \n- Referential integrity constraints: relationship-based constraints\n- e.g., if you work for a company, it must exist in the database.\n-  Domain constraints:  peoples ' ages are between 0 and 150.\n-  General constraints: all others (at most 50 students enroll in a class)"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0010"}, "A_first_introduced_at": {"lecture_index": 19, "lecture_id": "7- ConstraintsTriggers", "chunk_id": "7- ConstraintsTriggers__0001"}, "gap_lectures": 15}}}
{"A": {"name": "ATTRIBUTES", "role": "NA"}, "B": {"name": "DATABASE_DESIGN", "role": "NA"}, "relation": "part_of", "justification": "Attributes are components of database design, as they are used to define the structure of relations within a database.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0016", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nWhat are the attributes and what is the key for Assignment?\n```\nProject(P-number, P-name, Due-Date) Employee(SSN, E-Name, Office)\n```\nProject\nP-number P-name Due-Date\nEmployee\nSSN\nE-Name\nOffice\n0..*     Assignment      0..*\n- 0..*        Manager        1..1\nAnswer: Assignment(P-Number, SSN)\nP-Number is a foreign key for Project SSN is a foreign key for Employee\nProject(P-Number, P-Due-Date)\nEmployee(SSN, E-Name, Office)"}, {"source": "cluster_A", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design__0016", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nWhat are the attributes and what is the key for Assignment?\n```\nProject(P-number, P-name, Due-Date) Employee(SSN, E-Name, Office)\n```\nProject\nP-number P-name Due-Date\nEmployee\nSSN\nE-Name\nOffice\n0..*     Assignment      0..*\n- 0..*        Manager        1..1\nAnswer: Assignment(P-Number, SSN)\nP-Number is a foreign key for Project SSN is a foreign key for Employee\nProject(P-Number, P-Due-Date)\nEmployee(SSN, E-Name, Office)"}, {"source": "cluster_B", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0018", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nMgrSSN is a foreign key (referencing the Employee relation)\nvalue of Manager must match an SSN\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nvs.\nProject(P-number, P-name, Due-Date)\nEmployee(SSN, E-Name, Office)\nManager(P-number, SSN)\nWhat are the tradeoffs between these two?\nNote: P-number is the key for Manager"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0004"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0001"}, "gap_lectures": 0}}}
{"A": {"name": "ATTRIBUTES", "role": "NA"}, "B": {"name": "DATABASE_RELATIONS", "role": "NA"}, "relation": "part_of", "justification": "Attributes are components of database relations, as evidenced by the examples provided where attributes like P-number, SSN, and E-Name are part of the relations Project and Employee.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0016", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nWhat are the attributes and what is the key for Assignment?\n```\nProject(P-number, P-name, Due-Date) Employee(SSN, E-Name, Office)\n```\nProject\nP-number P-name Due-Date\nEmployee\nSSN\nE-Name\nOffice\n0..*     Assignment      0..*\n- 0..*        Manager        1..1\nAnswer: Assignment(P-Number, SSN)\nP-Number is a foreign key for Project SSN is a foreign key for Employee\nProject(P-Number, P-Due-Date)\nEmployee(SSN, E-Name, Office)"}, {"source": "cluster_A", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design__0016", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nWhat are the attributes and what is the key for Assignment?\n```\nProject(P-number, P-name, Due-Date) Employee(SSN, E-Name, Office)\n```\nProject\nP-number P-name Due-Date\nEmployee\nSSN\nE-Name\nOffice\n0..*     Assignment      0..*\n- 0..*        Manager        1..1\nAnswer: Assignment(P-Number, SSN)\nP-Number is a foreign key for Project SSN is a foreign key for Employee\nProject(P-Number, P-Due-Date)\nEmployee(SSN, E-Name, Office)"}, {"source": "cluster_B", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design__0018", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nMgrSSN is a foreign key (referencing the Employee relation)\nvalue of Manager must match an SSN\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nvs.\nProject(P-number, P-name, Due-Date)\nEmployee(SSN, E-Name, Office)\nManager(P-number, SSN)\nWhat are the tradeoffs between these two?\nNote: P-number is the key for Manager"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0011"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0001"}, "gap_lectures": 0}}}
{"A": {"name": "ATTRIBUTES", "role": "NA"}, "B": {"name": "DATA_NORMALIZATION", "role": "NA"}, "relation": null, "justification": "There is no clear indication in the provided evidence that attributes depend on or are part of data normalization.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0016", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nWhat are the attributes and what is the key for Assignment?\n```\nProject(P-number, P-name, Due-Date) Employee(SSN, E-Name, Office)\n```\nProject\nP-number P-name Due-Date\nEmployee\nSSN\nE-Name\nOffice\n0..*     Assignment      0..*\n- 0..*        Manager        1..1\nAnswer: Assignment(P-Number, SSN)\nP-Number is a foreign key for Project SSN is a foreign key for Employee\nProject(P-Number, P-Due-Date)\nEmployee(SSN, E-Name, Office)"}, {"source": "cluster_A", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design__0016", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nWhat are the attributes and what is the key for Assignment?\n```\nProject(P-number, P-name, Due-Date) Employee(SSN, E-Name, Office)\n```\nProject\nP-number P-name Due-Date\nEmployee\nSSN\nE-Name\nOffice\n0..*     Assignment      0..*\n- 0..*        Manager        1..1\nAnswer: Assignment(P-Number, SSN)\nP-Number is a foreign key for Project SSN is a foreign key for Employee\nProject(P-Number, P-Due-Date)\nEmployee(SSN, E-Name, Office)"}, {"source": "cluster_B", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design__0018", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nMgrSSN is a foreign key (referencing the Employee relation)\nvalue of Manager must match an SSN\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nvs.\nProject(P-number, P-name, Due-Date)\nEmployee(SSN, E-Name, Office)\nManager(P-number, SSN)\nWhat are the tradeoffs between these two?\nNote: P-number is the key for Manager"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0018"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0001"}, "gap_lectures": 0}}}
{"A": {"name": "ATTRIBUTES", "role": "NA"}, "B": {"name": "PRIMARY_KEY", "role": "NA"}, "relation": "part_of", "justification": "Both attributes and primary keys are components of the relational model, with primary keys being a specific type of attribute used to uniquely identify records in a table.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 103, "label_hint": "keys-and-model-foreign-relational", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0001", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Relational model has:\n- tables (relations) with attributes, keys, foreign keys, domain definitions for attributes"}, {"source": "cluster_A", "cluster_id": 103, "label_hint": "keys-and-model-foreign-relational", "chunk_id": "12-Conceptual_Logical_DB_Design__0001", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Relational model has:\n- tables (relations) with attributes, keys, foreign keys, domain definitions for attributes"}, {"source": "cluster_B", "cluster_id": 103, "label_hint": "keys-and-model-foreign-relational", "chunk_id": "1-RelationalModel__0000", "lecture_id": "1-RelationalModel", "text": "- Define a data model\n- Define the relational data model\n- Articulate the basic terminologies of the relational data model (from a practical perspective)\n- Define Primary and Foreign keys"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0000"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0001"}, "gap_lectures": 4}}}
{"A": {"name": "ATTRIBUTES", "role": "NA"}, "B": {"name": "REFERENTIAL_INTEGRITY", "role": "NA"}, "relation": "depends_on", "justification": "Referential integrity relies on the correct assignment of foreign keys, which are a type of attribute. The evidence shows that attributes like SSN and P-number are used as foreign keys to ensure referential integrity.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0016", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nWhat are the attributes and what is the key for Assignment?\n```\nProject(P-number, P-name, Due-Date) Employee(SSN, E-Name, Office)\n```\nProject\nP-number P-name Due-Date\nEmployee\nSSN\nE-Name\nOffice\n0..*     Assignment      0..*\n- 0..*        Manager        1..1\nAnswer: Assignment(P-Number, SSN)\nP-Number is a foreign key for Project SSN is a foreign key for Employee\nProject(P-Number, P-Due-Date)\nEmployee(SSN, E-Name, Office)"}, {"source": "cluster_A", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design__0016", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nWhat are the attributes and what is the key for Assignment?\n```\nProject(P-number, P-name, Due-Date) Employee(SSN, E-Name, Office)\n```\nProject\nP-number P-name Due-Date\nEmployee\nSSN\nE-Name\nOffice\n0..*     Assignment      0..*\n- 0..*        Manager        1..1\nAnswer: Assignment(P-Number, SSN)\nP-Number is a foreign key for Project SSN is a foreign key for Employee\nProject(P-Number, P-Due-Date)\nEmployee(SSN, E-Name, Office)"}, {"source": "cluster_B", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0018", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nMgrSSN is a foreign key (referencing the Employee relation)\nvalue of Manager must match an SSN\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nvs.\nProject(P-number, P-name, Due-Date)\nEmployee(SSN, E-Name, Office)\nManager(P-number, SSN)\nWhat are the tradeoffs between these two?\nNote: P-number is the key for Manager"}, {"source": "cluster_B", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design__0018", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nMgrSSN is a foreign key (referencing the Employee relation)\nvalue of Manager must match an SSN\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nvs.\nProject(P-number, P-name, Due-Date)\nEmployee(SSN, E-Name, Office)\nManager(P-number, SSN)\nWhat are the tradeoffs between these two?\nNote: P-number is the key for Manager"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0015"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0001"}, "gap_lectures": 4}}}
{"A": {"name": "CARDINALITY", "role": "NA"}, "B": {"name": "FROM_CLAUSE", "role": "NA"}, "relation": null, "justification": "There is no clear connection between 'CARDINALITY' and 'FROM_CLAUSE' based on the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0012", "lecture_id": "1-RelationalModel", "text": "The intension of the table\n101, Owner = J. Smith. 101, Balance = 1000.00. 101, Type = checking. 102, Owner = W. Wei. 102, Balance = 2000.00. 102, Type = checking. 103, Owner = J. Smith. 103, Balance = 5000.00. 103, Type = savings. 104, Owner = M. Jones. 104, Balance = 1000.00. 104, Type = checking. 105, Owner = H. Martin. 105, Balance = 10,000.00. 105, Type = checking\nThe extension of the table.  Also called the extent .\n, Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. Cardinality, Number = 102. Cardinality, Owner = W. Wei. Cardinality, Balance = 2000.00. Cardinality, Type = checking. of this instance is 5 (because, Number = 103. of this instance is 5 (because, Owner = J. Smith. of this instance is 5 (because, Balance = 5000.00. of this instance is 5 (because, Type = savings. there are 5, Number = 104. there are 5, Owner = M. Jones. there are 5, Balance = 1000.00. there are 5, Type = checking. rows), Number = 105. rows), Owner = H. Martin. rows), Balance = 10,000.00. rows), Type = checking\n-  Data Models\n- Relational Database Model\n-  Basic Concepts and Terminology\n- Keys and Foreign Keys\n- Schema Specifications"}, {"source": "cluster_B", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "2-SQL-Basics__0005", "lecture_id": "2-SQL-Basics", "text": "Account, 1 = Number. Account, 2 = Owner. Account, 3 = Balance. Account, 4 = T\\pe. , 1 = 101. , 2 = J. Smith. , 3 = 1000.00. , 4 = checking. , 1 = 102. , 2 = W. Wei. , 3 = 2000.00. , 4 = checking. , 1 = 103. , 2 = J. Smith. , 3 = 5000.00. , 4 = savings. , 1 = 104. , 2 = M. Jones. , 3 = 1000.00. , 4 = checking. , 1 = 105. , 2 = H. Martin. , 3 = 10,000.00. , 4 = checking\nSELECT, 1 = Number, Owner. FROM, 1 = Account. WHERE, 1 = T\\pe = \" savings \" ;\nNumber, 1 = Owner\n103\nJ. Smith"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 10, "lecture_id": "2-SQL-Basics", "chunk_id": "2-SQL-Basics__0005"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0012"}, "gap_lectures": -10}}}
{"A": {"name": "CARDINALITY", "role": "NA"}, "B": {"name": "REFERENTIAL_INTEGRITY", "role": "NA"}, "relation": null, "justification": "There is no clear indication in the provided evidence that CARDINALITY depends on or is part of REFERENTIAL_INTEGRITY. The concepts appear in different contexts within the same lecture but do not establish a direct dependency or part-of relationship.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0012", "lecture_id": "1-RelationalModel", "text": "The intension of the table\n101, Owner = J. Smith. 101, Balance = 1000.00. 101, Type = checking. 102, Owner = W. Wei. 102, Balance = 2000.00. 102, Type = checking. 103, Owner = J. Smith. 103, Balance = 5000.00. 103, Type = savings. 104, Owner = M. Jones. 104, Balance = 1000.00. 104, Type = checking. 105, Owner = H. Martin. 105, Balance = 10,000.00. 105, Type = checking\nThe extension of the table.  Also called the extent .\n, Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. Cardinality, Number = 102. Cardinality, Owner = W. Wei. Cardinality, Balance = 2000.00. Cardinality, Type = checking. of this instance is 5 (because, Number = 103. of this instance is 5 (because, Owner = J. Smith. of this instance is 5 (because, Balance = 5000.00. of this instance is 5 (because, Type = savings. there are 5, Number = 104. there are 5, Owner = M. Jones. there are 5, Balance = 1000.00. there are 5, Type = checking. rows), Number = 105. rows), Owner = H. Martin. rows), Balance = 10,000.00. rows), Type = checking\n-  Data Models\n- Relational Database Model\n-  Basic Concepts and Terminology\n- Keys and Foreign Keys\n- Schema Specifications"}, {"source": "cluster_B", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0015", "lecture_id": "1-RelationalModel", "text": ", Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. , Number = 102. , Owner = W. Wei. , Balance = 2000.00. , Type = checking. , Number = 103. , Owner = J. Smith. , Balance = 5000.00. , Type = savings. , Number = 104. , Owner = M. Jones. , Balance = 1000.00. , Type = checking. , Number = 105. , Owner = H. Martin. , Balance = 10,000.00. , Type = checking. Deposit, Number = AcctNo Transaction-id. Deposit, Owner = Date. Deposit, Balance = Amount. Deposit, Type = . , Number = 102 1. , Owner = 10/22/00. , Balance = 500.00. , Type = . , Number = 102 2. , Owner = 10/29/00. , Balance = 200.00. , Type = . , Number = 104 3. , Owner = 10/29/00. , Balance = 1000.00. , Type = . , Number = 105 4. , Owner = 11/02/00. , Balance = 10,000.00. , Type = . , Number = 106 5. , Owner = 12/05/00. , Balance = 555.00. , Type = \nWe say that Deposit.AcctNo is a foreign key that references Account.Number.  If the DBMS enforces this constraint, we have referential integrity .\n, Foreign keys might or might not be part of the key for the referring table.Number = 101 102 103 104 105. , Foreign keys might or might not be part of the key for the referring table.Owner = J. Smith W. Wei J. Smith M. Jones H. Martin. , Foreign keys might or might not be part of the key for the referring table.Balance = 1000.00 2000.00 5000.00 1000.00 10,000.00. , Foreign keys might or might not be part of the key for the referring table.Type = checking checking savings checking checking. Deposit, Foreign keys might or might not be part of the key for the referring table.Number = AcctNo. Deposit, Foreign keys might or might not be part of the key for the referring table.Owner = Transaction-id. Deposit, Foreign keys might or might not be part of the key for the referring table.Balance = Date. Deposit, Foreign keys might or might not be part of the key for the referring table.Type = Amount. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Number = AcctNo 101 101. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Owner = Check-number 924 925. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Balance = Date 10/23/00 10/24/00. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Type = Amount 125.00 23.98\n-  Data Models\n- Relational Database Model\n-  Basic Concepts and Terminology\n-  Keys and Foreign Keys\n- Schema Specifications"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0015"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0012"}, "gap_lectures": 0}}}
{"A": {"name": "CARDINALITY", "role": "NA"}, "B": {"name": "WHERE_CLAUSE", "role": "NA"}, "relation": null, "justification": "There is no clear connection or dependency between 'CARDINALITY' and 'WHERE_CLAUSE' based on the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0012", "lecture_id": "1-RelationalModel", "text": "The intension of the table\n101, Owner = J. Smith. 101, Balance = 1000.00. 101, Type = checking. 102, Owner = W. Wei. 102, Balance = 2000.00. 102, Type = checking. 103, Owner = J. Smith. 103, Balance = 5000.00. 103, Type = savings. 104, Owner = M. Jones. 104, Balance = 1000.00. 104, Type = checking. 105, Owner = H. Martin. 105, Balance = 10,000.00. 105, Type = checking\nThe extension of the table.  Also called the extent .\n, Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. Cardinality, Number = 102. Cardinality, Owner = W. Wei. Cardinality, Balance = 2000.00. Cardinality, Type = checking. of this instance is 5 (because, Number = 103. of this instance is 5 (because, Owner = J. Smith. of this instance is 5 (because, Balance = 5000.00. of this instance is 5 (because, Type = savings. there are 5, Number = 104. there are 5, Owner = M. Jones. there are 5, Balance = 1000.00. there are 5, Type = checking. rows), Number = 105. rows), Owner = H. Martin. rows), Balance = 10,000.00. rows), Type = checking\n-  Data Models\n- Relational Database Model\n-  Basic Concepts and Terminology\n- Keys and Foreign Keys\n- Schema Specifications"}, {"source": "cluster_B", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "2-SQL-Basics__0005", "lecture_id": "2-SQL-Basics", "text": "Account, 1 = Number. Account, 2 = Owner. Account, 3 = Balance. Account, 4 = T\\pe. , 1 = 101. , 2 = J. Smith. , 3 = 1000.00. , 4 = checking. , 1 = 102. , 2 = W. Wei. , 3 = 2000.00. , 4 = checking. , 1 = 103. , 2 = J. Smith. , 3 = 5000.00. , 4 = savings. , 1 = 104. , 2 = M. Jones. , 3 = 1000.00. , 4 = checking. , 1 = 105. , 2 = H. Martin. , 3 = 10,000.00. , 4 = checking\nSELECT, 1 = Number, Owner. FROM, 1 = Account. WHERE, 1 = T\\pe = \" savings \" ;\nNumber, 1 = Owner\n103\nJ. Smith"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 10, "lecture_id": "2-SQL-Basics", "chunk_id": "2-SQL-Basics__0005"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0012"}, "gap_lectures": -10}}}
{"A": {"name": "CONCEPTUAL_DESIGN", "role": "NA"}, "B": {"name": "DATABASE_SCHEMA", "role": "NA"}, "relation": "depends_on", "justification": "Conceptual design (A) involves defining entities and relationships, which are used to create a database schema (B). The evidence shows that the conceptual design is a prerequisite for transforming ER design into a relational schema, which is a form of database schema.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0000", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "cluster_A", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "12-Conceptual_Logical_DB_Design__0000", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "cluster_A", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "13-NFs-FDs__0001", "lecture_id": "13-NFs-FDs", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "cluster_B", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "13-NFs-FDs__0003", "lecture_id": "13-NFs-FDs", "text": "- Start with the original db schema R\n- From ER translation or otherwise\n- Identify its functional dependencies\n- Use them to transform R until we get a good design R*"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0003"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "gap_lectures": -2}}}
{"A": {"name": "CONCEPTUAL_DESIGN", "role": "NA"}, "B": {"name": "FUNCTIONAL_DEPENDENCIES", "role": "NA"}, "relation": "depends_on", "justification": "Conceptual design (A) involves understanding entities and relationships, which are foundational for identifying functional dependencies (B) in the logical design phase.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0000", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "cluster_A", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "12-Conceptual_Logical_DB_Design__0000", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "cluster_A", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "13-NFs-FDs__0001", "lecture_id": "13-NFs-FDs", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "cluster_B", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "13-NFs-FDs__0003", "lecture_id": "13-NFs-FDs", "text": "- Start with the original db schema R\n- From ER translation or otherwise\n- Identify its functional dependencies\n- Use them to transform R until we get a good design R*"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0003"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "gap_lectures": -2}}}
{"A": {"name": "CONCURRENT_EXECUTION", "role": "NA"}, "B": {"name": "LOCKING", "role": "NA"}, "relation": "depends_on", "justification": "Locking is a mechanism used to manage concurrent execution of transactions to ensure isolation and consistency, implying that understanding locking is necessary before understanding how concurrent execution is managed.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 81, "label_hint": "isolation-and-levels-transactions-acid", "chunk_id": "19-Trxn-Mgmt__0002", "lecture_id": "19-Trxn-Mgmt", "text": "- Describe transactions, ACID properties and issues related to concurrent exaction of transactions.\n- Describe how database systems implement isolation levels"}, {"source": "cluster_B", "cluster_id": 81, "label_hint": "isolation-and-levels-transactions-acid", "chunk_id": "19-Trxn-Mgmt__0003", "lecture_id": "19-Trxn-Mgmt", "text": "- Transactions and ACID properties\n- Transactions in SQL\n- Isolation levels\n- Isolation Levels and Locking"}, {"source": "cluster_B", "cluster_id": 81, "label_hint": "isolation-and-levels-transactions-acid", "chunk_id": "19-Trxn-Mgmt__0016", "lecture_id": "19-Trxn-Mgmt", "text": "-  Transactions and ACID properties\n- Transactions in SQL\n- Isolation levels\n- Isolation Levels and Locking"}, {"source": "cluster_B", "cluster_id": 81, "label_hint": "isolation-and-levels-transactions-acid", "chunk_id": "19-Trxn-Mgmt__0025", "lecture_id": "19-Trxn-Mgmt", "text": "-  Transactions and ACID properties\n-  Transactions in SQL\n- Isolation levels\n- Isolation Levels and Locking"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0003"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0002"}, "gap_lectures": 0}}}
{"A": {"name": "CONCURRENT_EXECUTION", "role": "NA"}, "B": {"name": "READ_COMMITTED", "role": "NA"}, "relation": "depends_on", "justification": "CONCURRENT_EXECUTION depends on READ_COMMITTED because the concept of concurrent execution is discussed in the context of transaction management, and READ_COMMITTED is a specific isolation level that allows for concurrent reads while maintaining consistency.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 70, "label_hint": "transaction-and-read-balance-account", "chunk_id": "19-Trxn-Mgmt__0018", "lecture_id": "19-Trxn-Mgmt", "text": "- When a transaction only reads information, we have more freedom to let the transaction execute concurrently with other transactions.\n- We signal this to the system by stating:\n```\nSET TRANSACTION READ ONLY; SELECT * FROM Accounts WHERE account#= ' 1234 ' ; ...\n```"}, {"source": "cluster_B", "cluster_id": 70, "label_hint": "transaction-and-read-balance-account", "chunk_id": "19-Trxn-Mgmt__0036", "lecture_id": "19-Trxn-Mgmt", "text": "READ UNCOMMITTED allows queries in the transaction to read data without acquiring any lock\n- Access mode READ ONLY, no updates are allowed\nREAD COMMITTED requires a read-lock to be obtained for all tuples touched by queries, but it releases the locks immediately after the read\n- Exclusive locks must be obtained for updates and held to end of transaction"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0027"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0002"}, "gap_lectures": 0}}}
{"A": {"name": "CONCURRENT_EXECUTION", "role": "NA"}, "B": {"name": "READ_UNCOMMITTED", "role": "NA"}, "relation": null, "justification": "There is no clear dependency or part_of relationship between CONCURRENT_EXECUTION and READ_UNCOMMITTED based on the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 70, "label_hint": "transaction-and-read-balance-account", "chunk_id": "19-Trxn-Mgmt__0018", "lecture_id": "19-Trxn-Mgmt", "text": "- When a transaction only reads information, we have more freedom to let the transaction execute concurrently with other transactions.\n- We signal this to the system by stating:\n```\nSET TRANSACTION READ ONLY; SELECT * FROM Accounts WHERE account#= ' 1234 ' ; ...\n```"}, {"source": "cluster_B", "cluster_id": 70, "label_hint": "transaction-and-read-balance-account", "chunk_id": "19-Trxn-Mgmt__0036", "lecture_id": "19-Trxn-Mgmt", "text": "READ UNCOMMITTED allows queries in the transaction to read data without acquiring any lock\n- Access mode READ ONLY, no updates are allowed\nREAD COMMITTED requires a read-lock to be obtained for all tuples touched by queries, but it releases the locks immediately after the read\n- Exclusive locks must be obtained for updates and held to end of transaction"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0027"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0002"}, "gap_lectures": 0}}}
{"A": {"name": "CONCURRENT_EXECUTION", "role": "NA"}, "B": {"name": "SQL_TRANSACTIONS", "role": "NA"}, "relation": "depends_on", "justification": "CONCURRENT_EXECUTION is discussed in the context of how database systems implement isolation levels, which are crucial for understanding SQL_TRANSACTIONS and their isolation levels.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 81, "label_hint": "isolation-and-levels-transactions-acid", "chunk_id": "19-Trxn-Mgmt__0002", "lecture_id": "19-Trxn-Mgmt", "text": "- Describe transactions, ACID properties and issues related to concurrent exaction of transactions.\n- Describe how database systems implement isolation levels"}, {"source": "cluster_B", "cluster_id": 81, "label_hint": "isolation-and-levels-transactions-acid", "chunk_id": "19-Trxn-Mgmt__0003", "lecture_id": "19-Trxn-Mgmt", "text": "- Transactions and ACID properties\n- Transactions in SQL\n- Isolation levels\n- Isolation Levels and Locking"}, {"source": "cluster_B", "cluster_id": 81, "label_hint": "isolation-and-levels-transactions-acid", "chunk_id": "19-Trxn-Mgmt__0016", "lecture_id": "19-Trxn-Mgmt", "text": "-  Transactions and ACID properties\n- Transactions in SQL\n- Isolation levels\n- Isolation Levels and Locking"}, {"source": "cluster_B", "cluster_id": 81, "label_hint": "isolation-and-levels-transactions-acid", "chunk_id": "19-Trxn-Mgmt__0025", "lecture_id": "19-Trxn-Mgmt", "text": "-  Transactions and ACID properties\n-  Transactions in SQL\n- Isolation levels\n- Isolation Levels and Locking"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0003"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0002"}, "gap_lectures": 0}}}
{"A": {"name": "CONCURRENT_EXECUTION", "role": "NA"}, "B": {"name": "TRANSACTION_ISOLATION", "role": "NA"}, "relation": "depends_on", "justification": "CONCURRENT_EXECUTION depends on TRANSACTION_ISOLATION because the isolation level determines the conditions under which concurrent transactions can read and write data, which directly impacts how concurrent execution is managed.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 70, "label_hint": "transaction-and-read-balance-account", "chunk_id": "19-Trxn-Mgmt__0018", "lecture_id": "19-Trxn-Mgmt", "text": "- When a transaction only reads information, we have more freedom to let the transaction execute concurrently with other transactions.\n- We signal this to the system by stating:\n```\nSET TRANSACTION READ ONLY; SELECT * FROM Accounts WHERE account#= ' 1234 ' ; ...\n```"}, {"source": "cluster_B", "cluster_id": 70, "label_hint": "transaction-and-read-balance-account", "chunk_id": "19-Trxn-Mgmt__0028", "lecture_id": "19-Trxn-Mgmt", "text": "- Forbids the reading of dirty (uncommitted) data, but allows a transaction T to issue the same query several times and get different answers\n- No value written by T can be modified until T completes"}, {"source": "cluster_B", "cluster_id": 70, "label_hint": "transaction-and-read-balance-account", "chunk_id": "19-Trxn-Mgmt__0036", "lecture_id": "19-Trxn-Mgmt", "text": "READ UNCOMMITTED allows queries in the transaction to read data without acquiring any lock\n- Access mode READ ONLY, no updates are allowed\nREAD COMMITTED requires a read-lock to be obtained for all tuples touched by queries, but it releases the locks immediately after the read\n- Exclusive locks must be obtained for updates and held to end of transaction"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0013"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0002"}, "gap_lectures": 0}}}
{"A": {"name": "CONDITIONAL_CHECK", "role": "NA"}, "B": {"name": "DATABASE_SCHEMA", "role": "NA"}, "relation": "depends_on", "justification": "A conditional check is used within the context of a database schema to enforce constraints on attribute values, indicating that understanding database schema is a prerequisite for implementing conditional checks.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 136, "label_hint": "condition-and-attribute-check-added", "chunk_id": "7- ConstraintsTriggers__0016", "lecture_id": "7- ConstraintsTriggers", "text": "- Place a constraint on the value of a particular attribute.\n- CHECK( <condition> ) must be added to the declaration for the attribute.\n- The condition may use the name of the attribute, but any other relation or attribute name must be in a subquery.\nI"}, {"source": "cluster_B", "cluster_id": 136, "label_hint": "condition-and-attribute-check-added", "chunk_id": "7- ConstraintsTriggers__0024", "lecture_id": "7- ConstraintsTriggers", "text": "- These are database -schema elements, like relations or views.\n- Defined by:\nCREATE ASSERTION <name>\n- CHECK ( <condition> );\n- Condition may refer to any relation or attribute in the database schema.\n- Must be true at all times\nI ILLINOIS"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0003"}, "A_first_introduced_at": {"lecture_index": 19, "lecture_id": "7- ConstraintsTriggers", "chunk_id": "7- ConstraintsTriggers__0016"}, "gap_lectures": 13}}}
{"A": {"name": "CONDITIONAL_CHECK", "role": "NA"}, "B": {"name": "REFERENTIAL_INTEGRITY", "role": "NA"}, "relation": null, "justification": "There is no clear dependency or part_of relationship between CONDITIONAL_CHECK and REFERENTIAL_INTEGRITY based on the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 136, "label_hint": "condition-and-attribute-check-added", "chunk_id": "7- ConstraintsTriggers__0016", "lecture_id": "7- ConstraintsTriggers", "text": "- Place a constraint on the value of a particular attribute.\n- CHECK( <condition> ) must be added to the declaration for the attribute.\n- The condition may use the name of the attribute, but any other relation or attribute name must be in a subquery.\nI"}, {"source": "cluster_B", "cluster_id": 136, "label_hint": "condition-and-attribute-check-added", "chunk_id": "7- ConstraintsTriggers__0024", "lecture_id": "7- ConstraintsTriggers", "text": "- These are database -schema elements, like relations or views.\n- Defined by:\nCREATE ASSERTION <name>\n- CHECK ( <condition> );\n- Condition may refer to any relation or attribute in the database schema.\n- Must be true at all times\nI ILLINOIS"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0015"}, "A_first_introduced_at": {"lecture_index": 19, "lecture_id": "7- ConstraintsTriggers", "chunk_id": "7- ConstraintsTriggers__0016"}, "gap_lectures": 19}}}
{"A": {"name": "CONFLICT", "role": "NA"}, "B": {"name": "READ_OPERATION", "role": "NA"}, "relation": "depends_on", "justification": "CONFLICT depends on READ_OPERATION because a conflict can arise from operations involving read and write actions, and the presence of a read operation is a necessary condition for identifying a conflict scenario.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 34, "label_hint": "t1-and-t2-t3-write", "chunk_id": "20-Trxn-Serializability__0019", "lecture_id": "20-Trxn-Serializability", "text": "T1:        R(A)   W(A)\nR(B)    W(B)\nT2:\nR(A)     W(A)\nR(B)   W(B)"}, {"source": "cluster_B", "cluster_id": 34, "label_hint": "t1-and-t2-t3-write", "chunk_id": "20-Trxn-Serializability__0020", "lecture_id": "20-Trxn-Serializability", "text": "T1:, 1 = R(A),. T1:, 2 = R(C). T1:, 3 = W(B). T2: T3:, 1 = R(B). T2: T3:, 2 = . T2: T3:, 3 = R(B)\n```\nS1(A); R1(A); S2(B) R2(B); S3(A); R3(A); X2(C); W2(C); REL2(C); S1(C); R1(C); R2(B); REL2(B); X1(B); W1(B); REL1(A,B,C); S3(B); R3(B); REL3(A,B);\n```"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 2, "reason": "A and B appear in different chunks within 2 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0021"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0019"}, "gap_lectures": 2}}}
{"A": {"name": "CONFLICT", "role": "NA"}, "B": {"name": "TRANSACTION_ISOLATION", "role": "NA"}, "relation": "depends_on", "justification": "Conflict is a concept that needs to be understood before discussing transaction isolation, as transaction isolation mechanisms aim to prevent conflicts between transactions.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 34, "label_hint": "t1-and-t2-t3-write", "chunk_id": "20-Trxn-Serializability__0019", "lecture_id": "20-Trxn-Serializability", "text": "T1:        R(A)   W(A)\nR(B)    W(B)\nT2:\nR(A)     W(A)\nR(B)   W(B)"}, {"source": "cluster_B", "cluster_id": 34, "label_hint": "t1-and-t2-t3-write", "chunk_id": "20-Trxn-Serializability__0020", "lecture_id": "20-Trxn-Serializability", "text": "T1:, 1 = R(A),. T1:, 2 = R(C). T1:, 3 = W(B). T2: T3:, 1 = R(B). T2: T3:, 2 = . T2: T3:, 3 = R(B)\n```\nS1(A); R1(A); S2(B) R2(B); S3(A); R3(A); X2(C); W2(C); REL2(C); S1(C); R1(C); R2(B); REL2(B); X1(B); W1(B); REL1(A,B,C); S3(B); R3(B); REL3(A,B);\n```"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 2, "reason": "A and B appear in different chunks within 2 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0013"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0019"}, "gap_lectures": 2}}}
{"A": {"name": "CONFLICT", "role": "NA"}, "B": {"name": "WRITE_OPERATION", "role": "NA"}, "relation": "depends_on", "justification": "A conflict arises due to the presence of write operations in different transactions, indicating that understanding write operations is a prerequisite for understanding conflicts.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 34, "label_hint": "t1-and-t2-t3-write", "chunk_id": "20-Trxn-Serializability__0019", "lecture_id": "20-Trxn-Serializability", "text": "T1:        R(A)   W(A)\nR(B)    W(B)\nT2:\nR(A)     W(A)\nR(B)   W(B)"}, {"source": "cluster_B", "cluster_id": 34, "label_hint": "t1-and-t2-t3-write", "chunk_id": "20-Trxn-Serializability__0020", "lecture_id": "20-Trxn-Serializability", "text": "T1:, 1 = R(A),. T1:, 2 = R(C). T1:, 3 = W(B). T2: T3:, 1 = R(B). T2: T3:, 2 = . T2: T3:, 3 = R(B)\n```\nS1(A); R1(A); S2(B) R2(B); S3(A); R3(A); X2(C); W2(C); REL2(C); S1(C); R1(C); R2(B); REL2(B); X1(B); W1(B); REL1(A,B,C); S3(B); R3(B); REL3(A,B);\n```"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 2, "reason": "A and B appear in different chunks within 2 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0004"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0019"}, "gap_lectures": 0}}}
{"A": {"name": "CONFLICT_SERIALIZABLE", "role": "NA"}, "B": {"name": "READ_OPERATION", "role": "NA"}, "relation": null, "justification": "There is no clear evidence that CONFLICT_SERIALIZABLE depends on or is part of READ_OPERATION based on the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0007", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n- Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0011", "lecture_id": "20-Trxn-Serializability", "text": "Given a schedule S, we can construct a directed graph G=(V,E) called a precedence graph\n- V :  all transactions in S\n- E :  T i  Tj whenever an action of T i precedes and conflicts with an action of T j in S (RW, WR, WW)\nTheorem:A schedule S is conflict serializable iff its precedence graph contains no cycles"}, {"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0015", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0014", "lecture_id": "20-Trxn-Serializability", "text": "Two schedules S1 and S2 are view equivalent if:\n- If ௜ reads an initial value of A in S1, then ௜ reads the initial value of A in S2\n- If ௜ reads a value of A written by ௝ in S1, then ௜ reads a value of A written by ௝ in S2\n- If ௜ writes the final value of A in S1, then ௜ writes the final value of A in S2\nA schedule is view serializable if it is view-equivalent to a serial schedule"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0021"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "gap_lectures": 2}}}
{"A": {"name": "CONFLICT_SERIALIZABLE", "role": "NA"}, "B": {"name": "SERIALIZABILITY", "role": "NA"}, "relation": "depends_on", "justification": "Conflict-Serializable schedules are a specific type of serializable schedules, implying that understanding serializability is a prerequisite for understanding conflict-serializability.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0007", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n- Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0011", "lecture_id": "20-Trxn-Serializability", "text": "Given a schedule S, we can construct a directed graph G=(V,E) called a precedence graph\n- V :  all transactions in S\n- E :  T i  Tj whenever an action of T i precedes and conflicts with an action of T j in S (RW, WR, WW)\nTheorem:A schedule S is conflict serializable iff its precedence graph contains no cycles"}, {"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0015", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0005", "lecture_id": "20-Trxn-Serializability", "text": "A schedule is serializable if it is equivalent to a serial schedule.\nFinal state must be the same as the state produced by one of the serial schedules.\nT1\nT2\nREAD(A, t)\nt := t+100\nWRITE(A, t)\nREAD(A, s)\ns := s*2\nWRITE(A,s)\nREAD(B, t)\nt := t+100\nWRITE(B,t)\nREAD(B,s)\ns := s*2\nWRITE(B,s)"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0017", "lecture_id": "20-Trxn-Serializability", "text": "If all transactions are well-formed and two-phase, then any schedule in which conflicting locks are never granted ensures serializability"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0006"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "gap_lectures": 2}}}
{"A": {"name": "CONFLICT_SERIALIZABLE", "role": "NA"}, "B": {"name": "SERIAL_SCHEDULE", "role": "NA"}, "relation": "depends_on", "justification": "Conflict-Serializable schedules are a specific type of serializable schedules, and understanding serial schedules is necessary to comprehend conflict-serializable schedules.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0007", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n- Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0011", "lecture_id": "20-Trxn-Serializability", "text": "Given a schedule S, we can construct a directed graph G=(V,E) called a precedence graph\n- V :  all transactions in S\n- E :  T i  Tj whenever an action of T i precedes and conflicts with an action of T j in S (RW, WR, WW)\nTheorem:A schedule S is conflict serializable iff its precedence graph contains no cycles"}, {"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0015", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0005", "lecture_id": "20-Trxn-Serializability", "text": "A schedule is serializable if it is equivalent to a serial schedule.\nFinal state must be the same as the state produced by one of the serial schedules.\nT1\nT2\nREAD(A, t)\nt := t+100\nWRITE(A, t)\nREAD(A, s)\ns := s*2\nWRITE(A,s)\nREAD(B, t)\nt := t+100\nWRITE(B,t)\nREAD(B,s)\ns := s*2\nWRITE(B,s)"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0013", "lecture_id": "20-Trxn-Serializability", "text": "Is this schedule conflict-serializable?\nIn both schedules, database is in the same state:\nA written by T2 and B written by T3\nBoth schedules are equivalent\nBut not conflict-equivalent\nA schedule is view serializable if it is view-equivalent to a serial schedule\nW(A), T2 = . W(A), T3 = . , T2 = W(A). , T3 = . , T2 = W(B). , T3 = . W(B), T2 = . W(B), T3 = . , T2 = . , T3 = W(B). T1, T2 = T2. T1, T3 = T3. W(A), T2 = . W(A), T3 = . W(B), T2 = . W(B), T3 = . , T2 = W(A). , T3 = . , T2 = W(B). , T3 = . , T2 = . , T3 = W(B)"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0014", "lecture_id": "20-Trxn-Serializability", "text": "Two schedules S1 and S2 are view equivalent if:\n- If ௜ reads an initial value of A in S1, then ௜ reads the initial value of A in S2\n- If ௜ reads a value of A written by ௝ in S1, then ௜ reads a value of A written by ௝ in S2\n- If ௜ writes the final value of A in S1, then ௜ writes the final value of A in S2\nA schedule is view serializable if it is view-equivalent to a serial schedule"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0005"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "gap_lectures": 0}}}
{"A": {"name": "CONFLICT_SERIALIZABLE", "role": "NA"}, "B": {"name": "TRANSACTION_MANAGEMENT", "role": "NA"}, "relation": "depends_on", "justification": "Conflict-Serializable schedules are a specific concept within transaction management that require understanding of transaction management principles.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0007", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n- Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0011", "lecture_id": "20-Trxn-Serializability", "text": "Given a schedule S, we can construct a directed graph G=(V,E) called a precedence graph\n- V :  all transactions in S\n- E :  T i  Tj whenever an action of T i precedes and conflicts with an action of T j in S (RW, WR, WW)\nTheorem:A schedule S is conflict serializable iff its precedence graph contains no cycles"}, {"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0015", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0017", "lecture_id": "20-Trxn-Serializability", "text": "If all transactions are well-formed and two-phase, then any schedule in which conflicting locks are never granted ensures serializability"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0001"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "gap_lectures": 2}}}
{"A": {"name": "CONFLICT_SERIALIZABLE", "role": "NA"}, "B": {"name": "WRITE_OPERATION", "role": "NA"}, "relation": "depends_on", "justification": "Conflict-Serializable schedules depend on write operations as they involve actions that conflict with other actions, such as write-write (WW) conflicts.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0007", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n- Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0011", "lecture_id": "20-Trxn-Serializability", "text": "Given a schedule S, we can construct a directed graph G=(V,E) called a precedence graph\n- V :  all transactions in S\n- E :  T i  Tj whenever an action of T i precedes and conflicts with an action of T j in S (RW, WR, WW)\nTheorem:A schedule S is conflict serializable iff its precedence graph contains no cycles"}, {"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0015", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0014", "lecture_id": "20-Trxn-Serializability", "text": "Two schedules S1 and S2 are view equivalent if:\n- If ௜ reads an initial value of A in S1, then ௜ reads the initial value of A in S2\n- If ௜ reads a value of A written by ௝ in S1, then ௜ reads a value of A written by ௝ in S2\n- If ௜ writes the final value of A in S1, then ௜ writes the final value of A in S2\nA schedule is view serializable if it is view-equivalent to a serial schedule"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0004"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "gap_lectures": 0}}}
{"A": {"name": "COST_CALCULATION", "role": "NA"}, "B": {"name": "GROUP_BY", "role": "NA"}, "relation": "depends_on", "justification": "COST_CALCULATION appears to depend on GROUP_BY because the evidence suggests that future operations like GROUP BY may be cheaper after sorting, implying that understanding GROUP_BY is necessary to fully grasp the cost implications of sorting and join operations.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 63, "label_hint": "join-and-sort-index-operations", "chunk_id": "QP__0024", "lecture_id": "QP", "text": "- Assume both R and S have a sorted index (B+ tree) on the join attribute. (A clustering index.)\n- Then perform a merge join (called zig-zag join)\n- This is only the last step of the 'two pass sorting-based join' algorithm we saw previously.\n- 'bring all relevant tuples into memory'\n- Cost: B(R) + B(S)"}, {"source": "cluster_B", "cluster_id": 63, "label_hint": "join-and-sort-index-operations", "chunk_id": "QP__0001", "lecture_id": "QP", "text": "- May want to sort the tuples as we read them: 'Sort-scan'\n- Why?\n- ORDER BY in query\n- Some RA operations are implemented using sort\n- Union, Intersection, …\n- Future operations may be cheaper (e.g., GROUP BY)"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 14, "lecture_id": "23-Rule-basedOpt", "chunk_id": "23-Rule-basedOpt__0001"}, "A_first_introduced_at": {"lecture_index": 24, "lecture_id": "QP", "chunk_id": "QP__0003"}, "gap_lectures": 10}}}
{"A": {"name": "CYPHER_LANGUAGE", "role": "NA"}, "B": {"name": "CYPHER_QUERY", "role": "NA"}, "relation": "part_of", "justification": "Cypher Query appears to be a specific type of operation within the broader concept of Cypher Language, as Cypher is described as a Graph Query Language and queries are performed using this language.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 111, "label_hint": "neo4j-and-graph-com-https", "chunk_id": "10-Neo4J-Part 1__0019", "lecture_id": "10-Neo4J-Part 1", "text": "-  Map -reduce\n-  Introduction to Neo4J\n- Cypher: A Graph Query Language\n-  Querying Nodes and Relationships using Patterns\n- Manipulating Graph Data"}, {"source": "cluster_B", "cluster_id": 111, "label_hint": "neo4j-and-graph-com-https", "chunk_id": "10-Neo4J-Part 1__0028", "lecture_id": "10-Neo4J-Part 1", "text": "1. Neo4j Tutorial: https://www.tutorialspoint.com/neo4j/index.htm\n2. Video Tutorials: https://neo4j.com/blog/neo4j -video -tutorials/?_ga=2.57983406.580712586.1555337212 -902296776.1553382068\n3. GraphGists are teaching tools which allow you to explore how data in a particular domain would be modeled as a graph and see some example queries of that graph data\n- https://neo4j.com/graphgists/\n4. Awesome user -defined procedures: https://github.com/neo4j -contrib/neo4j -apoc -procedures"}, {"source": "cluster_B", "cluster_id": 111, "label_hint": "neo4j-and-graph-com-https", "chunk_id": "11-Neo4J-Part2__0019", "lecture_id": "11-Neo4J-Part2", "text": "1. Neo4j Tutorial:\nhttps://www.tutorialspoint.com/neo4j/index.htm\n2. Video Tutorials: https://neo4j.com/blog/neo4j-videotutorials/?_ga=2.57983406.580712586.1555337212902296776.1553382068\n3. GraphGists are teaching tools which allow you to explore how data in a particular domain would be modeled as a graph and see some example queries of that graph data\n- https://neo4j.com/graphgists/\n4. Awesome user-defined procedures: https://github.com/neo4jcontrib/neo4j-apoc-procedures"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0010"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0019"}, "gap_lectures": 0}}}
{"A": {"name": "CYPHER_LANGUAGE", "role": "NA"}, "B": {"name": "DATA_MODELING", "role": "NA"}, "relation": null, "justification": "There is no clear evidence that supports a 'depends_on' or 'part_of' relationship between CYPHER_LANGUAGE and DATA_MODELING based on the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 111, "label_hint": "neo4j-and-graph-com-https", "chunk_id": "10-Neo4J-Part 1__0019", "lecture_id": "10-Neo4J-Part 1", "text": "-  Map -reduce\n-  Introduction to Neo4J\n- Cypher: A Graph Query Language\n-  Querying Nodes and Relationships using Patterns\n- Manipulating Graph Data"}, {"source": "cluster_B", "cluster_id": 111, "label_hint": "neo4j-and-graph-com-https", "chunk_id": "11-Neo4J-Part2__0009", "lecture_id": "11-Neo4J-Part2", "text": "Source: https://neo4j.com/developer/graph-db-vs-rdbms/#_from_relational_to_graph_databases"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0006"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0019"}, "gap_lectures": 0}}}
{"A": {"name": "CYPHER_QUERY", "role": "NA"}, "B": {"name": "DATA_MODELING", "role": "NA"}, "relation": "depends_on", "justification": "CYPHER_QUERY appears in the context of exploring and querying graph data, which implies that understanding how data is modeled (DATA_MODELING) is a prerequisite for effectively using CYPHER_QUERY.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 111, "label_hint": "neo4j-and-graph-com-https", "chunk_id": "10-Neo4J-Part 1__0028", "lecture_id": "10-Neo4J-Part 1", "text": "1. Neo4j Tutorial: https://www.tutorialspoint.com/neo4j/index.htm\n2. Video Tutorials: https://neo4j.com/blog/neo4j -video -tutorials/?_ga=2.57983406.580712586.1555337212 -902296776.1553382068\n3. GraphGists are teaching tools which allow you to explore how data in a particular domain would be modeled as a graph and see some example queries of that graph data\n- https://neo4j.com/graphgists/\n4. Awesome user -defined procedures: https://github.com/neo4j -contrib/neo4j -apoc -procedures"}, {"source": "cluster_A", "cluster_id": 111, "label_hint": "neo4j-and-graph-com-https", "chunk_id": "11-Neo4J-Part2__0019", "lecture_id": "11-Neo4J-Part2", "text": "1. Neo4j Tutorial:\nhttps://www.tutorialspoint.com/neo4j/index.htm\n2. Video Tutorials: https://neo4j.com/blog/neo4j-videotutorials/?_ga=2.57983406.580712586.1555337212902296776.1553382068\n3. GraphGists are teaching tools which allow you to explore how data in a particular domain would be modeled as a graph and see some example queries of that graph data\n- https://neo4j.com/graphgists/\n4. Awesome user-defined procedures: https://github.com/neo4jcontrib/neo4j-apoc-procedures"}, {"source": "cluster_B", "cluster_id": 111, "label_hint": "neo4j-and-graph-com-https", "chunk_id": "11-Neo4J-Part2__0009", "lecture_id": "11-Neo4J-Part2", "text": "Source: https://neo4j.com/developer/graph-db-vs-rdbms/#_from_relational_to_graph_databases"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0006"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0010"}, "gap_lectures": 0}}}
{"A": {"name": "CYPHER_QUERY", "role": "NA"}, "B": {"name": "DISTINCT_RESULTS", "role": "NA"}, "relation": null, "justification": "There is no clear indication that CYPHER_QUERY depends on or is part of DISTINCT_RESULTS based on the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 94, "label_hint": "product-and-od-products-orderid", "chunk_id": "11-Neo4J-Part2__0012", "lecture_id": "11-Neo4J-Part2", "text": "- Select everything from the products table\nSELECT p.* FROM products as p;\nSQL\nMATCH (p:Product) RETURN p;\nCypher"}, {"source": "cluster_B", "cluster_id": 94, "label_hint": "product-and-od-products-orderid", "chunk_id": "11-Neo4J-Part2__0016", "lecture_id": "11-Neo4J-Part2", "text": "SELECT DISTINCT c.CompanyName\nFROM customers AS c JOIN orders AS o ON (c.CustomerID = o.CustomerID)\nJOIN order_details AS od ON (o.OrderID = od.OrderID)\nJOIN products AS p ON (od.ProductID = p.ProductID)\nWHERE p.ProductName = 'Chocolate';\nMATCH (p:Product {productName:\"Chocolate\"})<[:PRODUCT]-(:Order)<-[:PURCHASED]-(c:Customer) RETURN distinct c.companyName;\nSource: https://neo4j.com/developer/cypher-query-language/"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 2, "lecture_id": "11-Neo4J-Part2", "chunk_id": "11-Neo4J-Part2__0016"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0010"}, "gap_lectures": -1}}}
{"A": {"name": "CYPHER_QUERY", "role": "NA"}, "B": {"name": "NODES", "role": "NA"}, "relation": "depends_on", "justification": "CYPHER_QUERY appears to utilize NODES as it involves operations on named entities (e.g., Person nodes) in the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 33, "label_hint": "person-and-abdu-match-return", "chunk_id": "10-Neo4J-Part 1__0025", "lecture_id": "10-Neo4J-Part 1", "text": "```\nMERGE Ca:Person 3 name: 'Abdu' ? }) ON CREATE SET a.created = timestamp ON MATCH SET a.lastSeen = timestamp RETURN a.name, a.created, a.lastSeen\n```"}, {"source": "cluster_B", "cluster_id": 33, "label_hint": "person-and-abdu-match-return", "chunk_id": "10-Neo4J-Part 1__0022", "lecture_id": "10-Neo4J-Part 1", "text": "```\n{name:\"Lamya\"}) MATCH (a:Person {name:\"Devin\"}) MATCH (b:Person \"Vidisha\"}) MATCH (c:Person {name: CREATE (a)-[:Friends]->(b)<-[:Friends]-(c) RETURN a,b,c\n```"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0002"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0010"}, "gap_lectures": 0}}}
{"A": {"name": "CYPHER_QUERY", "role": "NA"}, "B": {"name": "QUERY_LANGUAGE", "role": "NA"}, "relation": "part_of", "justification": "CYPHER_QUERY is a specific type of query language used in Neo4J, which is a broader concept of QUERY_LANGUAGE.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 32, "label_hint": "title-and-movie-matrix-born", "chunk_id": "10-Neo4J-Part 1__0010", "lecture_id": "10-Neo4J-Part 1", "text": "```\n() (matrix) (:Movie) (matrix:Movie) (matrix:Movie {title: \"The Matrix\"}) (matrix:Movie {title: \"The Matrix\", released: 1997})\n```"}, {"source": "cluster_A", "cluster_id": 32, "label_hint": "title-and-movie-matrix-born", "chunk_id": "10-Neo4J-Part 1__0011", "lecture_id": "10-Neo4J-Part 1", "text": "```\nMATCH (node:Label) WHERE node.property = {value} RETURN node.property\n```\n- Find 'Apollo 13' movie\n- Find 1990's movies\n```\nMATCH (n:Movie {title:\"Apollo 13\"}) RETURN n.released;\n```\n```\nMATCH (n:Movie) WHERE n.released >= 1990 AND n.released <=2000 RETURN I n;\n```"}, {"source": "cluster_B", "cluster_id": 32, "label_hint": "title-and-movie-matrix-born", "chunk_id": "10-Neo4J-Part 1__0018", "lecture_id": "10-Neo4J-Part 1", "text": "```\nMATCH (p:Person)-[:ACTED_IN]->(m:Movie)<-[:DIRECTED]-Cp) RETURN I p.name, m.title;\n```\nTom Hanks, m.title = That Thing You Do. Clint Eastwood, m.title = Unforgiven. Danny DeVito, m.title = Hoffa"}, {"source": "cluster_B", "cluster_id": 32, "label_hint": "title-and-movie-matrix-born", "chunk_id": "11-Neo4J-Part2__0004", "lecture_id": "11-Neo4J-Part2", "text": "```\nMATCH (person: Person)-[:ACTED_IN] ->(m:Movie) WITH person, count(*) AS appearances, collect(m.title) AS movies WHERE appearances > 1 RETURN person.name, appearances, movies\n```\n\"Cuba Gooding Jr.\", \"appearances\" = \"4\". \"Cuba Gooding Jr.\", \"movies\" = [\"AFewGood Men\",\"Jerry Magui re\",\"AsGoodasItGets\",\"what DreamsMayCome\"]. \"oliver Platt\", \"appearances\" = \"2\". \"oliver Platt\", \"movies\" = [\"Frost/Nixon\",\"BicentennialM an\"]. \"Philip Seymour Hoffman\", \"appearances\" = \"2\". \"Philip Seymour Hoffman\", \"movies\" = [\"Twister\",\"charliewilson'sw ar\"]. \"SamRockwell\", \"appearances\" = \"2\". \"SamRockwell\", \"movies\" = [\"The Green Mile\",\"Frost/Nixon \"]. \"Greg Kinnear\", \"appearances\" = \"2\". \"Greg Kinnear\", \"movies\" = [\"As Good as It Gets\",\"You've Got Mail\"]. \"Zach Grenier\", \"appearances\" = \"2\". \"Zach Grenier\", \"movies\" = [\"RescueDawn\",\"Twister\"]. \"Rosieo'Donnell\", \"appearances\" = \"2\". \"Rosieo'Donnell\", \"movies\" = [\"A League ofTheirOwn\",\"slee plessinSeattle\"]\nSource: https://neo4j.com/developer/cypher-query-language/"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0007"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0010"}, "gap_lectures": 0}}}
{"A": {"name": "CYPHER_QUERY", "role": "NA"}, "B": {"name": "RELATIONSHIPS", "role": "NA"}, "relation": "depends_on", "justification": "CYPHER_QUERY (A) requires an understanding of RELATIONSHIPS (B) to effectively create and manipulate relationships between nodes in a graph database.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 33, "label_hint": "person-and-abdu-match-return", "chunk_id": "10-Neo4J-Part 1__0025", "lecture_id": "10-Neo4J-Part 1", "text": "```\nMERGE Ca:Person 3 name: 'Abdu' ? }) ON CREATE SET a.created = timestamp ON MATCH SET a.lastSeen = timestamp RETURN a.name, a.created, a.lastSeen\n```"}, {"source": "cluster_B", "cluster_id": 33, "label_hint": "person-and-abdu-match-return", "chunk_id": "10-Neo4J-Part 1__0022", "lecture_id": "10-Neo4J-Part 1", "text": "```\n{name:\"Lamya\"}) MATCH (a:Person {name:\"Devin\"}) MATCH (b:Person \"Vidisha\"}) MATCH (c:Person {name: CREATE (a)-[:Friends]->(b)<-[:Friends]-(c) RETURN a,b,c\n```"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0002"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0010"}, "gap_lectures": 0}}}
{"A": {"name": "CYPHER_QUERY", "role": "NA"}, "B": {"name": "RELATIONSHIP_TYPES", "role": "NA"}, "relation": "depends_on", "justification": "CYPHER_QUERY requires an understanding of RELATIONSHIP_TYPES to effectively query relationships between nodes in a graph database.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 32, "label_hint": "title-and-movie-matrix-born", "chunk_id": "10-Neo4J-Part 1__0010", "lecture_id": "10-Neo4J-Part 1", "text": "```\n() (matrix) (:Movie) (matrix:Movie) (matrix:Movie {title: \"The Matrix\"}) (matrix:Movie {title: \"The Matrix\", released: 1997})\n```"}, {"source": "cluster_A", "cluster_id": 32, "label_hint": "title-and-movie-matrix-born", "chunk_id": "10-Neo4J-Part 1__0011", "lecture_id": "10-Neo4J-Part 1", "text": "```\nMATCH (node:Label) WHERE node.property = {value} RETURN node.property\n```\n- Find 'Apollo 13' movie\n- Find 1990's movies\n```\nMATCH (n:Movie {title:\"Apollo 13\"}) RETURN n.released;\n```\n```\nMATCH (n:Movie) WHERE n.released >= 1990 AND n.released <=2000 RETURN I n;\n```"}, {"source": "cluster_B", "cluster_id": 32, "label_hint": "title-and-movie-matrix-born", "chunk_id": "11-Neo4J-Part2__0002", "lecture_id": "11-Neo4J-Part2", "text": "- UNION combines the results of two statements that have the same result structure\nEquivalent Query MATCH (p:Person)-[r:ACTED_IN]->(m:Movie) RETuRN p.name as name, type(r) as Acted_Directed, m.title as title UNION MATCH (p:Person)-[r:DIRECTED]->(m:Movie) RETURNp.name as name type(r) as Acted_Directed, m.title as title MATCH (actor:Person)-[r:ACTED_INI DIRECTED]->(movie:Movie) RETURN actor.name AS name, type(r) AS acted_in, movie.title AS title\n\"name\", 1 = \"Acted_Directed\"|\"title\". \"name\", 2 = . \"Nathan Lane\", 1 = \"ACTED_IN\". \"Nathan Lane\", 2 = \"JoeVersustheVolcano\". \"Tom Hanks\", 1 = \"ACTED_IN\". \"Tom Hanks\", 2 = \"Joe Versus the Volcano\". \"Meg Ryan\", 1 = \"ACTED_IN\". \"Meg Ryan\", 2 = \"Joe Versus the Volcano\". \"Lilly Wachowski\", 1 = \"DIRECTED\". \"Lilly Wachowski\", 2 = \"The Matrix\". \"Lana Wachowski\", 1 = \"DIRECTED\". \"Lana Wachowski\", 2 = \"The Matrix\". \"Rob Reiner\", 1 = \"DIRECTED\". \"Rob Reiner\", 2 = \"When Harry Met Sally\"\n4\nSource: https://neo4j.com/developer/cypher-query-language/"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 2, "lecture_id": "11-Neo4J-Part2", "chunk_id": "11-Neo4J-Part2__0002"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0010"}, "gap_lectures": -1}}}
{"A": {"name": "DATABASE_DESIGN", "role": "NA"}, "B": {"name": "DATABASE_NORMALIZATION", "role": "NA"}, "relation": "depends_on", "justification": "DATABASE_NORMALIZATION is introduced before DATABASE_DESIGN in the lecture sequence, indicating that normalization is a prerequisite for effective database design.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 2, "label_hint": "dnum-and-dname-st-dmgr", "chunk_id": "13-NFs-FDs__0017", "lecture_id": "13-NFs-FDs", "text": "caused by 'troublesome' FDs\nEMP(name, SSN, birthdate, address, dnum, dname, dmgr)"}, {"source": "cluster_B", "cluster_id": 2, "label_hint": "dnum-and-dname-st-dmgr", "chunk_id": "13-NFs-FDs__0022", "lecture_id": "13-NFs-FDs", "text": "New-EMP(name, SSN, birthdate, address, dnum)\nInsert anomalies: No Problem\n```\nJohn    111 June 3     123 St.      D1 Sue     222 May 15    455 St.       D1 Max    333 Mar. 5      678 St.      D2 Wei     444 May 2      999 St.      D2 Tom    555 June 22   888 St.      D2\n```\nDept(dnum,  dname,  dmgr)\nD1         sales        222\nD2        research  333\nLess redundancy!\nDelete anomalies: No Problem"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0006"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0004"}, "gap_lectures": 3}}}
{"A": {"name": "DATABASE_DESIGN", "role": "NA"}, "B": {"name": "DATABASE_RELATIONS", "role": "NA"}, "relation": "part_of", "justification": "DATABASE_RELATIONS are specific components within the broader concept of DATABASE_DESIGN, as evidenced by the discussion of relations like 'Project' and 'Employee' within the context of database design.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0018", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nMgrSSN is a foreign key (referencing the Employee relation)\nvalue of Manager must match an SSN\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nvs.\nProject(P-number, P-name, Due-Date)\nEmployee(SSN, E-Name, Office)\nManager(P-number, SSN)\nWhat are the tradeoffs between these two?\nNote: P-number is the key for Manager"}, {"source": "cluster_B", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design__0018", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nMgrSSN is a foreign key (referencing the Employee relation)\nvalue of Manager must match an SSN\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nvs.\nProject(P-number, P-name, Due-Date)\nEmployee(SSN, E-Name, Office)\nManager(P-number, SSN)\nWhat are the tradeoffs between these two?\nNote: P-number is the key for Manager"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0011"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0004"}, "gap_lectures": 0}}}
{"A": {"name": "DATABASE_DESIGN", "role": "NA"}, "B": {"name": "DATA_NORMALIZATION", "role": "NA"}, "relation": "depends_on", "justification": "B (DATA_NORMALIZATION) is introduced to address redundancy issues in database design, indicating that DATA_NORMALIZATION is a necessary step in the process of DATABASE_DESIGN.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 2, "label_hint": "dnum-and-dname-st-dmgr", "chunk_id": "13-NFs-FDs__0017", "lecture_id": "13-NFs-FDs", "text": "caused by 'troublesome' FDs\nEMP(name, SSN, birthdate, address, dnum, dname, dmgr)"}, {"source": "cluster_B", "cluster_id": 2, "label_hint": "dnum-and-dname-st-dmgr", "chunk_id": "13-NFs-FDs__0016", "lecture_id": "13-NFs-FDs", "text": "EMP(name, SSN, birthdate, address, dnum, dname, dmgr)\nJohn 111 June 3 123 St.      D1     sales     222\nSue 222 May 15 455 St.     D1     sales     222\nMax       333 Mar. 5 678 St.     D2    research 333\nWei 444 May 2 999 St.     D2    research 333\nTom 555 June 22 888 St.     D2    research 333\ndname and dmgr are stored redundantly - whenever there are multiple employees in a department.\nThis redundancy is caused by what we informally call 'troublesome' FDs. The FDs shown in blue are 'troublesome'."}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 2, "reason": "A and B appear in different chunks within 2 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0018"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0004"}, "gap_lectures": 0}}}
{"A": {"name": "DATABASE_DESIGN", "role": "NA"}, "B": {"name": "ENTITY", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly establish a 'depends_on' or 'part_of' relationship between DATABASE_DESIGN and ENTITY. The evidence focuses on specific schema definitions and foreign key relationships without explicitly linking ENTITY as a prerequisite or component of DATABASE_DESIGN.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0018", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nMgrSSN is a foreign key (referencing the Employee relation)\nvalue of Manager must match an SSN\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nvs.\nProject(P-number, P-name, Due-Date)\nEmployee(SSN, E-Name, Office)\nManager(P-number, SSN)\nWhat are the tradeoffs between these two?\nNote: P-number is the key for Manager"}, {"source": "cluster_B", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0016", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nWhat are the attributes and what is the key for Assignment?\n```\nProject(P-number, P-name, Due-Date) Employee(SSN, E-Name, Office)\n```\nProject\nP-number P-name Due-Date\nEmployee\nSSN\nE-Name\nOffice\n0..*     Assignment      0..*\n- 0..*        Manager        1..1\nAnswer: Assignment(P-Number, SSN)\nP-Number is a foreign key for Project SSN is a foreign key for Employee\nProject(P-Number, P-Due-Date)\nEmployee(SSN, E-Name, Office)"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0005"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0004"}, "gap_lectures": 0}}}
{"A": {"name": "DATABASE_DESIGN", "role": "NA"}, "B": {"name": "FOREIGN_KEYS", "role": "NA"}, "relation": "depends_on", "justification": "FOREIGN_KEYS are introduced as a solution to enforce 'troublesome' FDs in the context of DATABASE_DESIGN, indicating that FOREIGN_KEYS are a necessary component to properly design a database.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 2, "label_hint": "dnum-and-dname-st-dmgr", "chunk_id": "13-NFs-FDs__0017", "lecture_id": "13-NFs-FDs", "text": "caused by 'troublesome' FDs\nEMP(name, SSN, birthdate, address, dnum, dname, dmgr)"}, {"source": "cluster_B", "cluster_id": 2, "label_hint": "dnum-and-dname-st-dmgr", "chunk_id": "13-NFs-FDs__0021", "lecture_id": "13-NFs-FDs", "text": "Dept(dnum, dname, dmgr)\n1. Lift the 'troublesome' FD into its own table with dnum as the key.  Now they will be enforced.\nEMP(name, ssn, birthdate, address, dnum, dname, dmgr)\nNew-Emp(name, ssn, birthdate, address, dnum)\n2. Leave the LHS of the 'troublesome' FDs behind. Define a foreign key where New-Emp.dnum REFERENCES Dept.dnum"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 2, "reason": "A and B appear in different chunks within 2 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0004"}, "gap_lectures": 4}}}
{"A": {"name": "DATABASE_DESIGN", "role": "NA"}, "B": {"name": "FUNCTIONAL_DEPENDENCY", "role": "NA"}, "relation": "depends_on", "justification": "Functional dependencies are a fundamental concept in database design that help identify and resolve issues such as redundancy and update anomalies, which are critical for designing efficient and effective databases.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 2, "label_hint": "dnum-and-dname-st-dmgr", "chunk_id": "13-NFs-FDs__0017", "lecture_id": "13-NFs-FDs", "text": "caused by 'troublesome' FDs\nEMP(name, SSN, birthdate, address, dnum, dname, dmgr)"}, {"source": "cluster_B", "cluster_id": 2, "label_hint": "dnum-and-dname-st-dmgr", "chunk_id": "13-NFs-FDs__0018", "lecture_id": "13-NFs-FDs", "text": "if you want to insert a department, you can't ... until there is at least one employee.\nDeletion anomalies: if you delete an employee, is that dept. gone?  Was this the last employee in that dept.?\nUpdate anomalies: If you want to change dname , for example, you need to change it everywhere!  And you have to find them all first.\nTroublesome FDs cause (redundancy and) update anomalies."}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0012"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0004"}, "gap_lectures": -2}}}
{"A": {"name": "DATABASE_DESIGN", "role": "NA"}, "B": {"name": "REDUNDANCY_REDUCTION", "role": "NA"}, "relation": "depends_on", "justification": "Redundancy reduction (B) builds upon the foundational concepts of database design (A) by addressing issues such as insert and delete anomalies that arise from 'troublesome' FDs in the context of database design.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 2, "label_hint": "dnum-and-dname-st-dmgr", "chunk_id": "13-NFs-FDs__0017", "lecture_id": "13-NFs-FDs", "text": "caused by 'troublesome' FDs\nEMP(name, SSN, birthdate, address, dnum, dname, dmgr)"}, {"source": "cluster_B", "cluster_id": 2, "label_hint": "dnum-and-dname-st-dmgr", "chunk_id": "13-NFs-FDs__0022", "lecture_id": "13-NFs-FDs", "text": "New-EMP(name, SSN, birthdate, address, dnum)\nInsert anomalies: No Problem\n```\nJohn    111 June 3     123 St.      D1 Sue     222 May 15    455 St.       D1 Max    333 Mar. 5      678 St.      D2 Wei     444 May 2      999 St.      D2 Tom    555 June 22   888 St.      D2\n```\nDept(dnum,  dname,  dmgr)\nD1         sales        222\nD2        research  333\nLess redundancy!\nDelete anomalies: No Problem"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0019"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0004"}, "gap_lectures": -2}}}
{"A": {"name": "DATABASE_DESIGN", "role": "NA"}, "B": {"name": "RELATIONSHIP", "role": "NA"}, "relation": "depends_on", "justification": "The evidence shows that understanding the concept of 'RELATIONSHIP' is necessary before delving into 'DATABASE_DESIGN', as 'RELATIONSHIP' is discussed in the context of defining foreign keys and keys for tables, which are foundational concepts in database design.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0018", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nMgrSSN is a foreign key (referencing the Employee relation)\nvalue of Manager must match an SSN\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nvs.\nProject(P-number, P-name, Due-Date)\nEmployee(SSN, E-Name, Office)\nManager(P-number, SSN)\nWhat are the tradeoffs between these two?\nNote: P-number is the key for Manager"}, {"source": "cluster_B", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0016", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nWhat are the attributes and what is the key for Assignment?\n```\nProject(P-number, P-name, Due-Date) Employee(SSN, E-Name, Office)\n```\nProject\nP-number P-name Due-Date\nEmployee\nSSN\nE-Name\nOffice\n0..*     Assignment      0..*\n- 0..*        Manager        1..1\nAnswer: Assignment(P-Number, SSN)\nP-Number is a foreign key for Project SSN is a foreign key for Employee\nProject(P-Number, P-Due-Date)\nEmployee(SSN, E-Name, Office)"}, {"source": "cluster_B", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design__0016", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nWhat are the attributes and what is the key for Assignment?\n```\nProject(P-number, P-name, Due-Date) Employee(SSN, E-Name, Office)\n```\nProject\nP-number P-name Due-Date\nEmployee\nSSN\nE-Name\nOffice\n0..*     Assignment      0..*\n- 0..*        Manager        1..1\nAnswer: Assignment(P-Number, SSN)\nP-Number is a foreign key for Project SSN is a foreign key for Employee\nProject(P-Number, P-Due-Date)\nEmployee(SSN, E-Name, Office)"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0005"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0004"}, "gap_lectures": 0}}}
{"A": {"name": "DATABASE_DESIGN", "role": "NA"}, "B": {"name": "RELATIONSHIP_TYPES", "role": "NA"}, "relation": null, "justification": "There is no clear evidence that DATABASE_DESIGN depends_on or part_of RELATIONSHIP_TYPES based on the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 80, "label_hint": "uml-and-omg-draft-proposed", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0004", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- UML is a standard language for designing software systems\n- also used for DB design\n- created by the Object Management Group (OMG)\n- UML 1.0 specification draft was proposed to the OMG in early 1997."}, {"source": "cluster_A", "cluster_id": 80, "label_hint": "uml-and-omg-draft-proposed", "chunk_id": "12-Conceptual_Logical_DB_Design__0004", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- UML is a standard language for designing software systems\n- also used for DB design\n- created by the Object Management Group (OMG)\n- UML 1.0 specification draft was proposed to the OMG in early 1997."}, {"source": "cluster_B", "cluster_id": 80, "label_hint": "uml-and-omg-draft-proposed", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0008", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "UML notation"}, {"source": "cluster_B", "cluster_id": 80, "label_hint": "uml-and-omg-draft-proposed", "chunk_id": "12-Conceptual_Logical_DB_Design__0008", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "UML notation"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 2, "lecture_id": "11-Neo4J-Part2", "chunk_id": "11-Neo4J-Part2__0002"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0004"}, "gap_lectures": 2}}}
{"A": {"name": "DATABASE_DESIGN", "role": "NA"}, "B": {"name": "UPDATE_ANOMALIES", "role": "NA"}, "relation": "depends_on", "justification": "Understanding database design (A) is a prerequisite for recognizing update anomalies (B) as they arise from issues in the design of the database schema.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 2, "label_hint": "dnum-and-dname-st-dmgr", "chunk_id": "13-NFs-FDs__0017", "lecture_id": "13-NFs-FDs", "text": "caused by 'troublesome' FDs\nEMP(name, SSN, birthdate, address, dnum, dname, dmgr)"}, {"source": "cluster_B", "cluster_id": 2, "label_hint": "dnum-and-dname-st-dmgr", "chunk_id": "13-NFs-FDs__0020", "lecture_id": "13-NFs-FDs", "text": "EMP(name, ssn, birthdate, address, dnum, dname, dmgr)\nWe have a problem! dnum is NOT the key for this table!\nSo these blue FDs will not be enforced automatically by the DBMS (using only keys). And there can be redundancy and update anomalies"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0014"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0004"}, "gap_lectures": -2}}}
{"A": {"name": "DATABASE_NORMALIZATION", "role": "NA"}, "B": {"name": "DATA_NORMALIZATION", "role": "NA"}, "relation": null, "justification": "No decision (LLM output invalid).", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 2, "label_hint": "dnum-and-dname-st-dmgr", "chunk_id": "13-NFs-FDs__0022", "lecture_id": "13-NFs-FDs", "text": "New-EMP(name, SSN, birthdate, address, dnum)\nInsert anomalies: No Problem\n```\nJohn    111 June 3     123 St.      D1 Sue     222 May 15    455 St.       D1 Max    333 Mar. 5      678 St.      D2 Wei     444 May 2      999 St.      D2 Tom    555 June 22   888 St.      D2\n```\nDept(dnum,  dname,  dmgr)\nD1         sales        222\nD2        research  333\nLess redundancy!\nDelete anomalies: No Problem"}, {"source": "cluster_B", "cluster_id": 2, "label_hint": "dnum-and-dname-st-dmgr", "chunk_id": "13-NFs-FDs__0016", "lecture_id": "13-NFs-FDs", "text": "EMP(name, SSN, birthdate, address, dnum, dname, dmgr)\nJohn 111 June 3 123 St.      D1     sales     222\nSue 222 May 15 455 St.     D1     sales     222\nMax       333 Mar. 5 678 St.     D2    research 333\nWei 444 May 2 999 St.     D2    research 333\nTom 555 June 22 888 St.     D2    research 333\ndname and dmgr are stored redundantly - whenever there are multiple employees in a department.\nThis redundancy is caused by what we informally call 'troublesome' FDs. The FDs shown in blue are 'troublesome'."}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0018"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0006"}, "gap_lectures": -3}, "_error": "Unbalanced JSON braces in output."}}
{"A": {"name": "DATABASE_NORMALIZATION", "role": "NA"}, "B": {"name": "FOREIGN_KEYS", "role": "NA"}, "relation": "depends_on", "justification": "DATABASE_NORMALIZATION requires the understanding of FOREIGN_KEYS to ensure referential integrity and avoid anomalies in database design.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 2, "label_hint": "dnum-and-dname-st-dmgr", "chunk_id": "13-NFs-FDs__0022", "lecture_id": "13-NFs-FDs", "text": "New-EMP(name, SSN, birthdate, address, dnum)\nInsert anomalies: No Problem\n```\nJohn    111 June 3     123 St.      D1 Sue     222 May 15    455 St.       D1 Max    333 Mar. 5      678 St.      D2 Wei     444 May 2      999 St.      D2 Tom    555 June 22   888 St.      D2\n```\nDept(dnum,  dname,  dmgr)\nD1         sales        222\nD2        research  333\nLess redundancy!\nDelete anomalies: No Problem"}, {"source": "cluster_B", "cluster_id": 2, "label_hint": "dnum-and-dname-st-dmgr", "chunk_id": "13-NFs-FDs__0021", "lecture_id": "13-NFs-FDs", "text": "Dept(dnum, dname, dmgr)\n1. Lift the 'troublesome' FD into its own table with dnum as the key.  Now they will be enforced.\nEMP(name, ssn, birthdate, address, dnum, dname, dmgr)\nNew-Emp(name, ssn, birthdate, address, dnum)\n2. Leave the LHS of the 'troublesome' FDs behind. Define a foreign key where New-Emp.dnum REFERENCES Dept.dnum"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0006"}, "gap_lectures": 1}}}
{"A": {"name": "DATABASE_NORMALIZATION", "role": "NA"}, "B": {"name": "FUNCTIONAL_DEPENDENCY", "role": "NA"}, "relation": "depends_on", "justification": "Functional dependencies are a foundational concept used in understanding and resolving issues related to database normalization, such as insertion, deletion, and update anomalies.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 2, "label_hint": "dnum-and-dname-st-dmgr", "chunk_id": "13-NFs-FDs__0022", "lecture_id": "13-NFs-FDs", "text": "New-EMP(name, SSN, birthdate, address, dnum)\nInsert anomalies: No Problem\n```\nJohn    111 June 3     123 St.      D1 Sue     222 May 15    455 St.       D1 Max    333 Mar. 5      678 St.      D2 Wei     444 May 2      999 St.      D2 Tom    555 June 22   888 St.      D2\n```\nDept(dnum,  dname,  dmgr)\nD1         sales        222\nD2        research  333\nLess redundancy!\nDelete anomalies: No Problem"}, {"source": "cluster_B", "cluster_id": 2, "label_hint": "dnum-and-dname-st-dmgr", "chunk_id": "13-NFs-FDs__0018", "lecture_id": "13-NFs-FDs", "text": "if you want to insert a department, you can't ... until there is at least one employee.\nDeletion anomalies: if you delete an employee, is that dept. gone?  Was this the last employee in that dept.?\nUpdate anomalies: If you want to change dname , for example, you need to change it everywhere!  And you have to find them all first.\nTroublesome FDs cause (redundancy and) update anomalies."}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0012"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0006"}, "gap_lectures": -5}}}
{"A": {"name": "DATABASE_NORMALIZATION", "role": "NA"}, "B": {"name": "NORMALIZATION", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly establish a 'depends_on' or 'part_of' relationship between DATABASE_NORMALIZATION and NORMALIZATION.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 2, "label_hint": "dnum-and-dname-st-dmgr", "chunk_id": "13-NFs-FDs__0022", "lecture_id": "13-NFs-FDs", "text": "New-EMP(name, SSN, birthdate, address, dnum)\nInsert anomalies: No Problem\n```\nJohn    111 June 3     123 St.      D1 Sue     222 May 15    455 St.       D1 Max    333 Mar. 5      678 St.      D2 Wei     444 May 2      999 St.      D2 Tom    555 June 22   888 St.      D2\n```\nDept(dnum,  dname,  dmgr)\nD1         sales        222\nD2        research  333\nLess redundancy!\nDelete anomalies: No Problem"}, {"source": "cluster_B", "cluster_id": 2, "label_hint": "dnum-and-dname-st-dmgr", "chunk_id": "13-NFs-FDs__0017", "lecture_id": "13-NFs-FDs", "text": "caused by 'troublesome' FDs\nEMP(name, SSN, birthdate, address, dnum, dname, dmgr)"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0000"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0006"}, "gap_lectures": 0}}}
{"A": {"name": "DATABASE_NORMALIZATION", "role": "NA"}, "B": {"name": "UPDATE_ANOMALIES", "role": "NA"}, "relation": "depends_on", "justification": "Normalization is a prerequisite for understanding and mitigating update anomalies, as the evidence shows that without proper normalization, there can be redundancy and update anomalies in the database.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 2, "label_hint": "dnum-and-dname-st-dmgr", "chunk_id": "13-NFs-FDs__0022", "lecture_id": "13-NFs-FDs", "text": "New-EMP(name, SSN, birthdate, address, dnum)\nInsert anomalies: No Problem\n```\nJohn    111 June 3     123 St.      D1 Sue     222 May 15    455 St.       D1 Max    333 Mar. 5      678 St.      D2 Wei     444 May 2      999 St.      D2 Tom    555 June 22   888 St.      D2\n```\nDept(dnum,  dname,  dmgr)\nD1         sales        222\nD2        research  333\nLess redundancy!\nDelete anomalies: No Problem"}, {"source": "cluster_B", "cluster_id": 2, "label_hint": "dnum-and-dname-st-dmgr", "chunk_id": "13-NFs-FDs__0020", "lecture_id": "13-NFs-FDs", "text": "EMP(name, ssn, birthdate, address, dnum, dname, dmgr)\nWe have a problem! dnum is NOT the key for this table!\nSo these blue FDs will not be enforced automatically by the DBMS (using only keys). And there can be redundancy and update anomalies"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0014"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0006"}, "gap_lectures": -5}}}
{"A": {"name": "DATABASE_QUERY", "role": "NA"}, "B": {"name": "DISTINCT_RESULTS", "role": "NA"}, "relation": "depends_on", "justification": "DISTINCT_RESULTS is used as a specific operation within a DATABASE_QUERY to ensure unique results, indicating that understanding DATABASE_QUERY is a prerequisite for using DISTINCT_RESULTS.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 94, "label_hint": "product-and-od-products-orderid", "chunk_id": "11-Neo4J-Part2__0012", "lecture_id": "11-Neo4J-Part2", "text": "- Select everything from the products table\nSELECT p.* FROM products as p;\nSQL\nMATCH (p:Product) RETURN p;\nCypher"}, {"source": "cluster_B", "cluster_id": 94, "label_hint": "product-and-od-products-orderid", "chunk_id": "11-Neo4J-Part2__0016", "lecture_id": "11-Neo4J-Part2", "text": "SELECT DISTINCT c.CompanyName\nFROM customers AS c JOIN orders AS o ON (c.CustomerID = o.CustomerID)\nJOIN order_details AS od ON (o.OrderID = od.OrderID)\nJOIN products AS p ON (od.ProductID = p.ProductID)\nWHERE p.ProductName = 'Chocolate';\nMATCH (p:Product {productName:\"Chocolate\"})<[:PRODUCT]-(:Order)<-[:PURCHASED]-(c:Customer) RETURN distinct c.companyName;\nSource: https://neo4j.com/developer/cypher-query-language/"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 2, "lecture_id": "11-Neo4J-Part2", "chunk_id": "11-Neo4J-Part2__0016"}, "A_first_introduced_at": {"lecture_index": 2, "lecture_id": "11-Neo4J-Part2", "chunk_id": "11-Neo4J-Part2__0012"}, "gap_lectures": 0}}}
{"A": {"name": "DATABASE_QUERY", "role": "NA"}, "B": {"name": "GROUP_BY", "role": "NA"}, "relation": "depends_on", "justification": "B (GROUP_BY) is used in a more advanced query that builds upon the basic query introduced in A (DATABASE_QUERY). GROUP_BY is used to aggregate data by a specific column, which is a more complex operation that depends on understanding basic database queries.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 125, "label_hint": "price-and-drink-sells-cafe", "chunk_id": "5- SQL4-AggGrpViews__0003", "lecture_id": "5- SQL4-AggGrpViews", "text": "- From Sells(cafe, drink, price), find the average price of Mocha:\n```\nSELECT AVG(price) FROM Sells WHERE drink = ' Mocha ' ;\n```"}, {"source": "cluster_B", "cluster_id": 125, "label_hint": "price-and-drink-sells-cafe", "chunk_id": "5- SQL4-AggGrpViews__0007", "lecture_id": "5- SQL4-AggGrpViews", "text": "- From Sells(cafe, drink, price), find the average price for each drink:\n```\nSELECT drink, AVG(price) FROM Sells GROUP BY drink;\n```\n工\n- From Sells(cafe, drink, price) and Frequents(customer, cafe), find for each customer the average price of Mocha at the cafes they frequent:\nI ILLINOIS"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 14, "lecture_id": "23-Rule-basedOpt", "chunk_id": "23-Rule-basedOpt__0001"}, "A_first_introduced_at": {"lecture_index": 2, "lecture_id": "11-Neo4J-Part2", "chunk_id": "11-Neo4J-Part2__0012"}, "gap_lectures": -12}}}
{"A": {"name": "DATABASE_QUERY", "role": "NA"}, "B": {"name": "READ", "role": "NA"}, "relation": "depends_on", "justification": "DATABASE_QUERY involves operations that read data from a database, implying that the concept of READ is a prerequisite for understanding DATABASE_QUERY.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 105, "label_hint": "people-and-db-john-collection", "chunk_id": "8- NoSQL-MongoDB-Basics__0025", "lecture_id": "8- NoSQL-MongoDB-Basics", "text": "- db.people.find({ ' name.first ' : ' John ' })\n- Finds all people with first name John\n- db.people.find({ ' name.first ' : ' John ' , ' name.last ' : ' Smith ' })\n- Finds all people with first name John and last name Smith.\n- Contrast with\n```\ndb.people.find({ ' name ' :  { ' first ' : ' John ' , ' last ' : ' Smith ' }})\n```\nI IlLINOIS\nA. Alawini\n23"}, {"source": "cluster_B", "cluster_id": 105, "label_hint": "people-and-db-john-collection", "chunk_id": "8- NoSQL-MongoDB-Basics__0016", "lecture_id": "8- NoSQL-MongoDB-Basics", "text": "- CRUD: create , read , update ,  and delete\n- Insert\n- One at a time:  db.people.insert(mydoc)\n- New (version 3.2): db.collection.insertOne(), db.collection.insertMany()\n- Delete\n- Documents that match some predicate, e.g. to remove the document in the previous slide:\n- All documents in a collection:  db.people.deleteMany()\n- The collection still remains, with indexes\n- Remove a collection (faster):  db.people.drop()\n```\ndb.people.deleteOne({ ' _id ' :  1}) db.people.deleteMany({ birthyear: 1924 })\n```\nI IlLINOIS\nA. Alawini\n14"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0019"}, "A_first_introduced_at": {"lecture_index": 2, "lecture_id": "11-Neo4J-Part2", "chunk_id": "11-Neo4J-Part2__0012"}, "gap_lectures": -9}}}
{"A": {"name": "DATABASE_QUERY", "role": "NA"}, "B": {"name": "REFERENTIAL_INTEGRITY", "role": "NA"}, "relation": "depends_on", "justification": "Referential integrity is a fundamental concept in database management that ensures the consistency and accuracy of data relationships. Understanding referential integrity is crucial before performing database queries that involve relationships between tables, such as the delete operation mentioned in the evidence for DATABASE_QUERY.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 114, "label_hint": "drink-and-mocha-drinks-sells", "chunk_id": "6- SQL5-DBUpdatesSPs__0008", "lecture_id": "6- SQL5-DBUpdatesSPs", "text": "- Delete from Likes (customer, drink) the fact that Sally likes Latte:\n```\nDELETE FROM Likes WHERE customer = ' Sally ' AND drink = ' Latte ' ;\n```\nI ILLINOIS\n工"}, {"source": "cluster_B", "cluster_id": 114, "label_hint": "drink-and-mocha-drinks-sells", "chunk_id": "7- ConstraintsTriggers__0008", "lecture_id": "7- ConstraintsTriggers", "text": "- Suppose R = Sells, S = Drinks.\n- Referencing relation changes:\n- An insert or update to Sells that introduces a nonexistent drink must be rejected.\n- Referenced relation changes:\n- A deletion or update to Drinks that removes a drink value found in some tuples of Sells can be handled in three ways."}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0015"}, "A_first_introduced_at": {"lecture_index": 2, "lecture_id": "11-Neo4J-Part2", "chunk_id": "11-Neo4J-Part2__0012"}, "gap_lectures": 2}}}
{"A": {"name": "DATABASE_QUERY", "role": "NA"}, "B": {"name": "SET_OPERATIONS", "role": "NA"}, "relation": "depends_on", "justification": "DATABASE_QUERY appears to be a more basic concept introduced earlier in the course, while SET_OPERATIONS are more advanced and build upon the foundational knowledge of database queries.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 124, "label_hint": "price-and-cafe-bene-latte", "chunk_id": "2-SQL-Basics__0010", "lecture_id": "2-SQL-Basics", "text": "-  From Sells (cafe, drink, priceȌ, find the price Caffe bene charges for Mocha:\n```\nSELECT SULce FROM SeOOV WHERE cafe = 'Caffe bene' AND dULQN = ' MRcKa ' ;\n```"}, {"source": "cluster_B", "cluster_id": 124, "label_hint": "price-and-cafe-bene-latte", "chunk_id": "4-AdvSQL-SubqueriesSetOps__0005", "lecture_id": "4-AdvSQL-SubqueriesSetOps", "text": "Find the café shops that serve Latte at that price\n```\nSELECT cafe FROM Sells WHERE drink = 'Latte' AND price = (SELECT price FROM Sells WHERE cafe = 'Espresso Royal' AND drink = 'Cappuccino');\n```\nFind the price Espresso Royal charges for Cappuccino.\n- Advanced SQL\n-  Subqueries\n- Boolean Operators (IN, ANY, EXISTS, ALL)\n- Set operations"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0011"}, "A_first_introduced_at": {"lecture_index": 2, "lecture_id": "11-Neo4J-Part2", "chunk_id": "11-Neo4J-Part2__0012"}, "gap_lectures": -10}}}
{"A": {"name": "DATABASE_RELATIONS", "role": "NA"}, "B": {"name": "ENTITY", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly establish a 'depends_on' or 'part_of' relationship between DATABASE_RELATIONS and ENTITY.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design__0018", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nMgrSSN is a foreign key (referencing the Employee relation)\nvalue of Manager must match an SSN\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nvs.\nProject(P-number, P-name, Due-Date)\nEmployee(SSN, E-Name, Office)\nManager(P-number, SSN)\nWhat are the tradeoffs between these two?\nNote: P-number is the key for Manager"}, {"source": "cluster_B", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0016", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nWhat are the attributes and what is the key for Assignment?\n```\nProject(P-number, P-name, Due-Date) Employee(SSN, E-Name, Office)\n```\nProject\nP-number P-name Due-Date\nEmployee\nSSN\nE-Name\nOffice\n0..*     Assignment      0..*\n- 0..*        Manager        1..1\nAnswer: Assignment(P-Number, SSN)\nP-Number is a foreign key for Project SSN is a foreign key for Employee\nProject(P-Number, P-Due-Date)\nEmployee(SSN, E-Name, Office)"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0005"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0011"}, "gap_lectures": 0}}}
{"A": {"name": "DATABASE_RELATIONS", "role": "NA"}, "B": {"name": "FOREIGN_KEY", "role": "NA"}, "relation": "part_of", "justification": "FOREIGN_KEY is a specific concept within the broader topic of DATABASE_RELATIONS, as evidenced by its use in defining relationships between database tables.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design__0018", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nMgrSSN is a foreign key (referencing the Employee relation)\nvalue of Manager must match an SSN\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nvs.\nProject(P-number, P-name, Due-Date)\nEmployee(SSN, E-Name, Office)\nManager(P-number, SSN)\nWhat are the tradeoffs between these two?\nNote: P-number is the key for Manager"}, {"source": "cluster_B", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0016", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nWhat are the attributes and what is the key for Assignment?\n```\nProject(P-number, P-name, Due-Date) Employee(SSN, E-Name, Office)\n```\nProject\nP-number P-name Due-Date\nEmployee\nSSN\nE-Name\nOffice\n0..*     Assignment      0..*\n- 0..*        Manager        1..1\nAnswer: Assignment(P-Number, SSN)\nP-Number is a foreign key for Project SSN is a foreign key for Employee\nProject(P-Number, P-Due-Date)\nEmployee(SSN, E-Name, Office)"}, {"source": "cluster_B", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0018", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nMgrSSN is a foreign key (referencing the Employee relation)\nvalue of Manager must match an SSN\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nvs.\nProject(P-number, P-name, Due-Date)\nEmployee(SSN, E-Name, Office)\nManager(P-number, SSN)\nWhat are the tradeoffs between these two?\nNote: P-number is the key for Manager"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0000"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0011"}, "gap_lectures": 4}}}
{"A": {"name": "DATABASE_RELATIONS", "role": "NA"}, "B": {"name": "RELATIONSHIP", "role": "NA"}, "relation": "part_of", "justification": "DATABASE_RELATIONS is a broader concept that encompasses various types of relationships within a database, including foreign keys and primary keys, as seen in the evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design__0018", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nMgrSSN is a foreign key (referencing the Employee relation)\nvalue of Manager must match an SSN\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nvs.\nProject(P-number, P-name, Due-Date)\nEmployee(SSN, E-Name, Office)\nManager(P-number, SSN)\nWhat are the tradeoffs between these two?\nNote: P-number is the key for Manager"}, {"source": "cluster_B", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0016", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nWhat are the attributes and what is the key for Assignment?\n```\nProject(P-number, P-name, Due-Date) Employee(SSN, E-Name, Office)\n```\nProject\nP-number P-name Due-Date\nEmployee\nSSN\nE-Name\nOffice\n0..*     Assignment      0..*\n- 0..*        Manager        1..1\nAnswer: Assignment(P-Number, SSN)\nP-Number is a foreign key for Project SSN is a foreign key for Employee\nProject(P-Number, P-Due-Date)\nEmployee(SSN, E-Name, Office)"}, {"source": "cluster_B", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design__0016", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nWhat are the attributes and what is the key for Assignment?\n```\nProject(P-number, P-name, Due-Date) Employee(SSN, E-Name, Office)\n```\nProject\nP-number P-name Due-Date\nEmployee\nSSN\nE-Name\nOffice\n0..*     Assignment      0..*\n- 0..*        Manager        1..1\nAnswer: Assignment(P-Number, SSN)\nP-Number is a foreign key for Project SSN is a foreign key for Employee\nProject(P-Number, P-Due-Date)\nEmployee(SSN, E-Name, Office)"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0005"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0011"}, "gap_lectures": 0}}}
{"A": {"name": "DATABASE_SCHEMA", "role": "NA"}, "B": {"name": "DATABASE_TUNING", "role": "NA"}, "relation": "depends_on", "justification": "DATABASE_SCHEMA is introduced before DATABASE_TUNING in the course sequence and is a prerequisite for understanding DATABASE_TUNING.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "13-NFs-FDs__0003", "lecture_id": "13-NFs-FDs", "text": "- Start with the original db schema R\n- From ER translation or otherwise\n- Identify its functional dependencies\n- Use them to transform R until we get a good design R*"}, {"source": "cluster_B", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0000", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "cluster_B", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "12-Conceptual_Logical_DB_Design__0000", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "cluster_B", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "13-NFs-FDs__0001", "lecture_id": "13-NFs-FDs", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "A_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0003"}, "gap_lectures": 2}}}
{"A": {"name": "DATABASE_SCHEMA", "role": "NA"}, "B": {"name": "ENTITIES_RELATIONSHIPS", "role": "NA"}, "relation": "depends_on", "justification": "B (ENTITIES_RELATIONSHIPS) is introduced before A (DATABASE_SCHEMA) and is used as a foundational step in the design process that leads to A. The evidence shows that entities and relationships are identified in the conceptual design phase, which is a prerequisite for transforming the ER design into a relational schema.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "13-NFs-FDs__0003", "lecture_id": "13-NFs-FDs", "text": "- Start with the original db schema R\n- From ER translation or otherwise\n- Identify its functional dependencies\n- Use them to transform R until we get a good design R*"}, {"source": "cluster_B", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0000", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "cluster_B", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "12-Conceptual_Logical_DB_Design__0000", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "cluster_B", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "13-NFs-FDs__0001", "lecture_id": "13-NFs-FDs", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "A_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0003"}, "gap_lectures": 2}}}
{"A": {"name": "DATABASE_SCHEMA", "role": "NA"}, "B": {"name": "INDEXING", "role": "NA"}, "relation": "depends_on", "justification": "Indexing is discussed after the schema refinement and normalization process, indicating that understanding database schema is a prerequisite for learning about indexing.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "13-NFs-FDs__0003", "lecture_id": "13-NFs-FDs", "text": "- Start with the original db schema R\n- From ER translation or otherwise\n- Identify its functional dependencies\n- Use them to transform R until we get a good design R*"}, {"source": "cluster_B", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "15-NFs-3NF__0017", "lecture_id": "15-NFs-3NF", "text": "- Conceptual design:  (ER & UML Models are used\n- for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\nWe'll discuss indexing next.\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 2, "lecture_id": "11-Neo4J-Part2", "chunk_id": "11-Neo4J-Part2__0005"}, "A_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0003"}, "gap_lectures": 4}}}
{"A": {"name": "DATABASE_SCHEMA", "role": "NA"}, "B": {"name": "LOGICAL_DESIGN", "role": "NA"}, "relation": "depends_on", "justification": "DATABASE_SCHEMA depends on LOGICAL_DESIGN because the process of transforming an ER design to a relational schema (logical design) is a prerequisite for creating a database schema.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "13-NFs-FDs__0003", "lecture_id": "13-NFs-FDs", "text": "- Start with the original db schema R\n- From ER translation or otherwise\n- Identify its functional dependencies\n- Use them to transform R until we get a good design R*"}, {"source": "cluster_B", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0000", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "cluster_B", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "12-Conceptual_Logical_DB_Design__0000", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "cluster_B", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "13-NFs-FDs__0001", "lecture_id": "13-NFs-FDs", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "A_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0003"}, "gap_lectures": 2}}}
{"A": {"name": "DATABASE_SCHEMA", "role": "NA"}, "B": {"name": "PHYSICAL_DESIGN", "role": "NA"}, "relation": "depends_on", "justification": "DATABASE_SCHEMA (A) is introduced as a step in the process of transforming an ER design into a relational schema, which is a prerequisite for Physical Database Design (B).", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "13-NFs-FDs__0003", "lecture_id": "13-NFs-FDs", "text": "- Start with the original db schema R\n- From ER translation or otherwise\n- Identify its functional dependencies\n- Use them to transform R until we get a good design R*"}, {"source": "cluster_B", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0000", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "cluster_B", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "12-Conceptual_Logical_DB_Design__0000", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "cluster_B", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "13-NFs-FDs__0001", "lecture_id": "13-NFs-FDs", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "A_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0003"}, "gap_lectures": 2}}}
{"A": {"name": "DATABASE_SCHEMA", "role": "NA"}, "B": {"name": "RELATIONAL_SCHEMA", "role": "NA"}, "relation": "depends_on", "justification": "DATABASE_SCHEMA (A) appears to depend on RELATIONAL_SCHEMA (B) as the evidence suggests that RELATIONAL_SCHEMA is a foundational concept used in the refinement and normalization of database schemas.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "13-NFs-FDs__0003", "lecture_id": "13-NFs-FDs", "text": "- Start with the original db schema R\n- From ER translation or otherwise\n- Identify its functional dependencies\n- Use them to transform R until we get a good design R*"}, {"source": "cluster_B", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0000", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "cluster_B", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "12-Conceptual_Logical_DB_Design__0000", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "cluster_B", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "13-NFs-FDs__0001", "lecture_id": "13-NFs-FDs", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "A_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0003"}, "gap_lectures": 2}}}
{"A": {"name": "DATABASE_SCHEMA", "role": "NA"}, "B": {"name": "SCHEMA_REFINEMENT", "role": "NA"}, "relation": "depends_on", "justification": "B (SCHEMA_REFINEMENT) is a process that improves and refines A (DATABASE_SCHEMA) to eliminate redundancies and anomalies, indicating that DATABASE_SCHEMA must be understood before SCHEMA_REFINEMENT can be applied.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "13-NFs-FDs__0003", "lecture_id": "13-NFs-FDs", "text": "- Start with the original db schema R\n- From ER translation or otherwise\n- Identify its functional dependencies\n- Use them to transform R until we get a good design R*"}, {"source": "cluster_B", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0000", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "cluster_B", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "12-Conceptual_Logical_DB_Design__0000", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "cluster_B", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "13-NFs-FDs__0001", "lecture_id": "13-NFs-FDs", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "A_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0003"}, "gap_lectures": 2}}}
{"A": {"name": "DATABASE_TUNING", "role": "NA"}, "B": {"name": "FUNCTIONAL_DEPENDENCIES", "role": "NA"}, "relation": "depends_on", "justification": "DATABASE_TUNING appears to require prior knowledge of FUNCTIONAL_DEPENDENCIES for schema refinement and anomaly checking, which are crucial steps before physical database tuning.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0000", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "cluster_A", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "12-Conceptual_Logical_DB_Design__0000", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "cluster_A", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "13-NFs-FDs__0001", "lecture_id": "13-NFs-FDs", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "cluster_B", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "13-NFs-FDs__0003", "lecture_id": "13-NFs-FDs", "text": "- Start with the original db schema R\n- From ER translation or otherwise\n- Identify its functional dependencies\n- Use them to transform R until we get a good design R*"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0003"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "gap_lectures": -2}}}
{"A": {"name": "DATABASE_TUNING", "role": "NA"}, "B": {"name": "INDEXING", "role": "NA"}, "relation": "depends_on", "justification": "DATABASE_TUNING requires INDEXING as a prerequisite because physical database design and tuning involves selecting file types and indexes, which are discussed before tuning is mentioned.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0000", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "cluster_A", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "12-Conceptual_Logical_DB_Design__0000", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "cluster_A", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "13-NFs-FDs__0001", "lecture_id": "13-NFs-FDs", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "cluster_B", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "15-NFs-3NF__0017", "lecture_id": "15-NFs-3NF", "text": "- Conceptual design:  (ER & UML Models are used\n- for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\nWe'll discuss indexing next.\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 2, "lecture_id": "11-Neo4J-Part2", "chunk_id": "11-Neo4J-Part2__0005"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "gap_lectures": 2}}}
{"A": {"name": "DATA_MANAGEMENT", "role": "NA"}, "B": {"name": "DATA_MODELING", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly indicate a dependency or part_of relationship between DATA_MANAGEMENT and DATA_MODELING.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "19-Trxn-Mgmt__0001", "lecture_id": "19-Trxn-Mgmt", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}, {"source": "cluster_A", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "20-Trxn-Serializability__0000", "lecture_id": "20-Trxn-Serializability", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}, {"source": "cluster_A", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "PT1-WS1-DBDesign_GCP__0009", "lecture_id": "PT1-WS1-DBDesign_GCP", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}, {"source": "cluster_B", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "5- SQL4-AggGrpViews__0000", "lecture_id": "5- SQL4-AggGrpViews", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems\n工"}, {"source": "cluster_B", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "7- ConstraintsTriggers__0000", "lecture_id": "7- ConstraintsTriggers", "text": "University of Illinois at Urbana -Champaign CS411: Database Systems\n工"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0006"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0001"}, "gap_lectures": 8}}}
{"A": {"name": "DATA_MANAGEMENT", "role": "NA"}, "B": {"name": "NORMALIZATION", "role": "NA"}, "relation": null, "justification": "There is no clear evidence in the provided text that supports a 'depends_on' or 'part_of' relationship between DATA_MANAGEMENT and NORMALIZATION.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "19-Trxn-Mgmt__0001", "lecture_id": "19-Trxn-Mgmt", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}, {"source": "cluster_A", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "20-Trxn-Serializability__0000", "lecture_id": "20-Trxn-Serializability", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}, {"source": "cluster_A", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "PT1-WS1-DBDesign_GCP__0009", "lecture_id": "PT1-WS1-DBDesign_GCP", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}, {"source": "cluster_B", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "10-Neo4J-Part 1__0000", "lecture_id": "10-Neo4J-Part 1", "text": "University of Illinois at Urbana -Champaign CS411: Database Systems"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0000"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0001"}, "gap_lectures": 8}}}
{"A": {"name": "DATA_MANAGEMENT", "role": "NA"}, "B": {"name": "QUERY_OPTIMIZATION", "role": "NA"}, "relation": "depends_on", "justification": "Query Optimization (B) builds upon the foundational knowledge of Data Management (A) as it involves optimizing the retrieval of data, which is a core aspect of data management.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "19-Trxn-Mgmt__0001", "lecture_id": "19-Trxn-Mgmt", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}, {"source": "cluster_A", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "20-Trxn-Serializability__0000", "lecture_id": "20-Trxn-Serializability", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}, {"source": "cluster_A", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "PT1-WS1-DBDesign_GCP__0009", "lecture_id": "PT1-WS1-DBDesign_GCP", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}, {"source": "cluster_B", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "5- SQL4-AggGrpViews__0000", "lecture_id": "5- SQL4-AggGrpViews", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems\n工"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0022"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0001"}, "gap_lectures": -3}}}
{"A": {"name": "DATA_MANAGEMENT", "role": "NA"}, "B": {"name": "TRANSACTIONS", "role": "NA"}, "relation": "depends_on", "justification": "Transactions are a fundamental aspect of data management, implying that understanding transactions is necessary before delving into comprehensive data management.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "19-Trxn-Mgmt__0001", "lecture_id": "19-Trxn-Mgmt", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}, {"source": "cluster_A", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "20-Trxn-Serializability__0000", "lecture_id": "20-Trxn-Serializability", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}, {"source": "cluster_A", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "PT1-WS1-DBDesign_GCP__0009", "lecture_id": "PT1-WS1-DBDesign_GCP", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}, {"source": "cluster_B", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "10-Neo4J-Part 1__0000", "lecture_id": "10-Neo4J-Part 1", "text": "University of Illinois at Urbana -Champaign CS411: Database Systems"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0000"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0001"}, "gap_lectures": 8}}}
{"A": {"name": "DATA_MODELING", "role": "NA"}, "B": {"name": "GRAPH_DATABASE", "role": "NA"}, "relation": null, "justification": "There is no clear evidence that supports a 'depends_on' or 'part_of' relationship between DATA_MODELING and GRAPH_DATABASE based on the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 111, "label_hint": "neo4j-and-graph-com-https", "chunk_id": "11-Neo4J-Part2__0009", "lecture_id": "11-Neo4J-Part2", "text": "Source: https://neo4j.com/developer/graph-db-vs-rdbms/#_from_relational_to_graph_databases"}, {"source": "cluster_B", "cluster_id": 111, "label_hint": "neo4j-and-graph-com-https", "chunk_id": "10-Neo4J-Part 1__0028", "lecture_id": "10-Neo4J-Part 1", "text": "1. Neo4j Tutorial: https://www.tutorialspoint.com/neo4j/index.htm\n2. Video Tutorials: https://neo4j.com/blog/neo4j -video -tutorials/?_ga=2.57983406.580712586.1555337212 -902296776.1553382068\n3. GraphGists are teaching tools which allow you to explore how data in a particular domain would be modeled as a graph and see some example queries of that graph data\n- https://neo4j.com/graphgists/\n4. Awesome user -defined procedures: https://github.com/neo4j -contrib/neo4j -apoc -procedures"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0008"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0006"}, "gap_lectures": 0}}}
{"A": {"name": "DATA_MODELING", "role": "NA"}, "B": {"name": "GRAPH_DATABASES", "role": "NA"}, "relation": null, "justification": "There is no clear evidence that DATA_MODELING depends_on or is part_of GRAPH_DATABASES based on the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 111, "label_hint": "neo4j-and-graph-com-https", "chunk_id": "11-Neo4J-Part2__0009", "lecture_id": "11-Neo4J-Part2", "text": "Source: https://neo4j.com/developer/graph-db-vs-rdbms/#_from_relational_to_graph_databases"}, {"source": "cluster_B", "cluster_id": 111, "label_hint": "neo4j-and-graph-com-https", "chunk_id": "11-Neo4J-Part2__0008", "lecture_id": "11-Neo4J-Part2", "text": "- Graph databases store relationships and connections as first-class entities:  'Property Graph Model'\nRDBMS, 1 = Graph Databases. Tables, 1 = Set of Nodes/Relationships. Rows, 1 = Nodes. Columns and data, 1 = Data properties and values. Constraints, 1 = Relationships. Joins, 1 = Traversals\nSource: https://neo4j.com/developer/graph-db-vs-rdbms/#_from_relational_to_graph_databases"}, {"source": "cluster_B", "cluster_id": 111, "label_hint": "neo4j-and-graph-com-https", "chunk_id": "11-Neo4J-Part2__0019", "lecture_id": "11-Neo4J-Part2", "text": "1. Neo4j Tutorial:\nhttps://www.tutorialspoint.com/neo4j/index.htm\n2. Video Tutorials: https://neo4j.com/blog/neo4j-videotutorials/?_ga=2.57983406.580712586.1555337212902296776.1553382068\n3. GraphGists are teaching tools which allow you to explore how data in a particular domain would be modeled as a graph and see some example queries of that graph data\n- https://neo4j.com/graphgists/\n4. Awesome user-defined procedures: https://github.com/neo4jcontrib/neo4j-apoc-procedures"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0002"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0006"}, "gap_lectures": 0}}}
{"A": {"name": "DATA_MODELING", "role": "NA"}, "B": {"name": "NORMALIZATION", "role": "NA"}, "relation": null, "justification": "There is no clear connection between DATA_MODELING and NORMALIZATION based on the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "5- SQL4-AggGrpViews__0000", "lecture_id": "5- SQL4-AggGrpViews", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems\n工"}, {"source": "cluster_A", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "7- ConstraintsTriggers__0000", "lecture_id": "7- ConstraintsTriggers", "text": "University of Illinois at Urbana -Champaign CS411: Database Systems\n工"}, {"source": "cluster_B", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "10-Neo4J-Part 1__0000", "lecture_id": "10-Neo4J-Part 1", "text": "University of Illinois at Urbana -Champaign CS411: Database Systems"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0000"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0006"}, "gap_lectures": 0}}}
{"A": {"name": "DATA_MODELING", "role": "NA"}, "B": {"name": "TRANSACTIONS", "role": "NA"}, "relation": null, "justification": "There is no clear connection or dependency between DATA_MODELING and TRANSACTIONS based on the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "5- SQL4-AggGrpViews__0000", "lecture_id": "5- SQL4-AggGrpViews", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems\n工"}, {"source": "cluster_A", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "7- ConstraintsTriggers__0000", "lecture_id": "7- ConstraintsTriggers", "text": "University of Illinois at Urbana -Champaign CS411: Database Systems\n工"}, {"source": "cluster_B", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "10-Neo4J-Part 1__0000", "lecture_id": "10-Neo4J-Part 1", "text": "University of Illinois at Urbana -Champaign CS411: Database Systems"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0000"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0006"}, "gap_lectures": 0}}}
{"A": {"name": "DATA_NORMALIZATION", "role": "NA"}, "B": {"name": "ENTITY", "role": "NA"}, "relation": null, "justification": "There is no clear connection or dependency between DATA_NORMALIZATION and ENTITY based on the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design__0018", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nMgrSSN is a foreign key (referencing the Employee relation)\nvalue of Manager must match an SSN\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nvs.\nProject(P-number, P-name, Due-Date)\nEmployee(SSN, E-Name, Office)\nManager(P-number, SSN)\nWhat are the tradeoffs between these two?\nNote: P-number is the key for Manager"}, {"source": "cluster_B", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0016", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nWhat are the attributes and what is the key for Assignment?\n```\nProject(P-number, P-name, Due-Date) Employee(SSN, E-Name, Office)\n```\nProject\nP-number P-name Due-Date\nEmployee\nSSN\nE-Name\nOffice\n0..*     Assignment      0..*\n- 0..*        Manager        1..1\nAnswer: Assignment(P-Number, SSN)\nP-Number is a foreign key for Project SSN is a foreign key for Employee\nProject(P-Number, P-Due-Date)\nEmployee(SSN, E-Name, Office)"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0005"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0018"}, "gap_lectures": 0}}}
{"A": {"name": "DATA_NORMALIZATION", "role": "NA"}, "B": {"name": "FOREIGN_KEY", "role": "NA"}, "relation": null, "justification": "There is no clear connection between DATA_NORMALIZATION and FOREIGN_KEY based on the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design__0018", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nMgrSSN is a foreign key (referencing the Employee relation)\nvalue of Manager must match an SSN\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nvs.\nProject(P-number, P-name, Due-Date)\nEmployee(SSN, E-Name, Office)\nManager(P-number, SSN)\nWhat are the tradeoffs between these two?\nNote: P-number is the key for Manager"}, {"source": "cluster_B", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0016", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nWhat are the attributes and what is the key for Assignment?\n```\nProject(P-number, P-name, Due-Date) Employee(SSN, E-Name, Office)\n```\nProject\nP-number P-name Due-Date\nEmployee\nSSN\nE-Name\nOffice\n0..*     Assignment      0..*\n- 0..*        Manager        1..1\nAnswer: Assignment(P-Number, SSN)\nP-Number is a foreign key for Project SSN is a foreign key for Employee\nProject(P-Number, P-Due-Date)\nEmployee(SSN, E-Name, Office)"}, {"source": "cluster_B", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0018", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nMgrSSN is a foreign key (referencing the Employee relation)\nvalue of Manager must match an SSN\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nvs.\nProject(P-number, P-name, Due-Date)\nEmployee(SSN, E-Name, Office)\nManager(P-number, SSN)\nWhat are the tradeoffs between these two?\nNote: P-number is the key for Manager"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0000"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0018"}, "gap_lectures": 4}}}
{"A": {"name": "DATA_NORMALIZATION", "role": "NA"}, "B": {"name": "FUNCTIONAL_DEPENDENCY", "role": "NA"}, "relation": "depends_on", "justification": "Functional dependency is a foundational concept that is required to understand data normalization, as it helps in identifying and resolving dependencies within database tables.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 1, "label_hint": "dept-and-phone-dnum-1234", "chunk_id": "15-NFs-3NF__0003", "lecture_id": "15-NFs-3NF", "text": "1234, Address = 10 Downing. 1234, Phone = 1234. 1234, Name = John. 5678, Address = 10 Downing. 5678, Phone = 5678. 5678, Name = John\nFD '\ns:  Phone \nAddress;      Address, Name  Phone\nNo problem so far. All\nlocal FD ' s are satisfied.\nLet's put all the data into a single table:\n1234, Address = 10 Downing. 1234, Name = John. 5678, Address = 10 Downing. 5678, Name = John\nViolates the dependency:   Address, Name\n Phone"}, {"source": "cluster_B", "cluster_id": 1, "label_hint": "dept-and-phone-dnum-1234", "chunk_id": "13-NFs-FDs__0012", "lecture_id": "13-NFs-FDs", "text": "Consider this table:\nEmp(ssn, name, phone, dnum, dept-name)\nSuppose there is an FD from dnum → dept-name\nBut ssn is the key for this table.\nWhat will prevent two names for one dept?"}, {"source": "cluster_B", "cluster_id": 1, "label_hint": "dept-and-phone-dnum-1234", "chunk_id": "13-NFs-FDs__0013", "lecture_id": "13-NFs-FDs", "text": "Consider this table:\nEmp(ssn, name, phone, dnum, dept-name)\n, ssn = 111111111. , Nam e = John. , Phone = 555-1234. , Dnum = 12. , Dept-name = Sales. , ssn = 222222222. , Nam e = Mary. , Phone = 555-7890. , Dnum = 12. , Dept-name = Marketing. , ssn = …. , Nam e = . , Phone = . , Dnum = . , Dept-name = \nCan we put these two rows in this table?\nYes, it doesn't violate the key constraint.\nBut, the FD from dept to dept-name is violated!  We shouldn't have two different names for dnum 12!"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 2, "reason": "A and B appear in different chunks within 2 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0012"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0018"}, "gap_lectures": -2}}}
{"A": {"name": "DATA_NORMALIZATION", "role": "NA"}, "B": {"name": "NORMALIZATION", "role": "NA"}, "relation": null, "justification": "There is no clear connection or dependency between 'DATA_NORMALIZATION' and 'NORMALIZATION' based on the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 2, "label_hint": "dnum-and-dname-st-dmgr", "chunk_id": "13-NFs-FDs__0016", "lecture_id": "13-NFs-FDs", "text": "EMP(name, SSN, birthdate, address, dnum, dname, dmgr)\nJohn 111 June 3 123 St.      D1     sales     222\nSue 222 May 15 455 St.     D1     sales     222\nMax       333 Mar. 5 678 St.     D2    research 333\nWei 444 May 2 999 St.     D2    research 333\nTom 555 June 22 888 St.     D2    research 333\ndname and dmgr are stored redundantly - whenever there are multiple employees in a department.\nThis redundancy is caused by what we informally call 'troublesome' FDs. The FDs shown in blue are 'troublesome'."}, {"source": "cluster_B", "cluster_id": 2, "label_hint": "dnum-and-dname-st-dmgr", "chunk_id": "13-NFs-FDs__0017", "lecture_id": "13-NFs-FDs", "text": "caused by 'troublesome' FDs\nEMP(name, SSN, birthdate, address, dnum, dname, dmgr)"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0000"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0018"}, "gap_lectures": 3}}}
{"A": {"name": "DATA_NORMALIZATION", "role": "NA"}, "B": {"name": "PRIMARY_KEY", "role": "NA"}, "relation": null, "justification": "There is no clear connection or dependency between DATA_NORMALIZATION and PRIMARY_KEY based on the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 1, "label_hint": "dept-and-phone-dnum-1234", "chunk_id": "15-NFs-3NF__0003", "lecture_id": "15-NFs-3NF", "text": "1234, Address = 10 Downing. 1234, Phone = 1234. 1234, Name = John. 5678, Address = 10 Downing. 5678, Phone = 5678. 5678, Name = John\nFD '\ns:  Phone \nAddress;      Address, Name  Phone\nNo problem so far. All\nlocal FD ' s are satisfied.\nLet's put all the data into a single table:\n1234, Address = 10 Downing. 1234, Name = John. 5678, Address = 10 Downing. 5678, Name = John\nViolates the dependency:   Address, Name\n Phone"}, {"source": "cluster_B", "cluster_id": 1, "label_hint": "dept-and-phone-dnum-1234", "chunk_id": "13-NFs-FDs__0012", "lecture_id": "13-NFs-FDs", "text": "Consider this table:\nEmp(ssn, name, phone, dnum, dept-name)\nSuppose there is an FD from dnum → dept-name\nBut ssn is the key for this table.\nWhat will prevent two names for one dept?"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0000"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0018"}, "gap_lectures": 4}}}
{"A": {"name": "DATA_NORMALIZATION", "role": "NA"}, "B": {"name": "REDUNDANCY_REDUCTION", "role": "NA"}, "relation": null, "justification": "There is no clear indication in the provided evidence that DATA_NORMALIZATION depends on or is part of REDUNDANCY_REDUCTION, or vice versa. The evidence does not establish a clear prerequisite or component relationship between the two concepts.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 2, "label_hint": "dnum-and-dname-st-dmgr", "chunk_id": "13-NFs-FDs__0016", "lecture_id": "13-NFs-FDs", "text": "EMP(name, SSN, birthdate, address, dnum, dname, dmgr)\nJohn 111 June 3 123 St.      D1     sales     222\nSue 222 May 15 455 St.     D1     sales     222\nMax       333 Mar. 5 678 St.     D2    research 333\nWei 444 May 2 999 St.     D2    research 333\nTom 555 June 22 888 St.     D2    research 333\ndname and dmgr are stored redundantly - whenever there are multiple employees in a department.\nThis redundancy is caused by what we informally call 'troublesome' FDs. The FDs shown in blue are 'troublesome'."}, {"source": "cluster_B", "cluster_id": 2, "label_hint": "dnum-and-dname-st-dmgr", "chunk_id": "13-NFs-FDs__0022", "lecture_id": "13-NFs-FDs", "text": "New-EMP(name, SSN, birthdate, address, dnum)\nInsert anomalies: No Problem\n```\nJohn    111 June 3     123 St.      D1 Sue     222 May 15    455 St.       D1 Max    333 Mar. 5      678 St.      D2 Wei     444 May 2      999 St.      D2 Tom    555 June 22   888 St.      D2\n```\nDept(dnum,  dname,  dmgr)\nD1         sales        222\nD2        research  333\nLess redundancy!\nDelete anomalies: No Problem"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0019"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0018"}, "gap_lectures": -2}}}
{"A": {"name": "DATA_NORMALIZATION", "role": "NA"}, "B": {"name": "RELATIONSHIP", "role": "NA"}, "relation": null, "justification": "There is no clear connection or dependency between DATA_NORMALIZATION and RELATIONSHIP based on the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design__0018", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nMgrSSN is a foreign key (referencing the Employee relation)\nvalue of Manager must match an SSN\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nvs.\nProject(P-number, P-name, Due-Date)\nEmployee(SSN, E-Name, Office)\nManager(P-number, SSN)\nWhat are the tradeoffs between these two?\nNote: P-number is the key for Manager"}, {"source": "cluster_B", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0016", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nWhat are the attributes and what is the key for Assignment?\n```\nProject(P-number, P-name, Due-Date) Employee(SSN, E-Name, Office)\n```\nProject\nP-number P-name Due-Date\nEmployee\nSSN\nE-Name\nOffice\n0..*     Assignment      0..*\n- 0..*        Manager        1..1\nAnswer: Assignment(P-Number, SSN)\nP-Number is a foreign key for Project SSN is a foreign key for Employee\nProject(P-Number, P-Due-Date)\nEmployee(SSN, E-Name, Office)"}, {"source": "cluster_B", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design__0016", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nWhat are the attributes and what is the key for Assignment?\n```\nProject(P-number, P-name, Due-Date) Employee(SSN, E-Name, Office)\n```\nProject\nP-number P-name Due-Date\nEmployee\nSSN\nE-Name\nOffice\n0..*     Assignment      0..*\n- 0..*        Manager        1..1\nAnswer: Assignment(P-Number, SSN)\nP-Number is a foreign key for Project SSN is a foreign key for Employee\nProject(P-Number, P-Due-Date)\nEmployee(SSN, E-Name, Office)"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0005"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0018"}, "gap_lectures": 0}}}
{"A": {"name": "DATA_NORMALIZATION", "role": "NA"}, "B": {"name": "UPDATE_ANOMALIES", "role": "NA"}, "relation": "depends_on", "justification": "Data normalization is a prerequisite for understanding and addressing update anomalies, as normalization helps reduce redundancy and inconsistencies in the database.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 2, "label_hint": "dnum-and-dname-st-dmgr", "chunk_id": "13-NFs-FDs__0016", "lecture_id": "13-NFs-FDs", "text": "EMP(name, SSN, birthdate, address, dnum, dname, dmgr)\nJohn 111 June 3 123 St.      D1     sales     222\nSue 222 May 15 455 St.     D1     sales     222\nMax       333 Mar. 5 678 St.     D2    research 333\nWei 444 May 2 999 St.     D2    research 333\nTom 555 June 22 888 St.     D2    research 333\ndname and dmgr are stored redundantly - whenever there are multiple employees in a department.\nThis redundancy is caused by what we informally call 'troublesome' FDs. The FDs shown in blue are 'troublesome'."}, {"source": "cluster_B", "cluster_id": 2, "label_hint": "dnum-and-dname-st-dmgr", "chunk_id": "13-NFs-FDs__0020", "lecture_id": "13-NFs-FDs", "text": "EMP(name, ssn, birthdate, address, dnum, dname, dmgr)\nWe have a problem! dnum is NOT the key for this table!\nSo these blue FDs will not be enforced automatically by the DBMS (using only keys). And there can be redundancy and update anomalies"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0014"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0018"}, "gap_lectures": -2}}}
{"A": {"name": "DISTINCT_RESULTS", "role": "NA"}, "B": {"name": "GROUP_BY", "role": "NA"}, "relation": null, "justification": "There is no clear indication that 'DISTINCT_RESULTS' depends on or is part of 'GROUP_BY'. The evidence does not provide a direct connection between the two concepts.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 87, "label_hint": "001-and-sem-sid-cid", "chunk_id": "21-RA__0008", "lecture_id": "21-RA", "text": "- Products are hardly ever used alone; they are typically used in conjunction with a selection. Example:\n<!-- formula-not-decoded -->\nSELECT DISTINCT * FROM Student s JOIN Takes t On s.sid=t.sid\nSELECT DISTINCT * FROM Student s, Takes t WHERE s.sid=t.sid\n1, name = Jill. 1, sid:2 = 1. 1, exp-grade = A. 1, cid = 550-001. 1, sem = F14. 1, name = Jill. 1, sid:2 = 1. 1, exp-grade = C. 1, cid = 502-001. 1, sem = F14. 3, name = Maya. 3, sid:2 = 3. 3, exp-grade = A. 3, cid = 555-001. 3, sem = S15. 3, name = Maya. 3, sid:2 = 3. 3, exp-grade = B. 3, cid = 550-001. 3, sem = F14"}, {"source": "cluster_B", "cluster_id": 87, "label_hint": "001-and-sem-sid-cid", "chunk_id": "23-Rule-basedOpt__0001", "lecture_id": "23-Rule-basedOpt", "text": "Need to start someplace..\nThe easy cases:\n```\nSelect a1, …, an From R1, …, Rk Where C\n```\n<!-- formula-not-decoded -->\n```\nSelect a1, …, an, aggs From R1, …, Rk Where C Group by b1, …, bl\n```\nUses 'extended' relational algebra, with gamma and delta\n<!-- formula-not-decoded -->\nIn most of these cases, the x will be a"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 14, "lecture_id": "23-Rule-basedOpt", "chunk_id": "23-Rule-basedOpt__0001"}, "A_first_introduced_at": {"lecture_index": 2, "lecture_id": "11-Neo4J-Part2", "chunk_id": "11-Neo4J-Part2__0016"}, "gap_lectures": -12}}}
{"A": {"name": "DISTINCT_RESULTS", "role": "NA"}, "B": {"name": "JOIN_OPERATION", "role": "NA"}, "relation": "depends_on", "justification": "DISTINCT_RESULTS is used in conjunction with JOIN_OPERATION to ensure that the results of a join operation are unique, indicating that JOIN_OPERATION must be understood first.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 87, "label_hint": "001-and-sem-sid-cid", "chunk_id": "21-RA__0008", "lecture_id": "21-RA", "text": "- Products are hardly ever used alone; they are typically used in conjunction with a selection. Example:\n<!-- formula-not-decoded -->\nSELECT DISTINCT * FROM Student s JOIN Takes t On s.sid=t.sid\nSELECT DISTINCT * FROM Student s, Takes t WHERE s.sid=t.sid\n1, name = Jill. 1, sid:2 = 1. 1, exp-grade = A. 1, cid = 550-001. 1, sem = F14. 1, name = Jill. 1, sid:2 = 1. 1, exp-grade = C. 1, cid = 502-001. 1, sem = F14. 3, name = Maya. 3, sid:2 = 3. 3, exp-grade = A. 3, cid = 555-001. 3, sem = S15. 3, name = Maya. 3, sid:2 = 3. 3, exp-grade = B. 3, cid = 550-001. 3, sem = F14"}, {"source": "cluster_B", "cluster_id": 87, "label_hint": "001-and-sem-sid-cid", "chunk_id": "21-RA__0005", "lecture_id": "21-RA", "text": "- Join\nR1 ⋈  R2\n- Intersection R1 ∩ R2\n550-001, subj = DB. 550-001, sem = F14. 502-001, subj = Algo. 502-001, sem = F14. 555-001, subj = I&W. 555-001, sem = S15. 666-001, subj = Ethics. 666-001, sem = S66\nNote:\nduplicate elimination.\n1, exp- grade = A. 1, cid = 550-001. 1, sem = F14. 1, exp- grade = C. 1, cid = 502-001. 1, sem = F14. 3, exp- grade = A. 3, cid = 555-001. 3, sem = S15. 3, exp- grade = B. 3, cid = 550-001. 3, sem = F14"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0005"}, "A_first_introduced_at": {"lecture_index": 2, "lecture_id": "11-Neo4J-Part2", "chunk_id": "11-Neo4J-Part2__0016"}, "gap_lectures": -10}}}
{"A": {"name": "DISTINCT_RESULTS", "role": "NA"}, "B": {"name": "RELATIONAL_ALGEBRA", "role": "NA"}, "relation": "depends_on", "justification": "DISTINCT_RESULTS is used as an operation within the context of relational algebra, indicating that understanding relational algebra is a prerequisite for understanding DISTINCT_RESULTS.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 87, "label_hint": "001-and-sem-sid-cid", "chunk_id": "21-RA__0008", "lecture_id": "21-RA", "text": "- Products are hardly ever used alone; they are typically used in conjunction with a selection. Example:\n<!-- formula-not-decoded -->\nSELECT DISTINCT * FROM Student s JOIN Takes t On s.sid=t.sid\nSELECT DISTINCT * FROM Student s, Takes t WHERE s.sid=t.sid\n1, name = Jill. 1, sid:2 = 1. 1, exp-grade = A. 1, cid = 550-001. 1, sem = F14. 1, name = Jill. 1, sid:2 = 1. 1, exp-grade = C. 1, cid = 502-001. 1, sem = F14. 3, name = Maya. 3, sid:2 = 3. 3, exp-grade = A. 3, cid = 555-001. 3, sem = S15. 3, name = Maya. 3, sid:2 = 3. 3, exp-grade = B. 3, cid = 550-001. 3, sem = F14"}, {"source": "cluster_B", "cluster_id": 87, "label_hint": "001-and-sem-sid-cid", "chunk_id": "23-Rule-basedOpt__0001", "lecture_id": "23-Rule-basedOpt", "text": "Need to start someplace..\nThe easy cases:\n```\nSelect a1, …, an From R1, …, Rk Where C\n```\n<!-- formula-not-decoded -->\n```\nSelect a1, …, an, aggs From R1, …, Rk Where C Group by b1, …, bl\n```\nUses 'extended' relational algebra, with gamma and delta\n<!-- formula-not-decoded -->\nIn most of these cases, the x will be a"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0002"}, "A_first_introduced_at": {"lecture_index": 2, "lecture_id": "11-Neo4J-Part2", "chunk_id": "11-Neo4J-Part2__0016"}, "gap_lectures": -10}}}
{"A": {"name": "DISTINCT_RESULTS", "role": "NA"}, "B": {"name": "RELATIONAL_SCHEMA", "role": "NA"}, "relation": null, "justification": "There is no clear connection between DISTINCT_RESULTS and RELATIONAL_SCHEMA based on the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 87, "label_hint": "001-and-sem-sid-cid", "chunk_id": "21-RA__0008", "lecture_id": "21-RA", "text": "- Products are hardly ever used alone; they are typically used in conjunction with a selection. Example:\n<!-- formula-not-decoded -->\nSELECT DISTINCT * FROM Student s JOIN Takes t On s.sid=t.sid\nSELECT DISTINCT * FROM Student s, Takes t WHERE s.sid=t.sid\n1, name = Jill. 1, sid:2 = 1. 1, exp-grade = A. 1, cid = 550-001. 1, sem = F14. 1, name = Jill. 1, sid:2 = 1. 1, exp-grade = C. 1, cid = 502-001. 1, sem = F14. 3, name = Maya. 3, sid:2 = 3. 3, exp-grade = A. 3, cid = 555-001. 3, sem = S15. 3, name = Maya. 3, sid:2 = 3. 3, exp-grade = B. 3, cid = 550-001. 3, sem = F14"}, {"source": "cluster_B", "cluster_id": 87, "label_hint": "001-and-sem-sid-cid", "chunk_id": "21-RA__0006", "lecture_id": "21-RA", "text": "- Does not change the relational instance\n- Changes the relational schema only\n- Notation: ρS(B1,…,Bn) (R)\n- Input schema:\nR(A1, …, An)\n- Output schema:\nS(B1, …, Bn)\n- Example: rename Student(sid, name)\nρ RenamedStudent(UIN, lastname) (Student)"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "A_first_introduced_at": {"lecture_index": 2, "lecture_id": "11-Neo4J-Part2", "chunk_id": "11-Neo4J-Part2__0016"}, "gap_lectures": -2}}}
{"A": {"name": "DISTINCT_RESULTS", "role": "NA"}, "B": {"name": "SET_SEMANTICS", "role": "NA"}, "relation": null, "justification": "There is no clear dependency or part_of relationship between DISTINCT_RESULTS and SET_SEMANTICS based on the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 131, "label_hint": "force-and-result-bag-duplicates", "chunk_id": "4-AdvSQL-SubqueriesSetOps__0013", "lecture_id": "4-AdvSQL-SubqueriesSetOps", "text": "- Force the result to be a set by SELECT DISTINCT . . .\n- Force the result to be a bag (i.e., don't eliminate duplicates) by ALL, as in\n- . . . UNION ALL . . ."}, {"source": "cluster_B", "cluster_id": 131, "label_hint": "force-and-result-bag-duplicates", "chunk_id": "4-AdvSQL-SubqueriesSetOps__0012", "lecture_id": "4-AdvSQL-SubqueriesSetOps", "text": "Although the SELECT-FROM-WHERE statement uses bag semantics, the default for union, intersection, and difference is set semantics.\n- That is, duplicates are eliminated as the operation is applied."}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 14, "lecture_id": "23-Rule-basedOpt", "chunk_id": "23-Rule-basedOpt__0004"}, "A_first_introduced_at": {"lecture_index": 2, "lecture_id": "11-Neo4J-Part2", "chunk_id": "11-Neo4J-Part2__0016"}, "gap_lectures": -12}}}
{"A": {"name": "EMPLOYEE_DEPARTMENT", "role": "NA"}, "B": {"name": "LEFT_OUTER_JOIN", "role": "NA"}, "relation": null, "justification": "There is no clear dependency or part-of relationship between 'EMPLOYEE_DEPARTMENT' and 'LEFT_OUTER_JOIN' based on the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 86, "label_hint": "departmentid-and-employee-lastname-departmentname", "chunk_id": "3-SQL2-JOINS_Nulls__0004", "lecture_id": "3-SQL2-JOINS_Nulls", "text": "Employee Department\nEmployee.DeptID = Department.DeptID\nSELECT *\nFROM Employee emp JOIN Department dept\nON emp.DepartmentID = dept.DepartmentID\nRobinson,  = 34. Robinson, Employee.LastName Employee.DepartmentiDDepartment.DepartmentName Department.DepartmentID = Clerical. Robinson,  = 34. Jones,  = 33. Jones, Employee.LastName Employee.DepartmentiDDepartment.DepartmentName Department.DepartmentID = Engineering. Jones,  = 33. Smith,  = 34. Smith, Employee.LastName Employee.DepartmentiDDepartment.DepartmentName Department.DepartmentID = Clerical. Smith,  = . Steinberg,  = 33. Steinberg, Employee.LastName Employee.DepartmentiDDepartment.DepartmentName Department.DepartmentID = Engineering. Steinberg,  = 33. Rafferty,  = 31. Rafferty, Employee.LastName Employee.DepartmentiDDepartment.DepartmentName Department.DepartmentID = Sales. Rafferty,  = 31\n34,  = Smith. 34, DepartmentiD Employee.LastName Department.DepartmentName = Clerical. 33,  = Jones. 33, DepartmentiD Employee.LastName Department.DepartmentName = Engineering. 34,  = Robinson. 34, DepartmentiD Employee.LastName Department.DepartmentName = Clerical. 33,  = Steinberg. 33, DepartmentiD Employee.LastName Department.DepartmentName = Engineering. 31,  = Rafferty. 31, DepartmentiD Employee.LastName Department.DepartmentName = Sales"}, {"source": "cluster_A", "cluster_id": 86, "label_hint": "departmentid-and-employee-lastname-departmentname", "chunk_id": "3-SQL2-JOINS_Nulls__0011", "lecture_id": "3-SQL2-JOINS_Nulls", "text": "Employee         Department\nEmployee.DepartmentID = Department.DepartmentID\nRafferty, Employeetable.LastName DepartmentID = 31. Jones, Employeetable.LastName DepartmentID = 33. Steinberg, Employeetable.LastName DepartmentID = 33. Robinson, Employeetable.LastName DepartmentID = 34. Smith, Employeetable.LastName DepartmentID = 34. John, Employeetable.LastName DepartmentID = NULL\nSELECT  *\nFROM Employee emp RIGHT OUTER JOIN Department dept ON emp.DepartmentID = dept.DepartmentID\nSmith,  = 34. Smith, Employee.LastName Employee.DepartmentIDDepartment.DepartmentNameDepartment.DepartmentID = Clerical. Smith,  = . Jones,  = 33. Jones, Employee.LastName Employee.DepartmentIDDepartment.DepartmentNameDepartment.DepartmentID = Engineering. Jones,  = 33. Robinson,  = . Robinson, Employee.LastName Employee.DepartmentIDDepartment.DepartmentNameDepartment.DepartmentID = Clerical. Robinson,  = . Steinberg,  = 33. Steinberg, Employee.LastName Employee.DepartmentIDDepartment.DepartmentNameDepartment.DepartmentID = Engineering. Steinberg,  = 33. Rafferty,  = 31. Rafferty, Employee.LastName Employee.DepartmentIDDepartment.DepartmentNameDepartment.DepartmentID = Sales. Rafferty,  = 31. NULL,  = NULL. NULL, Employee.LastName Employee.DepartmentIDDepartment.DepartmentNameDepartment.DepartmentID = Marketing. NULL,  = 35\n31, Departmenttable.DepartmentID DepartmentName = Sales. 33, Departmenttable.DepartmentID DepartmentName = Engineering. , Departmenttable.DepartmentID DepartmentName = Clerical. 35, Departmenttable.DepartmentID DepartmentName = Marketing"}, {"source": "cluster_A", "cluster_id": 86, "label_hint": "departmentid-and-employee-lastname-departmentname", "chunk_id": "3-SQL2-JOINS_Nulls__0012", "lecture_id": "3-SQL2-JOINS_Nulls", "text": "Employee         Department\nEmployee.DepartmentID = Department.DepartmentID\nSmith,  = 34. Smith, Employee.LastNameEmployee.DepartmentIDDepartment.DepartmentNameDepartment.DepartmentlD = Clerical. Smith,  = 34. Jones,  = 33. Jones, Employee.LastNameEmployee.DepartmentIDDepartment.DepartmentNameDepartment.DepartmentlD = Engineering. Jones,  = 33. Robinson,  = 34. Robinson, Employee.LastNameEmployee.DepartmentIDDepartment.DepartmentNameDepartment.DepartmentlD = Clerical. Robinson,  = . John,  = NULL. John, Employee.LastNameEmployee.DepartmentIDDepartment.DepartmentNameDepartment.DepartmentlD = NULL. John,  = NULL. Steinberg,  = 33. Steinberg, Employee.LastNameEmployee.DepartmentIDDepartment.DepartmentNameDepartment.DepartmentlD = Engineering. Steinberg,  = 33. Rafferty,  = 31. Rafferty, Employee.LastNameEmployee.DepartmentIDDepartment.DepartmentNameDepartment.DepartmentlD = Sales. Rafferty,  = 31. NULL,  = NULL.. NULL, Employee.LastNameEmployee.DepartmentIDDepartment.DepartmentNameDepartment.DepartmentlD = Marketing. NULL,  = 35"}, {"source": "cluster_B", "cluster_id": 86, "label_hint": "departmentid-and-employee-lastname-departmentname", "chunk_id": "3-SQL2-JOINS_Nulls__0009", "lecture_id": "3-SQL2-JOINS_Nulls", "text": "- Sometimes need special variations of joins:\n- I want to see all employees and their departments\n- … But what if there's a department with no employees?\n- Or what if an employee has not been assigned to a department?\n- Outer join:\n- Most common is left outer join\n- Left outer join:\n- Include the left tuple even if there's no match\n- Right outer join:\n- Include the right tuple even if there's no match\n- Full outer join:\n- Include both the left and right tuples even if there's no match"}, {"source": "cluster_B", "cluster_id": 86, "label_hint": "departmentid-and-employee-lastname-departmentname", "chunk_id": "3-SQL2-JOINS_Nulls__0010", "lecture_id": "3-SQL2-JOINS_Nulls", "text": "Rafferty, Employeetable.LastName DepartmentID = 31. Jones, Employeetable.LastName DepartmentID = 33. Steinberg, Employeetable.LastName DepartmentID = 33. Robinson, Employeetable.LastName DepartmentID = 34. Smith, Employeetable.LastName DepartmentID = 34. John, Employeetable.LastName DepartmentID = NULL\nSELECT  *\nFROM Employee emp LEFT OUTER JOIN Department dept ON emp.DepartmentID = dept.DepartmentID\nJones,  = 33. Jones, Employee.LastName Employee.DepartmentIDDepartment.DepartmentName Department.DepartmentID = Engineering. Jones,  = 33. Rafferty,  = 31. Rafferty, Employee.LastName Employee.DepartmentIDDepartment.DepartmentName Department.DepartmentID = Sales. Rafferty,  = 31. Robinson,  = . Robinson, Employee.LastName Employee.DepartmentIDDepartment.DepartmentName Department.DepartmentID = Clerical. Robinson,  = . Smith,  = 34. Smith, Employee.LastName Employee.DepartmentIDDepartment.DepartmentName Department.DepartmentID = Clerical. Smith,  = . John,  = NULL. John, Employee.LastName Employee.DepartmentIDDepartment.DepartmentName Department.DepartmentID = NULL. John,  = TTON. Steinberg,  = 33. Steinberg, Employee.LastName Employee.DepartmentIDDepartment.DepartmentName Department.DepartmentID = Engineering. Steinberg,  = 33\n31, Departmenttable.DepartmentiD DepartmentName = Sales. 33, Departmenttable.DepartmentiD DepartmentName = Engineering. , Departmenttable.DepartmentiD DepartmentName = Clerical. 35, Departmenttable.DepartmentiD DepartmentName = Marketing"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 15, "lecture_id": "3-SQL2-JOINS_Nulls", "chunk_id": "3-SQL2-JOINS_Nulls__0009"}, "A_first_introduced_at": {"lecture_index": 15, "lecture_id": "3-SQL2-JOINS_Nulls", "chunk_id": "3-SQL2-JOINS_Nulls__0004"}, "gap_lectures": 0}}}
{"A": {"name": "ENTITIES_RELATIONSHIPS", "role": "NA"}, "B": {"name": "FUNCTIONAL_DEPENDENCIES", "role": "NA"}, "relation": "depends_on", "justification": "Entities and relationships are introduced in the conceptual and logical design phases, which are foundational steps before identifying functional dependencies during schema refinement.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0000", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "cluster_A", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "12-Conceptual_Logical_DB_Design__0000", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "cluster_A", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "13-NFs-FDs__0001", "lecture_id": "13-NFs-FDs", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "cluster_B", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "13-NFs-FDs__0003", "lecture_id": "13-NFs-FDs", "text": "- Start with the original db schema R\n- From ER translation or otherwise\n- Identify its functional dependencies\n- Use them to transform R until we get a good design R*"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0003"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "gap_lectures": -2}}}
{"A": {"name": "ENTITY", "role": "NA"}, "B": {"name": "FOREIGN_KEYS", "role": "NA"}, "relation": null, "justification": "There is no clear dependency or part_of relationship between 'ENTITY' and 'FOREIGN_KEYS' based on the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0016", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nWhat are the attributes and what is the key for Assignment?\n```\nProject(P-number, P-name, Due-Date) Employee(SSN, E-Name, Office)\n```\nProject\nP-number P-name Due-Date\nEmployee\nSSN\nE-Name\nOffice\n0..*     Assignment      0..*\n- 0..*        Manager        1..1\nAnswer: Assignment(P-Number, SSN)\nP-Number is a foreign key for Project SSN is a foreign key for Employee\nProject(P-Number, P-Due-Date)\nEmployee(SSN, E-Name, Office)"}, {"source": "cluster_B", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design__0018", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nMgrSSN is a foreign key (referencing the Employee relation)\nvalue of Manager must match an SSN\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nvs.\nProject(P-number, P-name, Due-Date)\nEmployee(SSN, E-Name, Office)\nManager(P-number, SSN)\nWhat are the tradeoffs between these two?\nNote: P-number is the key for Manager"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0005"}, "gap_lectures": 4}}}
{"A": {"name": "ENTITY", "role": "NA"}, "B": {"name": "REFERENTIAL_INTEGRITY", "role": "NA"}, "relation": null, "justification": "The evidence does not clearly indicate a dependency or part_of relationship between 'ENTITY' and 'REFERENTIAL_INTEGRITY'. The co-occurrence in the same cluster does not provide sufficient context to infer a clear relation.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0016", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nWhat are the attributes and what is the key for Assignment?\n```\nProject(P-number, P-name, Due-Date) Employee(SSN, E-Name, Office)\n```\nProject\nP-number P-name Due-Date\nEmployee\nSSN\nE-Name\nOffice\n0..*     Assignment      0..*\n- 0..*        Manager        1..1\nAnswer: Assignment(P-Number, SSN)\nP-Number is a foreign key for Project SSN is a foreign key for Employee\nProject(P-Number, P-Due-Date)\nEmployee(SSN, E-Name, Office)"}, {"source": "cluster_B", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0018", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nMgrSSN is a foreign key (referencing the Employee relation)\nvalue of Manager must match an SSN\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nvs.\nProject(P-number, P-name, Due-Date)\nEmployee(SSN, E-Name, Office)\nManager(P-number, SSN)\nWhat are the tradeoffs between these two?\nNote: P-number is the key for Manager"}, {"source": "cluster_B", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design__0018", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nMgrSSN is a foreign key (referencing the Employee relation)\nvalue of Manager must match an SSN\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nvs.\nProject(P-number, P-name, Due-Date)\nEmployee(SSN, E-Name, Office)\nManager(P-number, SSN)\nWhat are the tradeoffs between these two?\nNote: P-number is the key for Manager"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0015"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0005"}, "gap_lectures": 4}}}
{"A": {"name": "ENTITY_IDENTIFICATION", "role": "NA"}, "B": {"name": "ENTITY_SET", "role": "NA"}, "relation": "depends_on", "justification": "Entity identification (A) requires understanding of entity sets (B) to uniquely identify entities within them.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 116, "label_hint": "entity-and-set-uniquely-weak", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0012", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Occasionally, entities of an entity set need 'help' to identify them uniquely.\n- Entity set E is weak if in order to identify entities of E uniquely, we need to follow one or more many-one relationships from E and include the key of the related entity sets.\n- Note: not an is-a relationship because E is not a 'subclass' of F: Univ and Team"}, {"source": "cluster_B", "cluster_id": 116, "label_hint": "entity-and-set-uniquely-weak", "chunk_id": "12-Conceptual_Logical_DB_Design__0021", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "supporting entity set supporting relationship set\nweak Entity set"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0005"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0010"}, "gap_lectures": 0}}}
{"A": {"name": "ENTITY_IDENTIFICATION", "role": "NA"}, "B": {"name": "FOREIGN_KEY", "role": "NA"}, "relation": "depends_on", "justification": "Entity identification (A) depends on understanding foreign keys (B) because foreign keys are used to ensure referential integrity, which is a type of constraint that helps identify relationships between entities in a database.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 140, "label_hint": "constraints-and-database-based-assertions", "chunk_id": "12-Conceptual_Logical_DB_Design__0010", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "Finding constraints is part of the modeling process. Commonly used constraints:\n-  Keys: attributes that identify entities in an entity set e.g., social security number uniquely identifies a person.\n- \n- Referential integrity constraints: relationship-based constraints\n- e.g., if you work for a company, it must exist in the database.\n-  Domain constraints:  peoples ' ages are between 0 and 150.\n-  General constraints: all others (at most 50 students enroll in a class)"}, {"source": "cluster_B", "cluster_id": 140, "label_hint": "constraints-and-database-based-assertions", "chunk_id": "7- ConstraintsTriggers__0002", "lecture_id": "7- ConstraintsTriggers", "text": "- Constraints are used to make sure that the data in the database 'makes sense', that is: important real -world properties are kept valid\n- Via continuous maintenance of 'assertions' (i.e. Constraints)\n- A constraint is a relationship among data elements that the DBMS is required to enforce.\n- Example: key constraints.\n- Keys.\n- Foreign -key, or referential -integrity.\n- Value -based constraints.\n- Constrain values of a particular attribute.\n- Tuple -based constraints.\n- Relationship among components.\n- Assertions: any SQL Boolean expression."}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0000"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0010"}, "gap_lectures": 4}}}
{"A": {"name": "ENTITY_IDENTIFICATION", "role": "NA"}, "B": {"name": "RELATIONSHIP_SET", "role": "NA"}, "relation": "depends_on", "justification": "Entity identification requires understanding relationship sets to uniquely identify entities within an entity set.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 116, "label_hint": "entity-and-set-uniquely-weak", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0012", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Occasionally, entities of an entity set need 'help' to identify them uniquely.\n- Entity set E is weak if in order to identify entities of E uniquely, we need to follow one or more many-one relationships from E and include the key of the related entity sets.\n- Note: not an is-a relationship because E is not a 'subclass' of F: Univ and Team"}, {"source": "cluster_B", "cluster_id": 116, "label_hint": "entity-and-set-uniquely-weak", "chunk_id": "12-Conceptual_Logical_DB_Design__0021", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "supporting entity set supporting relationship set\nweak Entity set"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0005"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0010"}, "gap_lectures": 0}}}
{"A": {"name": "ENTITY_IDENTIFICATION", "role": "NA"}, "B": {"name": "TRIGGERS", "role": "NA"}, "relation": null, "justification": "There is no clear evidence that ENTITY_IDENTIFICATION depends on or is part of TRIGGERS based on the provided text.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 140, "label_hint": "constraints-and-database-based-assertions", "chunk_id": "12-Conceptual_Logical_DB_Design__0010", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "Finding constraints is part of the modeling process. Commonly used constraints:\n-  Keys: attributes that identify entities in an entity set e.g., social security number uniquely identifies a person.\n- \n- Referential integrity constraints: relationship-based constraints\n- e.g., if you work for a company, it must exist in the database.\n-  Domain constraints:  peoples ' ages are between 0 and 150.\n-  General constraints: all others (at most 50 students enroll in a class)"}, {"source": "cluster_B", "cluster_id": 140, "label_hint": "constraints-and-database-based-assertions", "chunk_id": "7- ConstraintsTriggers__0001", "lecture_id": "7- ConstraintsTriggers", "text": "After this lecture, you should be able to:\n- Define Database Constraints, including\n- Referential integrity constraints\n- Attribute -level constraints\n- Tuple -level constraints\n- Assertions\n- Define database triggers\n2\n- Constraints\n- Foreign -key, or referential -integrity constraints.\n- Value -based constraints.\n- Tuple -based constraints.\n- Assertions.\n- Triggers"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 19, "lecture_id": "7- ConstraintsTriggers", "chunk_id": "7- ConstraintsTriggers__0001"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0010"}, "gap_lectures": -15}}}
{"A": {"name": "ENTITY_SET", "role": "NA"}, "B": {"name": "MANY_ONE_RELATIONSHIP", "role": "NA"}, "relation": "depends_on", "justification": "The evidence shows that understanding many-one relationships is necessary to identify entities uniquely within an entity set, indicating that many-one relationships are a prerequisite for understanding entity sets.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 116, "label_hint": "entity-and-set-uniquely-weak", "chunk_id": "12-Conceptual_Logical_DB_Design__0021", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "supporting entity set supporting relationship set\nweak Entity set"}, {"source": "cluster_B", "cluster_id": 116, "label_hint": "entity-and-set-uniquely-weak", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0012", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Occasionally, entities of an entity set need 'help' to identify them uniquely.\n- Entity set E is weak if in order to identify entities of E uniquely, we need to follow one or more many-one relationships from E and include the key of the related entity sets.\n- Note: not an is-a relationship because E is not a 'subclass' of F: Univ and Team"}, {"source": "cluster_B", "cluster_id": 116, "label_hint": "entity-and-set-uniquely-weak", "chunk_id": "12-Conceptual_Logical_DB_Design__0012", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Occasionally, entities of an entity set need 'help' to identify them uniquely.\n- Entity set E is weak if in order to identify entities of E uniquely, we need to follow one or more many-one relationships from E and include the key of the related entity sets.\n- Note: not an is-a relationship because E is not a 'subclass' of F: Univ and Team"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0006"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0005"}, "gap_lectures": 0}}}
{"A": {"name": "FOREIGN_KEY", "role": "NA"}, "B": {"name": "FOREIGN_KEYS", "role": "NA"}, "relation": "part_of", "justification": "FOREIGN_KEY is a specific instance of FOREIGN_KEYS, indicating that FOREIGN_KEY is part of the broader concept FOREIGN_KEYS.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0016", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nWhat are the attributes and what is the key for Assignment?\n```\nProject(P-number, P-name, Due-Date) Employee(SSN, E-Name, Office)\n```\nProject\nP-number P-name Due-Date\nEmployee\nSSN\nE-Name\nOffice\n0..*     Assignment      0..*\n- 0..*        Manager        1..1\nAnswer: Assignment(P-Number, SSN)\nP-Number is a foreign key for Project SSN is a foreign key for Employee\nProject(P-Number, P-Due-Date)\nEmployee(SSN, E-Name, Office)"}, {"source": "cluster_A", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0018", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nMgrSSN is a foreign key (referencing the Employee relation)\nvalue of Manager must match an SSN\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nvs.\nProject(P-number, P-name, Due-Date)\nEmployee(SSN, E-Name, Office)\nManager(P-number, SSN)\nWhat are the tradeoffs between these two?\nNote: P-number is the key for Manager"}, {"source": "cluster_B", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design__0018", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nMgrSSN is a foreign key (referencing the Employee relation)\nvalue of Manager must match an SSN\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nvs.\nProject(P-number, P-name, Due-Date)\nEmployee(SSN, E-Name, Office)\nManager(P-number, SSN)\nWhat are the tradeoffs between these two?\nNote: P-number is the key for Manager"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 2, "reason": "A and B appear in different chunks within 2 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0000"}, "gap_lectures": 0}}}
{"A": {"name": "FOREIGN_KEY", "role": "NA"}, "B": {"name": "FOREIGN_KEY_CONSTRAINT", "role": "NA"}, "relation": "part_of", "justification": "FOREIGN_KEY_CONSTRAINT is a specific type of constraint that enforces the FOREIGN_KEY relationship, indicating that FOREIGN_KEY is part of FOREIGN_KEY_CONSTRAINT.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 107, "label_hint": "drink-and-char-20-drinks", "chunk_id": "7- ConstraintsTriggers__0003", "lecture_id": "7- ConstraintsTriggers", "text": "- Consider Relation Sells(cafe, drink, price).\n- We might expect that a drink value is a real drink ---something appearing in Drink.name\n- A constraint that requires a drink in Sells to be a drink in Drinks is called a foreign -key constraint."}, {"source": "cluster_A", "cluster_id": 107, "label_hint": "drink-and-char-20-drinks", "chunk_id": "7- ConstraintsTriggers__0005", "lecture_id": "7- ConstraintsTriggers", "text": "```\nCREATE TABLE Drinks ( name  CHAR(20) PRIMARY KEY, manf CHAR(20) ); CREATE TABLE Sells ( cafe CHAR(20), drink CHAR(20) REFERENCES Drinks(name), price REAL );\n```\nI ILLINOIS\n8"}, {"source": "cluster_A", "cluster_id": 107, "label_hint": "drink-and-char-20-drinks", "chunk_id": "7- ConstraintsTriggers__0006", "lecture_id": "7- ConstraintsTriggers", "text": "```\nCREATE TABLE Drinks ( name CHAR(20) PRIMARY KEY, manf CHAR(20) ); CREATE TABLE Sells ( cafe CHAR(20), drink CHAR(20), price REAL,\n```\n```\nFOREIGN KEY(drink) REFERENCES Drink(name)); 9 I ILLINOIS\n```"}, {"source": "cluster_B", "cluster_id": 107, "label_hint": "drink-and-char-20-drinks", "chunk_id": "7- ConstraintsTriggers__0018", "lecture_id": "7- ConstraintsTriggers", "text": "```\n… drink CHAR(20) CHECK ( drink IN (SELECT name FROM Drinks))\n```\nThe drink check seems similar to Foreign Key constraints.\nHowever, the timing of enforcement is different."}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 19, "lecture_id": "7- ConstraintsTriggers", "chunk_id": "7- ConstraintsTriggers__0004"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0000"}, "gap_lectures": -19}}}
{"A": {"name": "FOREIGN_KEY", "role": "NA"}, "B": {"name": "KEYS", "role": "NA"}, "relation": "part_of", "justification": "FOREIGN_KEY is a specific type of key within the broader concept of KEYS.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 103, "label_hint": "keys-and-model-foreign-relational", "chunk_id": "1-RelationalModel__0000", "lecture_id": "1-RelationalModel", "text": "- Define a data model\n- Define the relational data model\n- Articulate the basic terminologies of the relational data model (from a practical perspective)\n- Define Primary and Foreign keys"}, {"source": "cluster_B", "cluster_id": 103, "label_hint": "keys-and-model-foreign-relational", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0001", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Relational model has:\n- tables (relations) with attributes, keys, foreign keys, domain definitions for attributes"}, {"source": "cluster_B", "cluster_id": 103, "label_hint": "keys-and-model-foreign-relational", "chunk_id": "12-Conceptual_Logical_DB_Design__0001", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Relational model has:\n- tables (relations) with attributes, keys, foreign keys, domain definitions for attributes"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0000"}, "gap_lectures": 0}}}
{"A": {"name": "FOREIGN_KEYS", "role": "NA"}, "B": {"name": "FROM_CLAUSE", "role": "NA"}, "relation": "depends_on", "justification": "FOREIGN_KEYS are introduced and explained in the context of relational database models, while FROM_CLAUSE is used in SQL queries. FOREIGN_KEYS need to be understood before using FROM_CLAUSE in SQL queries to ensure proper referencing and integrity.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0012", "lecture_id": "1-RelationalModel", "text": "The intension of the table\n101, Owner = J. Smith. 101, Balance = 1000.00. 101, Type = checking. 102, Owner = W. Wei. 102, Balance = 2000.00. 102, Type = checking. 103, Owner = J. Smith. 103, Balance = 5000.00. 103, Type = savings. 104, Owner = M. Jones. 104, Balance = 1000.00. 104, Type = checking. 105, Owner = H. Martin. 105, Balance = 10,000.00. 105, Type = checking\nThe extension of the table.  Also called the extent .\n, Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. Cardinality, Number = 102. Cardinality, Owner = W. Wei. Cardinality, Balance = 2000.00. Cardinality, Type = checking. of this instance is 5 (because, Number = 103. of this instance is 5 (because, Owner = J. Smith. of this instance is 5 (because, Balance = 5000.00. of this instance is 5 (because, Type = savings. there are 5, Number = 104. there are 5, Owner = M. Jones. there are 5, Balance = 1000.00. there are 5, Type = checking. rows), Number = 105. rows), Owner = H. Martin. rows), Balance = 10,000.00. rows), Type = checking\n-  Data Models\n- Relational Database Model\n-  Basic Concepts and Terminology\n- Keys and Foreign Keys\n- Schema Specifications"}, {"source": "cluster_A", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0015", "lecture_id": "1-RelationalModel", "text": ", Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. , Number = 102. , Owner = W. Wei. , Balance = 2000.00. , Type = checking. , Number = 103. , Owner = J. Smith. , Balance = 5000.00. , Type = savings. , Number = 104. , Owner = M. Jones. , Balance = 1000.00. , Type = checking. , Number = 105. , Owner = H. Martin. , Balance = 10,000.00. , Type = checking. Deposit, Number = AcctNo Transaction-id. Deposit, Owner = Date. Deposit, Balance = Amount. Deposit, Type = . , Number = 102 1. , Owner = 10/22/00. , Balance = 500.00. , Type = . , Number = 102 2. , Owner = 10/29/00. , Balance = 200.00. , Type = . , Number = 104 3. , Owner = 10/29/00. , Balance = 1000.00. , Type = . , Number = 105 4. , Owner = 11/02/00. , Balance = 10,000.00. , Type = . , Number = 106 5. , Owner = 12/05/00. , Balance = 555.00. , Type = \nWe say that Deposit.AcctNo is a foreign key that references Account.Number.  If the DBMS enforces this constraint, we have referential integrity .\n, Foreign keys might or might not be part of the key for the referring table.Number = 101 102 103 104 105. , Foreign keys might or might not be part of the key for the referring table.Owner = J. Smith W. Wei J. Smith M. Jones H. Martin. , Foreign keys might or might not be part of the key for the referring table.Balance = 1000.00 2000.00 5000.00 1000.00 10,000.00. , Foreign keys might or might not be part of the key for the referring table.Type = checking checking savings checking checking. Deposit, Foreign keys might or might not be part of the key for the referring table.Number = AcctNo. Deposit, Foreign keys might or might not be part of the key for the referring table.Owner = Transaction-id. Deposit, Foreign keys might or might not be part of the key for the referring table.Balance = Date. Deposit, Foreign keys might or might not be part of the key for the referring table.Type = Amount. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Number = AcctNo 101 101. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Owner = Check-number 924 925. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Balance = Date 10/23/00 10/24/00. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Type = Amount 125.00 23.98\n-  Data Models\n- Relational Database Model\n-  Basic Concepts and Terminology\n-  Keys and Foreign Keys\n- Schema Specifications"}, {"source": "cluster_B", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "2-SQL-Basics__0005", "lecture_id": "2-SQL-Basics", "text": "Account, 1 = Number. Account, 2 = Owner. Account, 3 = Balance. Account, 4 = T\\pe. , 1 = 101. , 2 = J. Smith. , 3 = 1000.00. , 4 = checking. , 1 = 102. , 2 = W. Wei. , 3 = 2000.00. , 4 = checking. , 1 = 103. , 2 = J. Smith. , 3 = 5000.00. , 4 = savings. , 1 = 104. , 2 = M. Jones. , 3 = 1000.00. , 4 = checking. , 1 = 105. , 2 = H. Martin. , 3 = 10,000.00. , 4 = checking\nSELECT, 1 = Number, Owner. FROM, 1 = Account. WHERE, 1 = T\\pe = \" savings \" ;\nNumber, 1 = Owner\n103\nJ. Smith"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 10, "lecture_id": "2-SQL-Basics", "chunk_id": "2-SQL-Basics__0005"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "gap_lectures": -10}}}
{"A": {"name": "FOREIGN_KEYS", "role": "NA"}, "B": {"name": "FUNCTIONAL_DEPENDENCY", "role": "NA"}, "relation": "depends_on", "justification": "FOREIGN_KEYS depend on FUNCTIONAL_DEPENDENCY because the concept of foreign keys is used to enforce functional dependencies, ensuring that the data remains consistent and anomalies are avoided.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 2, "label_hint": "dnum-and-dname-st-dmgr", "chunk_id": "13-NFs-FDs__0021", "lecture_id": "13-NFs-FDs", "text": "Dept(dnum, dname, dmgr)\n1. Lift the 'troublesome' FD into its own table with dnum as the key.  Now they will be enforced.\nEMP(name, ssn, birthdate, address, dnum, dname, dmgr)\nNew-Emp(name, ssn, birthdate, address, dnum)\n2. Leave the LHS of the 'troublesome' FDs behind. Define a foreign key where New-Emp.dnum REFERENCES Dept.dnum"}, {"source": "cluster_B", "cluster_id": 2, "label_hint": "dnum-and-dname-st-dmgr", "chunk_id": "13-NFs-FDs__0018", "lecture_id": "13-NFs-FDs", "text": "if you want to insert a department, you can't ... until there is at least one employee.\nDeletion anomalies: if you delete an employee, is that dept. gone?  Was this the last employee in that dept.?\nUpdate anomalies: If you want to change dname , for example, you need to change it everywhere!  And you have to find them all first.\nTroublesome FDs cause (redundancy and) update anomalies."}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0012"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "gap_lectures": -6}}}
{"A": {"name": "FOREIGN_KEYS", "role": "NA"}, "B": {"name": "NORMALIZATION", "role": "NA"}, "relation": "depends_on", "justification": "FOREIGN_KEYS are used as a solution to enforce normalization rules, indicating that understanding normalization is a prerequisite for using foreign keys effectively.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 2, "label_hint": "dnum-and-dname-st-dmgr", "chunk_id": "13-NFs-FDs__0021", "lecture_id": "13-NFs-FDs", "text": "Dept(dnum, dname, dmgr)\n1. Lift the 'troublesome' FD into its own table with dnum as the key.  Now they will be enforced.\nEMP(name, ssn, birthdate, address, dnum, dname, dmgr)\nNew-Emp(name, ssn, birthdate, address, dnum)\n2. Leave the LHS of the 'troublesome' FDs behind. Define a foreign key where New-Emp.dnum REFERENCES Dept.dnum"}, {"source": "cluster_B", "cluster_id": 2, "label_hint": "dnum-and-dname-st-dmgr", "chunk_id": "13-NFs-FDs__0017", "lecture_id": "13-NFs-FDs", "text": "caused by 'troublesome' FDs\nEMP(name, SSN, birthdate, address, dnum, dname, dmgr)"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0000"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "gap_lectures": -1}}}
{"A": {"name": "FOREIGN_KEYS", "role": "NA"}, "B": {"name": "PRIMARY_KEY", "role": "NA"}, "relation": "depends_on", "justification": "FOREIGN_KEYS depend on PRIMARY_KEY because foreign keys reference primary keys in other tables, implying that primary keys must be understood first.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 103, "label_hint": "keys-and-model-foreign-relational", "chunk_id": "1-RelationalModel__0016", "lecture_id": "1-RelationalModel", "text": "- Select the tables, with a name for each table.\n- Select columns for each table and give the domain for each column.\n- Specify the key(s) for each table.\n- Specify all appropriate foreign keys.\nThere can be more than one key for a table."}, {"source": "cluster_A", "cluster_id": 103, "label_hint": "keys-and-model-foreign-relational", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0001", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Relational model has:\n- tables (relations) with attributes, keys, foreign keys, domain definitions for attributes"}, {"source": "cluster_A", "cluster_id": 103, "label_hint": "keys-and-model-foreign-relational", "chunk_id": "12-Conceptual_Logical_DB_Design__0001", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Relational model has:\n- tables (relations) with attributes, keys, foreign keys, domain definitions for attributes"}, {"source": "cluster_B", "cluster_id": 103, "label_hint": "keys-and-model-foreign-relational", "chunk_id": "1-RelationalModel__0000", "lecture_id": "1-RelationalModel", "text": "- Define a data model\n- Define the relational data model\n- Articulate the basic terminologies of the relational data model (from a practical perspective)\n- Define Primary and Foreign keys"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0000"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "gap_lectures": 0}}}
{"A": {"name": "FOREIGN_KEYS", "role": "NA"}, "B": {"name": "REDUNDANCY_REDUCTION", "role": "NA"}, "relation": "depends_on", "justification": "FOREIGN_KEYS are used to enforce referential integrity and reduce redundancy in database design, as shown in the evidence where the introduction of foreign keys helps in managing redundancy.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 2, "label_hint": "dnum-and-dname-st-dmgr", "chunk_id": "13-NFs-FDs__0021", "lecture_id": "13-NFs-FDs", "text": "Dept(dnum, dname, dmgr)\n1. Lift the 'troublesome' FD into its own table with dnum as the key.  Now they will be enforced.\nEMP(name, ssn, birthdate, address, dnum, dname, dmgr)\nNew-Emp(name, ssn, birthdate, address, dnum)\n2. Leave the LHS of the 'troublesome' FDs behind. Define a foreign key where New-Emp.dnum REFERENCES Dept.dnum"}, {"source": "cluster_B", "cluster_id": 2, "label_hint": "dnum-and-dname-st-dmgr", "chunk_id": "13-NFs-FDs__0022", "lecture_id": "13-NFs-FDs", "text": "New-EMP(name, SSN, birthdate, address, dnum)\nInsert anomalies: No Problem\n```\nJohn    111 June 3     123 St.      D1 Sue     222 May 15    455 St.       D1 Max    333 Mar. 5      678 St.      D2 Wei     444 May 2      999 St.      D2 Tom    555 June 22   888 St.      D2\n```\nDept(dnum,  dname,  dmgr)\nD1         sales        222\nD2        research  333\nLess redundancy!\nDelete anomalies: No Problem"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0019"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "gap_lectures": -6}}}
{"A": {"name": "FOREIGN_KEYS", "role": "NA"}, "B": {"name": "RELATIONSHIP", "role": "NA"}, "relation": "part_of", "justification": "FOREIGN_KEYS are a specific type of relationship used in database design to establish connections between tables.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design__0018", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nMgrSSN is a foreign key (referencing the Employee relation)\nvalue of Manager must match an SSN\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nvs.\nProject(P-number, P-name, Due-Date)\nEmployee(SSN, E-Name, Office)\nManager(P-number, SSN)\nWhat are the tradeoffs between these two?\nNote: P-number is the key for Manager"}, {"source": "cluster_B", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0016", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nWhat are the attributes and what is the key for Assignment?\n```\nProject(P-number, P-name, Due-Date) Employee(SSN, E-Name, Office)\n```\nProject\nP-number P-name Due-Date\nEmployee\nSSN\nE-Name\nOffice\n0..*     Assignment      0..*\n- 0..*        Manager        1..1\nAnswer: Assignment(P-Number, SSN)\nP-Number is a foreign key for Project SSN is a foreign key for Employee\nProject(P-Number, P-Due-Date)\nEmployee(SSN, E-Name, Office)"}, {"source": "cluster_B", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design__0016", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nWhat are the attributes and what is the key for Assignment?\n```\nProject(P-number, P-name, Due-Date) Employee(SSN, E-Name, Office)\n```\nProject\nP-number P-name Due-Date\nEmployee\nSSN\nE-Name\nOffice\n0..*     Assignment      0..*\n- 0..*        Manager        1..1\nAnswer: Assignment(P-Number, SSN)\nP-Number is a foreign key for Project SSN is a foreign key for Employee\nProject(P-Number, P-Due-Date)\nEmployee(SSN, E-Name, Office)"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0005"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "gap_lectures": -4}}}
{"A": {"name": "FOREIGN_KEYS", "role": "NA"}, "B": {"name": "UPDATE_ANOMALIES", "role": "NA"}, "relation": "depends_on", "justification": "FOREIGN_KEYS are introduced as a solution to enforce the 'troublesome' FDs, which are related to the update anomalies discussed in the context of the EMP table.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 2, "label_hint": "dnum-and-dname-st-dmgr", "chunk_id": "13-NFs-FDs__0021", "lecture_id": "13-NFs-FDs", "text": "Dept(dnum, dname, dmgr)\n1. Lift the 'troublesome' FD into its own table with dnum as the key.  Now they will be enforced.\nEMP(name, ssn, birthdate, address, dnum, dname, dmgr)\nNew-Emp(name, ssn, birthdate, address, dnum)\n2. Leave the LHS of the 'troublesome' FDs behind. Define a foreign key where New-Emp.dnum REFERENCES Dept.dnum"}, {"source": "cluster_B", "cluster_id": 2, "label_hint": "dnum-and-dname-st-dmgr", "chunk_id": "13-NFs-FDs__0020", "lecture_id": "13-NFs-FDs", "text": "EMP(name, ssn, birthdate, address, dnum, dname, dmgr)\nWe have a problem! dnum is NOT the key for this table!\nSo these blue FDs will not be enforced automatically by the DBMS (using only keys). And there can be redundancy and update anomalies"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0014"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "gap_lectures": -6}}}
{"A": {"name": "FOREIGN_KEYS", "role": "NA"}, "B": {"name": "WHERE_CLAUSE", "role": "NA"}, "relation": "depends_on", "justification": "FOREIGN_KEYS are introduced in the context of database constraints and referential integrity, which are foundational concepts that must be understood before learning more advanced SQL operations like WHERE_CLAUSE.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0012", "lecture_id": "1-RelationalModel", "text": "The intension of the table\n101, Owner = J. Smith. 101, Balance = 1000.00. 101, Type = checking. 102, Owner = W. Wei. 102, Balance = 2000.00. 102, Type = checking. 103, Owner = J. Smith. 103, Balance = 5000.00. 103, Type = savings. 104, Owner = M. Jones. 104, Balance = 1000.00. 104, Type = checking. 105, Owner = H. Martin. 105, Balance = 10,000.00. 105, Type = checking\nThe extension of the table.  Also called the extent .\n, Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. Cardinality, Number = 102. Cardinality, Owner = W. Wei. Cardinality, Balance = 2000.00. Cardinality, Type = checking. of this instance is 5 (because, Number = 103. of this instance is 5 (because, Owner = J. Smith. of this instance is 5 (because, Balance = 5000.00. of this instance is 5 (because, Type = savings. there are 5, Number = 104. there are 5, Owner = M. Jones. there are 5, Balance = 1000.00. there are 5, Type = checking. rows), Number = 105. rows), Owner = H. Martin. rows), Balance = 10,000.00. rows), Type = checking\n-  Data Models\n- Relational Database Model\n-  Basic Concepts and Terminology\n- Keys and Foreign Keys\n- Schema Specifications"}, {"source": "cluster_A", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0015", "lecture_id": "1-RelationalModel", "text": ", Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. , Number = 102. , Owner = W. Wei. , Balance = 2000.00. , Type = checking. , Number = 103. , Owner = J. Smith. , Balance = 5000.00. , Type = savings. , Number = 104. , Owner = M. Jones. , Balance = 1000.00. , Type = checking. , Number = 105. , Owner = H. Martin. , Balance = 10,000.00. , Type = checking. Deposit, Number = AcctNo Transaction-id. Deposit, Owner = Date. Deposit, Balance = Amount. Deposit, Type = . , Number = 102 1. , Owner = 10/22/00. , Balance = 500.00. , Type = . , Number = 102 2. , Owner = 10/29/00. , Balance = 200.00. , Type = . , Number = 104 3. , Owner = 10/29/00. , Balance = 1000.00. , Type = . , Number = 105 4. , Owner = 11/02/00. , Balance = 10,000.00. , Type = . , Number = 106 5. , Owner = 12/05/00. , Balance = 555.00. , Type = \nWe say that Deposit.AcctNo is a foreign key that references Account.Number.  If the DBMS enforces this constraint, we have referential integrity .\n, Foreign keys might or might not be part of the key for the referring table.Number = 101 102 103 104 105. , Foreign keys might or might not be part of the key for the referring table.Owner = J. Smith W. Wei J. Smith M. Jones H. Martin. , Foreign keys might or might not be part of the key for the referring table.Balance = 1000.00 2000.00 5000.00 1000.00 10,000.00. , Foreign keys might or might not be part of the key for the referring table.Type = checking checking savings checking checking. Deposit, Foreign keys might or might not be part of the key for the referring table.Number = AcctNo. Deposit, Foreign keys might or might not be part of the key for the referring table.Owner = Transaction-id. Deposit, Foreign keys might or might not be part of the key for the referring table.Balance = Date. Deposit, Foreign keys might or might not be part of the key for the referring table.Type = Amount. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Number = AcctNo 101 101. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Owner = Check-number 924 925. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Balance = Date 10/23/00 10/24/00. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Type = Amount 125.00 23.98\n-  Data Models\n- Relational Database Model\n-  Basic Concepts and Terminology\n-  Keys and Foreign Keys\n- Schema Specifications"}, {"source": "cluster_B", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "2-SQL-Basics__0005", "lecture_id": "2-SQL-Basics", "text": "Account, 1 = Number. Account, 2 = Owner. Account, 3 = Balance. Account, 4 = T\\pe. , 1 = 101. , 2 = J. Smith. , 3 = 1000.00. , 4 = checking. , 1 = 102. , 2 = W. Wei. , 3 = 2000.00. , 4 = checking. , 1 = 103. , 2 = J. Smith. , 3 = 5000.00. , 4 = savings. , 1 = 104. , 2 = M. Jones. , 3 = 1000.00. , 4 = checking. , 1 = 105. , 2 = H. Martin. , 3 = 10,000.00. , 4 = checking\nSELECT, 1 = Number, Owner. FROM, 1 = Account. WHERE, 1 = T\\pe = \" savings \" ;\nNumber, 1 = Owner\n103\nJ. Smith"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 10, "lecture_id": "2-SQL-Basics", "chunk_id": "2-SQL-Basics__0005"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "gap_lectures": -10}}}
{"A": {"name": "FOREIGN_KEY_CONSTRAINT", "role": "NA"}, "B": {"name": "PRIMARY_KEY", "role": "NA"}, "relation": "depends_on", "justification": "FOREIGN_KEY_CONSTRAINT depends on PRIMARY_KEY because a foreign key constraint references a primary key in another table, implying that the primary key must be defined first.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 107, "label_hint": "drink-and-char-20-drinks", "chunk_id": "7- ConstraintsTriggers__0018", "lecture_id": "7- ConstraintsTriggers", "text": "```\n… drink CHAR(20) CHECK ( drink IN (SELECT name FROM Drinks))\n```\nThe drink check seems similar to Foreign Key constraints.\nHowever, the timing of enforcement is different."}, {"source": "cluster_B", "cluster_id": 107, "label_hint": "drink-and-char-20-drinks", "chunk_id": "7- ConstraintsTriggers__0005", "lecture_id": "7- ConstraintsTriggers", "text": "```\nCREATE TABLE Drinks ( name  CHAR(20) PRIMARY KEY, manf CHAR(20) ); CREATE TABLE Sells ( cafe CHAR(20), drink CHAR(20) REFERENCES Drinks(name), price REAL );\n```\nI ILLINOIS\n8"}, {"source": "cluster_B", "cluster_id": 107, "label_hint": "drink-and-char-20-drinks", "chunk_id": "7- ConstraintsTriggers__0006", "lecture_id": "7- ConstraintsTriggers", "text": "```\nCREATE TABLE Drinks ( name CHAR(20) PRIMARY KEY, manf CHAR(20) ); CREATE TABLE Sells ( cafe CHAR(20), drink CHAR(20), price REAL,\n```\n```\nFOREIGN KEY(drink) REFERENCES Drink(name)); 9 I ILLINOIS\n```"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0000"}, "A_first_introduced_at": {"lecture_index": 19, "lecture_id": "7- ConstraintsTriggers", "chunk_id": "7- ConstraintsTriggers__0004"}, "gap_lectures": 19}}}
{"A": {"name": "FROM_CLAUSE", "role": "NA"}, "B": {"name": "KEYS", "role": "NA"}, "relation": "depends_on", "justification": "FROM_CLAUSE requires an understanding of the structure of the database, including the concept of keys, to correctly reference tables.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "2-SQL-Basics__0005", "lecture_id": "2-SQL-Basics", "text": "Account, 1 = Number. Account, 2 = Owner. Account, 3 = Balance. Account, 4 = T\\pe. , 1 = 101. , 2 = J. Smith. , 3 = 1000.00. , 4 = checking. , 1 = 102. , 2 = W. Wei. , 3 = 2000.00. , 4 = checking. , 1 = 103. , 2 = J. Smith. , 3 = 5000.00. , 4 = savings. , 1 = 104. , 2 = M. Jones. , 3 = 1000.00. , 4 = checking. , 1 = 105. , 2 = H. Martin. , 3 = 10,000.00. , 4 = checking\nSELECT, 1 = Number, Owner. FROM, 1 = Account. WHERE, 1 = T\\pe = \" savings \" ;\nNumber, 1 = Owner\n103\nJ. Smith"}, {"source": "cluster_B", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0012", "lecture_id": "1-RelationalModel", "text": "The intension of the table\n101, Owner = J. Smith. 101, Balance = 1000.00. 101, Type = checking. 102, Owner = W. Wei. 102, Balance = 2000.00. 102, Type = checking. 103, Owner = J. Smith. 103, Balance = 5000.00. 103, Type = savings. 104, Owner = M. Jones. 104, Balance = 1000.00. 104, Type = checking. 105, Owner = H. Martin. 105, Balance = 10,000.00. 105, Type = checking\nThe extension of the table.  Also called the extent .\n, Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. Cardinality, Number = 102. Cardinality, Owner = W. Wei. Cardinality, Balance = 2000.00. Cardinality, Type = checking. of this instance is 5 (because, Number = 103. of this instance is 5 (because, Owner = J. Smith. of this instance is 5 (because, Balance = 5000.00. of this instance is 5 (because, Type = savings. there are 5, Number = 104. there are 5, Owner = M. Jones. there are 5, Balance = 1000.00. there are 5, Type = checking. rows), Number = 105. rows), Owner = H. Martin. rows), Balance = 10,000.00. rows), Type = checking\n-  Data Models\n- Relational Database Model\n-  Basic Concepts and Terminology\n- Keys and Foreign Keys\n- Schema Specifications"}, {"source": "cluster_B", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0015", "lecture_id": "1-RelationalModel", "text": ", Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. , Number = 102. , Owner = W. Wei. , Balance = 2000.00. , Type = checking. , Number = 103. , Owner = J. Smith. , Balance = 5000.00. , Type = savings. , Number = 104. , Owner = M. Jones. , Balance = 1000.00. , Type = checking. , Number = 105. , Owner = H. Martin. , Balance = 10,000.00. , Type = checking. Deposit, Number = AcctNo Transaction-id. Deposit, Owner = Date. Deposit, Balance = Amount. Deposit, Type = . , Number = 102 1. , Owner = 10/22/00. , Balance = 500.00. , Type = . , Number = 102 2. , Owner = 10/29/00. , Balance = 200.00. , Type = . , Number = 104 3. , Owner = 10/29/00. , Balance = 1000.00. , Type = . , Number = 105 4. , Owner = 11/02/00. , Balance = 10,000.00. , Type = . , Number = 106 5. , Owner = 12/05/00. , Balance = 555.00. , Type = \nWe say that Deposit.AcctNo is a foreign key that references Account.Number.  If the DBMS enforces this constraint, we have referential integrity .\n, Foreign keys might or might not be part of the key for the referring table.Number = 101 102 103 104 105. , Foreign keys might or might not be part of the key for the referring table.Owner = J. Smith W. Wei J. Smith M. Jones H. Martin. , Foreign keys might or might not be part of the key for the referring table.Balance = 1000.00 2000.00 5000.00 1000.00 10,000.00. , Foreign keys might or might not be part of the key for the referring table.Type = checking checking savings checking checking. Deposit, Foreign keys might or might not be part of the key for the referring table.Number = AcctNo. Deposit, Foreign keys might or might not be part of the key for the referring table.Owner = Transaction-id. Deposit, Foreign keys might or might not be part of the key for the referring table.Balance = Date. Deposit, Foreign keys might or might not be part of the key for the referring table.Type = Amount. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Number = AcctNo 101 101. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Owner = Check-number 924 925. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Balance = Date 10/23/00 10/24/00. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Type = Amount 125.00 23.98\n-  Data Models\n- Relational Database Model\n-  Basic Concepts and Terminology\n-  Keys and Foreign Keys\n- Schema Specifications"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "A_first_introduced_at": {"lecture_index": 10, "lecture_id": "2-SQL-Basics", "chunk_id": "2-SQL-Basics__0005"}, "gap_lectures": 10}}}
{"A": {"name": "FROM_CLAUSE", "role": "NA"}, "B": {"name": "REFERENTIAL_INTEGRITY", "role": "NA"}, "relation": null, "justification": "There is no clear connection between FROM_CLAUSE and REFERENTIAL_INTEGRITY based on the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "2-SQL-Basics__0005", "lecture_id": "2-SQL-Basics", "text": "Account, 1 = Number. Account, 2 = Owner. Account, 3 = Balance. Account, 4 = T\\pe. , 1 = 101. , 2 = J. Smith. , 3 = 1000.00. , 4 = checking. , 1 = 102. , 2 = W. Wei. , 3 = 2000.00. , 4 = checking. , 1 = 103. , 2 = J. Smith. , 3 = 5000.00. , 4 = savings. , 1 = 104. , 2 = M. Jones. , 3 = 1000.00. , 4 = checking. , 1 = 105. , 2 = H. Martin. , 3 = 10,000.00. , 4 = checking\nSELECT, 1 = Number, Owner. FROM, 1 = Account. WHERE, 1 = T\\pe = \" savings \" ;\nNumber, 1 = Owner\n103\nJ. Smith"}, {"source": "cluster_B", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0015", "lecture_id": "1-RelationalModel", "text": ", Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. , Number = 102. , Owner = W. Wei. , Balance = 2000.00. , Type = checking. , Number = 103. , Owner = J. Smith. , Balance = 5000.00. , Type = savings. , Number = 104. , Owner = M. Jones. , Balance = 1000.00. , Type = checking. , Number = 105. , Owner = H. Martin. , Balance = 10,000.00. , Type = checking. Deposit, Number = AcctNo Transaction-id. Deposit, Owner = Date. Deposit, Balance = Amount. Deposit, Type = . , Number = 102 1. , Owner = 10/22/00. , Balance = 500.00. , Type = . , Number = 102 2. , Owner = 10/29/00. , Balance = 200.00. , Type = . , Number = 104 3. , Owner = 10/29/00. , Balance = 1000.00. , Type = . , Number = 105 4. , Owner = 11/02/00. , Balance = 10,000.00. , Type = . , Number = 106 5. , Owner = 12/05/00. , Balance = 555.00. , Type = \nWe say that Deposit.AcctNo is a foreign key that references Account.Number.  If the DBMS enforces this constraint, we have referential integrity .\n, Foreign keys might or might not be part of the key for the referring table.Number = 101 102 103 104 105. , Foreign keys might or might not be part of the key for the referring table.Owner = J. Smith W. Wei J. Smith M. Jones H. Martin. , Foreign keys might or might not be part of the key for the referring table.Balance = 1000.00 2000.00 5000.00 1000.00 10,000.00. , Foreign keys might or might not be part of the key for the referring table.Type = checking checking savings checking checking. Deposit, Foreign keys might or might not be part of the key for the referring table.Number = AcctNo. Deposit, Foreign keys might or might not be part of the key for the referring table.Owner = Transaction-id. Deposit, Foreign keys might or might not be part of the key for the referring table.Balance = Date. Deposit, Foreign keys might or might not be part of the key for the referring table.Type = Amount. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Number = AcctNo 101 101. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Owner = Check-number 924 925. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Balance = Date 10/23/00 10/24/00. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Type = Amount 125.00 23.98\n-  Data Models\n- Relational Database Model\n-  Basic Concepts and Terminology\n-  Keys and Foreign Keys\n- Schema Specifications"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0015"}, "A_first_introduced_at": {"lecture_index": 10, "lecture_id": "2-SQL-Basics", "chunk_id": "2-SQL-Basics__0005"}, "gap_lectures": 10}}}
{"A": {"name": "FROM_CLAUSE", "role": "NA"}, "B": {"name": "SCHEMA_SPECIFICATIONS", "role": "NA"}, "relation": "depends_on", "justification": "FROM_CLAUSE depends on SCHEMA_SPECIFICATIONS because understanding the schema of the database is necessary to correctly use the FROM_CLAUSE in SQL queries.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "2-SQL-Basics__0005", "lecture_id": "2-SQL-Basics", "text": "Account, 1 = Number. Account, 2 = Owner. Account, 3 = Balance. Account, 4 = T\\pe. , 1 = 101. , 2 = J. Smith. , 3 = 1000.00. , 4 = checking. , 1 = 102. , 2 = W. Wei. , 3 = 2000.00. , 4 = checking. , 1 = 103. , 2 = J. Smith. , 3 = 5000.00. , 4 = savings. , 1 = 104. , 2 = M. Jones. , 3 = 1000.00. , 4 = checking. , 1 = 105. , 2 = H. Martin. , 3 = 10,000.00. , 4 = checking\nSELECT, 1 = Number, Owner. FROM, 1 = Account. WHERE, 1 = T\\pe = \" savings \" ;\nNumber, 1 = Owner\n103\nJ. Smith"}, {"source": "cluster_B", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0012", "lecture_id": "1-RelationalModel", "text": "The intension of the table\n101, Owner = J. Smith. 101, Balance = 1000.00. 101, Type = checking. 102, Owner = W. Wei. 102, Balance = 2000.00. 102, Type = checking. 103, Owner = J. Smith. 103, Balance = 5000.00. 103, Type = savings. 104, Owner = M. Jones. 104, Balance = 1000.00. 104, Type = checking. 105, Owner = H. Martin. 105, Balance = 10,000.00. 105, Type = checking\nThe extension of the table.  Also called the extent .\n, Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. Cardinality, Number = 102. Cardinality, Owner = W. Wei. Cardinality, Balance = 2000.00. Cardinality, Type = checking. of this instance is 5 (because, Number = 103. of this instance is 5 (because, Owner = J. Smith. of this instance is 5 (because, Balance = 5000.00. of this instance is 5 (because, Type = savings. there are 5, Number = 104. there are 5, Owner = M. Jones. there are 5, Balance = 1000.00. there are 5, Type = checking. rows), Number = 105. rows), Owner = H. Martin. rows), Balance = 10,000.00. rows), Type = checking\n-  Data Models\n- Relational Database Model\n-  Basic Concepts and Terminology\n- Keys and Foreign Keys\n- Schema Specifications"}, {"source": "cluster_B", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0015", "lecture_id": "1-RelationalModel", "text": ", Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. , Number = 102. , Owner = W. Wei. , Balance = 2000.00. , Type = checking. , Number = 103. , Owner = J. Smith. , Balance = 5000.00. , Type = savings. , Number = 104. , Owner = M. Jones. , Balance = 1000.00. , Type = checking. , Number = 105. , Owner = H. Martin. , Balance = 10,000.00. , Type = checking. Deposit, Number = AcctNo Transaction-id. Deposit, Owner = Date. Deposit, Balance = Amount. Deposit, Type = . , Number = 102 1. , Owner = 10/22/00. , Balance = 500.00. , Type = . , Number = 102 2. , Owner = 10/29/00. , Balance = 200.00. , Type = . , Number = 104 3. , Owner = 10/29/00. , Balance = 1000.00. , Type = . , Number = 105 4. , Owner = 11/02/00. , Balance = 10,000.00. , Type = . , Number = 106 5. , Owner = 12/05/00. , Balance = 555.00. , Type = \nWe say that Deposit.AcctNo is a foreign key that references Account.Number.  If the DBMS enforces this constraint, we have referential integrity .\n, Foreign keys might or might not be part of the key for the referring table.Number = 101 102 103 104 105. , Foreign keys might or might not be part of the key for the referring table.Owner = J. Smith W. Wei J. Smith M. Jones H. Martin. , Foreign keys might or might not be part of the key for the referring table.Balance = 1000.00 2000.00 5000.00 1000.00 10,000.00. , Foreign keys might or might not be part of the key for the referring table.Type = checking checking savings checking checking. Deposit, Foreign keys might or might not be part of the key for the referring table.Number = AcctNo. Deposit, Foreign keys might or might not be part of the key for the referring table.Owner = Transaction-id. Deposit, Foreign keys might or might not be part of the key for the referring table.Balance = Date. Deposit, Foreign keys might or might not be part of the key for the referring table.Type = Amount. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Number = AcctNo 101 101. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Owner = Check-number 924 925. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Balance = Date 10/23/00 10/24/00. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Type = Amount 125.00 23.98\n-  Data Models\n- Relational Database Model\n-  Basic Concepts and Terminology\n-  Keys and Foreign Keys\n- Schema Specifications"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "A_first_introduced_at": {"lecture_index": 10, "lecture_id": "2-SQL-Basics", "chunk_id": "2-SQL-Basics__0005"}, "gap_lectures": 10}}}
{"A": {"name": "FUNCTIONAL_DEPENDENCIES", "role": "NA"}, "B": {"name": "FUNCTIONAL_DEPENDENCY", "role": "NA"}, "relation": "part_of", "justification": "Functional Dependencies (A) is a broader concept that includes specific instances of Functional Dependency (B).", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 1, "label_hint": "dept-and-phone-dnum-1234", "chunk_id": "15-NFs-3NF__0003", "lecture_id": "15-NFs-3NF", "text": "1234, Address = 10 Downing. 1234, Phone = 1234. 1234, Name = John. 5678, Address = 10 Downing. 5678, Phone = 5678. 5678, Name = John\nFD '\ns:  Phone \nAddress;      Address, Name  Phone\nNo problem so far. All\nlocal FD ' s are satisfied.\nLet's put all the data into a single table:\n1234, Address = 10 Downing. 1234, Name = John. 5678, Address = 10 Downing. 5678, Name = John\nViolates the dependency:   Address, Name\n Phone"}, {"source": "cluster_B", "cluster_id": 1, "label_hint": "dept-and-phone-dnum-1234", "chunk_id": "13-NFs-FDs__0012", "lecture_id": "13-NFs-FDs", "text": "Consider this table:\nEmp(ssn, name, phone, dnum, dept-name)\nSuppose there is an FD from dnum → dept-name\nBut ssn is the key for this table.\nWhat will prevent two names for one dept?"}, {"source": "cluster_B", "cluster_id": 1, "label_hint": "dept-and-phone-dnum-1234", "chunk_id": "13-NFs-FDs__0013", "lecture_id": "13-NFs-FDs", "text": "Consider this table:\nEmp(ssn, name, phone, dnum, dept-name)\n, ssn = 111111111. , Nam e = John. , Phone = 555-1234. , Dnum = 12. , Dept-name = Sales. , ssn = 222222222. , Nam e = Mary. , Phone = 555-7890. , Dnum = 12. , Dept-name = Marketing. , ssn = …. , Nam e = . , Phone = . , Dnum = . , Dept-name = \nCan we put these two rows in this table?\nYes, it doesn't violate the key constraint.\nBut, the FD from dept to dept-name is violated!  We shouldn't have two different names for dnum 12!"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 2, "reason": "A and B appear in different chunks within 2 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0012"}, "A_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0003"}, "gap_lectures": 0}}}
{"A": {"name": "FUNCTIONAL_DEPENDENCIES", "role": "NA"}, "B": {"name": "INDEXING", "role": "NA"}, "relation": "depends_on", "justification": "Functional dependencies are used in the logical design phase to refine the relational schema, while indexing is discussed in the physical database design phase, indicating that understanding functional dependencies is a prerequisite for discussing indexing.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "13-NFs-FDs__0003", "lecture_id": "13-NFs-FDs", "text": "- Start with the original db schema R\n- From ER translation or otherwise\n- Identify its functional dependencies\n- Use them to transform R until we get a good design R*"}, {"source": "cluster_B", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "15-NFs-3NF__0017", "lecture_id": "15-NFs-3NF", "text": "- Conceptual design:  (ER & UML Models are used\n- for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\nWe'll discuss indexing next.\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 2, "lecture_id": "11-Neo4J-Part2", "chunk_id": "11-Neo4J-Part2__0005"}, "A_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0003"}, "gap_lectures": 4}}}
{"A": {"name": "FUNCTIONAL_DEPENDENCIES", "role": "NA"}, "B": {"name": "LOGICAL_DESIGN", "role": "NA"}, "relation": "depends_on", "justification": "Functional dependencies are used in the process of transforming the ER design to a relational schema, which is part of the logical design phase.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "13-NFs-FDs__0003", "lecture_id": "13-NFs-FDs", "text": "- Start with the original db schema R\n- From ER translation or otherwise\n- Identify its functional dependencies\n- Use them to transform R until we get a good design R*"}, {"source": "cluster_B", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0000", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "cluster_B", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "12-Conceptual_Logical_DB_Design__0000", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "cluster_B", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "13-NFs-FDs__0001", "lecture_id": "13-NFs-FDs", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "A_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0003"}, "gap_lectures": 2}}}
{"A": {"name": "FUNCTIONAL_DEPENDENCIES", "role": "NA"}, "B": {"name": "NORMAL_FORM", "role": "NA"}, "relation": "depends_on", "justification": "Functional dependencies are a prerequisite concept for understanding normal forms, as they are used in the decomposition and normalization processes.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 47, "label_hint": "normal-and-form-bcnf-3nf", "chunk_id": "DBDesign_BCNF__0003", "lecture_id": "DBDesign_BCNF", "text": "- X  A is OK, if X is a (super)key\n- X  A is NOT OK, otherwise\n- Need to decompose the table, but how?\nBoyce-Codd Normal Form (BCNF)"}, {"source": "cluster_B", "cluster_id": 47, "label_hint": "normal-and-form-bcnf-3nf", "chunk_id": "15-NFs-3NF__0001", "lecture_id": "15-NFs-3NF", "text": "First Normal Form = all attributes are atomic Second Normal Form (2NF) = old and obsolete\nBoyce Codd Normal Form (BCNF)\nThird Normal Form (3NF)\nOthers..."}, {"source": "cluster_B", "cluster_id": 47, "label_hint": "normal-and-form-bcnf-3nf", "chunk_id": "DBDesign_BCNF__0001", "lecture_id": "DBDesign_BCNF", "text": "First Normal Form = all attributes are atomic Second Normal Form (2NF) = old and obsolete\nBoyce Codd Normal Form (BCNF) Third Normal Form (3NF)\nOthers..."}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 7, "lecture_id": "15-NFs-3NF", "chunk_id": "15-NFs-3NF__0001"}, "A_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0003"}, "gap_lectures": -1}}}
{"A": {"name": "FUNCTIONAL_DEPENDENCIES", "role": "NA"}, "B": {"name": "PHYSICAL_DESIGN", "role": "NA"}, "relation": "depends_on", "justification": "Functional dependencies are used in the schema refinement process, which is a prerequisite step before physical database design and tuning.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "13-NFs-FDs__0003", "lecture_id": "13-NFs-FDs", "text": "- Start with the original db schema R\n- From ER translation or otherwise\n- Identify its functional dependencies\n- Use them to transform R until we get a good design R*"}, {"source": "cluster_B", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0000", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "cluster_B", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "12-Conceptual_Logical_DB_Design__0000", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "cluster_B", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "13-NFs-FDs__0001", "lecture_id": "13-NFs-FDs", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "A_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0003"}, "gap_lectures": 2}}}
{"A": {"name": "FUNCTIONAL_DEPENDENCIES", "role": "NA"}, "B": {"name": "PRIMARY_KEY", "role": "NA"}, "relation": "depends_on", "justification": "Functional dependencies require an understanding of primary keys to ensure data integrity and prevent anomalies.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 1, "label_hint": "dept-and-phone-dnum-1234", "chunk_id": "15-NFs-3NF__0003", "lecture_id": "15-NFs-3NF", "text": "1234, Address = 10 Downing. 1234, Phone = 1234. 1234, Name = John. 5678, Address = 10 Downing. 5678, Phone = 5678. 5678, Name = John\nFD '\ns:  Phone \nAddress;      Address, Name  Phone\nNo problem so far. All\nlocal FD ' s are satisfied.\nLet's put all the data into a single table:\n1234, Address = 10 Downing. 1234, Name = John. 5678, Address = 10 Downing. 5678, Name = John\nViolates the dependency:   Address, Name\n Phone"}, {"source": "cluster_B", "cluster_id": 1, "label_hint": "dept-and-phone-dnum-1234", "chunk_id": "13-NFs-FDs__0012", "lecture_id": "13-NFs-FDs", "text": "Consider this table:\nEmp(ssn, name, phone, dnum, dept-name)\nSuppose there is an FD from dnum → dept-name\nBut ssn is the key for this table.\nWhat will prevent two names for one dept?"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0000"}, "A_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0003"}, "gap_lectures": 6}}}
{"A": {"name": "FUNCTIONAL_DEPENDENCIES", "role": "NA"}, "B": {"name": "PROJECT_MANAGEMENT", "role": "NA"}, "relation": null, "justification": "There is no clear connection between functional dependencies and project management based on the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 44, "label_hint": "ssn-and-employee-project-number", "chunk_id": "13-NFs-FDs__0011", "lecture_id": "13-NFs-FDs", "text": "Likely functional dependencies:\nssn → employee-name course-number → course-title\nUnlikely functional dependencies course-number → book birthdate → ssn X X"}, {"source": "cluster_B", "cluster_id": 44, "label_hint": "ssn-and-employee-project-number", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0017", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "Manager (?)\nProject(P-number, P-name, Due-Date) Employee(SSN, E-Name, Office)"}, {"source": "cluster_B", "cluster_id": 44, "label_hint": "ssn-and-employee-project-number", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0020", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "Project(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)"}, {"source": "cluster_B", "cluster_id": 44, "label_hint": "ssn-and-employee-project-number", "chunk_id": "12-Conceptual_Logical_DB_Design__0017", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "Manager (?)\nProject(P-number, P-name, Due-Date) Employee(SSN, E-Name, Office)"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0017"}, "A_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0003"}, "gap_lectures": 2}}}
{"A": {"name": "FUNCTIONAL_DEPENDENCIES", "role": "NA"}, "B": {"name": "REDUNDANCY_REDUCTION", "role": "NA"}, "relation": "depends_on", "justification": "Functional dependencies (A) are used to identify and address redundancy in database tables, which is a key aspect of redundancy reduction (B).", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 2, "label_hint": "dnum-and-dname-st-dmgr", "chunk_id": "13-NFs-FDs__0016", "lecture_id": "13-NFs-FDs", "text": "EMP(name, SSN, birthdate, address, dnum, dname, dmgr)\nJohn 111 June 3 123 St.      D1     sales     222\nSue 222 May 15 455 St.     D1     sales     222\nMax       333 Mar. 5 678 St.     D2    research 333\nWei 444 May 2 999 St.     D2    research 333\nTom 555 June 22 888 St.     D2    research 333\ndname and dmgr are stored redundantly - whenever there are multiple employees in a department.\nThis redundancy is caused by what we informally call 'troublesome' FDs. The FDs shown in blue are 'troublesome'."}, {"source": "cluster_A", "cluster_id": 2, "label_hint": "dnum-and-dname-st-dmgr", "chunk_id": "13-NFs-FDs__0017", "lecture_id": "13-NFs-FDs", "text": "caused by 'troublesome' FDs\nEMP(name, SSN, birthdate, address, dnum, dname, dmgr)"}, {"source": "cluster_A", "cluster_id": 2, "label_hint": "dnum-and-dname-st-dmgr", "chunk_id": "13-NFs-FDs__0020", "lecture_id": "13-NFs-FDs", "text": "EMP(name, ssn, birthdate, address, dnum, dname, dmgr)\nWe have a problem! dnum is NOT the key for this table!\nSo these blue FDs will not be enforced automatically by the DBMS (using only keys). And there can be redundancy and update anomalies"}, {"source": "cluster_B", "cluster_id": 2, "label_hint": "dnum-and-dname-st-dmgr", "chunk_id": "13-NFs-FDs__0022", "lecture_id": "13-NFs-FDs", "text": "New-EMP(name, SSN, birthdate, address, dnum)\nInsert anomalies: No Problem\n```\nJohn    111 June 3     123 St.      D1 Sue     222 May 15    455 St.       D1 Max    333 Mar. 5      678 St.      D2 Wei     444 May 2      999 St.      D2 Tom    555 June 22   888 St.      D2\n```\nDept(dnum,  dname,  dmgr)\nD1         sales        222\nD2        research  333\nLess redundancy!\nDelete anomalies: No Problem"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 2, "reason": "A and B appear in different chunks within 2 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0019"}, "A_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0003"}, "gap_lectures": 0}}}
{"A": {"name": "FUNCTIONAL_DEPENDENCIES", "role": "NA"}, "B": {"name": "RELATIONAL_SCHEMA", "role": "NA"}, "relation": "depends_on", "justification": "Functional dependencies are used to transform and refine a relational schema, indicating that understanding relational schema is a prerequisite for working with functional dependencies.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "13-NFs-FDs__0003", "lecture_id": "13-NFs-FDs", "text": "- Start with the original db schema R\n- From ER translation or otherwise\n- Identify its functional dependencies\n- Use them to transform R until we get a good design R*"}, {"source": "cluster_B", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0000", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "cluster_B", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "12-Conceptual_Logical_DB_Design__0000", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "cluster_B", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "13-NFs-FDs__0001", "lecture_id": "13-NFs-FDs", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "A_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0003"}, "gap_lectures": 2}}}
{"A": {"name": "FUNCTIONAL_DEPENDENCIES", "role": "NA"}, "B": {"name": "SCHEMA_REFINEMENT", "role": "NA"}, "relation": "depends_on", "justification": "Functional dependencies are used in the process of schema refinement to transform the original database schema into a well-designed schema, indicating that schema refinement depends on understanding functional dependencies.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "13-NFs-FDs__0003", "lecture_id": "13-NFs-FDs", "text": "- Start with the original db schema R\n- From ER translation or otherwise\n- Identify its functional dependencies\n- Use them to transform R until we get a good design R*"}, {"source": "cluster_B", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0000", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "cluster_B", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "12-Conceptual_Logical_DB_Design__0000", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)  <-next lecture\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}, {"source": "cluster_B", "cluster_id": 95, "label_hint": "design-and-schema-er-database", "chunk_id": "13-NFs-FDs__0001", "lecture_id": "13-NFs-FDs", "text": "- Conceptual design:  (ER & UML Models are used for this.)\n- What are the entities and relationships we need?\n- Logical design:\n- Transform ER design to Relational Schema\n- Schema Refinement:  (Normalization)\n- Check relational schema for redundancies and related anomalies.\n- Physical Database Design and Tuning:\n- Consider typical workloads; (sometimes) modify the database design; select file types and indexes."}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "A_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0003"}, "gap_lectures": 2}}}
{"A": {"name": "FUNCTIONAL_DEPENDENCY", "role": "NA"}, "B": {"name": "NORMALIZATION", "role": "NA"}, "relation": null, "justification": "There is no clear indication that FUNCTIONAL_DEPENDENCY depends on or is part of NORMALIZATION based on the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 2, "label_hint": "dnum-and-dname-st-dmgr", "chunk_id": "13-NFs-FDs__0018", "lecture_id": "13-NFs-FDs", "text": "if you want to insert a department, you can't ... until there is at least one employee.\nDeletion anomalies: if you delete an employee, is that dept. gone?  Was this the last employee in that dept.?\nUpdate anomalies: If you want to change dname , for example, you need to change it everywhere!  And you have to find them all first.\nTroublesome FDs cause (redundancy and) update anomalies."}, {"source": "cluster_B", "cluster_id": 2, "label_hint": "dnum-and-dname-st-dmgr", "chunk_id": "13-NFs-FDs__0017", "lecture_id": "13-NFs-FDs", "text": "caused by 'troublesome' FDs\nEMP(name, SSN, birthdate, address, dnum, dname, dmgr)"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0000"}, "A_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0012"}, "gap_lectures": 5}}}
{"A": {"name": "FUNCTIONAL_DEPENDENCY", "role": "NA"}, "B": {"name": "REDUNDANCY_REDUCTION", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly establish a 'depends_on' or 'part_of' relationship between FUNCTIONAL_DEPENDENCY and REDUNDANCY_REDUCTION.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 2, "label_hint": "dnum-and-dname-st-dmgr", "chunk_id": "13-NFs-FDs__0018", "lecture_id": "13-NFs-FDs", "text": "if you want to insert a department, you can't ... until there is at least one employee.\nDeletion anomalies: if you delete an employee, is that dept. gone?  Was this the last employee in that dept.?\nUpdate anomalies: If you want to change dname , for example, you need to change it everywhere!  And you have to find them all first.\nTroublesome FDs cause (redundancy and) update anomalies."}, {"source": "cluster_B", "cluster_id": 2, "label_hint": "dnum-and-dname-st-dmgr", "chunk_id": "13-NFs-FDs__0022", "lecture_id": "13-NFs-FDs", "text": "New-EMP(name, SSN, birthdate, address, dnum)\nInsert anomalies: No Problem\n```\nJohn    111 June 3     123 St.      D1 Sue     222 May 15    455 St.       D1 Max    333 Mar. 5      678 St.      D2 Wei     444 May 2      999 St.      D2 Tom    555 June 22   888 St.      D2\n```\nDept(dnum,  dname,  dmgr)\nD1         sales        222\nD2        research  333\nLess redundancy!\nDelete anomalies: No Problem"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0019"}, "A_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0012"}, "gap_lectures": 0}}}
{"A": {"name": "FUNCTIONAL_DEPENDENCY", "role": "NA"}, "B": {"name": "UPDATE_ANOMALIES", "role": "NA"}, "relation": "depends_on", "justification": "Functional dependencies cause update anomalies, as evidenced by the text indicating that troublesome FDs lead to update anomalies.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 2, "label_hint": "dnum-and-dname-st-dmgr", "chunk_id": "13-NFs-FDs__0018", "lecture_id": "13-NFs-FDs", "text": "if you want to insert a department, you can't ... until there is at least one employee.\nDeletion anomalies: if you delete an employee, is that dept. gone?  Was this the last employee in that dept.?\nUpdate anomalies: If you want to change dname , for example, you need to change it everywhere!  And you have to find them all first.\nTroublesome FDs cause (redundancy and) update anomalies."}, {"source": "cluster_B", "cluster_id": 2, "label_hint": "dnum-and-dname-st-dmgr", "chunk_id": "13-NFs-FDs__0020", "lecture_id": "13-NFs-FDs", "text": "EMP(name, ssn, birthdate, address, dnum, dname, dmgr)\nWe have a problem! dnum is NOT the key for this table!\nSo these blue FDs will not be enforced automatically by the DBMS (using only keys). And there can be redundancy and update anomalies"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0014"}, "A_first_introduced_at": {"lecture_index": 6, "lecture_id": "13-NFs-FDs", "chunk_id": "13-NFs-FDs__0012"}, "gap_lectures": 0}}}
{"A": {"name": "GRAPH_DATABASE", "role": "NA"}, "B": {"name": "GRAPH_DATABASES", "role": "NA"}, "relation": "part_of", "justification": "GRAPH_DATABASE is a specific instance or type of GRAPH_DATABASES, indicating a part_of relationship.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 93, "label_hint": "developer-and-cypher-query-source", "chunk_id": "11-Neo4J-Part2__0010", "lecture_id": "11-Neo4J-Part2", "text": "Source: https://neo4j.com/developer/cypher-query-language/"}, {"source": "cluster_B", "cluster_id": 93, "label_hint": "developer-and-cypher-query-source", "chunk_id": "11-Neo4J-Part2__0011", "lecture_id": "11-Neo4J-Part2", "text": "Source: https://neo4j.com/developer/cypher-query-language/"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 3, "reason": "A and B appear in different chunks within 3 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0002"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0008"}, "gap_lectures": 0}}}
{"A": {"name": "GRAPH_DATABASE", "role": "NA"}, "B": {"name": "RELATIONSHIP_TYPES", "role": "NA"}, "relation": "depends_on", "justification": "GRAPH_DATABASE is introduced first and used to demonstrate various operations, while RELATIONSHIP_TYPES are introduced later and build upon the understanding of GRAPH_DATABASE to provide more specific details about the relationships within the database.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 32, "label_hint": "title-and-movie-matrix-born", "chunk_id": "10-Neo4J-Part 1__0010", "lecture_id": "10-Neo4J-Part 1", "text": "```\n() (matrix) (:Movie) (matrix:Movie) (matrix:Movie {title: \"The Matrix\"}) (matrix:Movie {title: \"The Matrix\", released: 1997})\n```"}, {"source": "cluster_A", "cluster_id": 32, "label_hint": "title-and-movie-matrix-born", "chunk_id": "10-Neo4J-Part 1__0011", "lecture_id": "10-Neo4J-Part 1", "text": "```\nMATCH (node:Label) WHERE node.property = {value} RETURN node.property\n```\n- Find 'Apollo 13' movie\n- Find 1990's movies\n```\nMATCH (n:Movie {title:\"Apollo 13\"}) RETURN n.released;\n```\n```\nMATCH (n:Movie) WHERE n.released >= 1990 AND n.released <=2000 RETURN I n;\n```"}, {"source": "cluster_A", "cluster_id": 32, "label_hint": "title-and-movie-matrix-born", "chunk_id": "10-Neo4J-Part 1__0018", "lecture_id": "10-Neo4J-Part 1", "text": "```\nMATCH (p:Person)-[:ACTED_IN]->(m:Movie)<-[:DIRECTED]-Cp) RETURN I p.name, m.title;\n```\nTom Hanks, m.title = That Thing You Do. Clint Eastwood, m.title = Unforgiven. Danny DeVito, m.title = Hoffa"}, {"source": "cluster_B", "cluster_id": 32, "label_hint": "title-and-movie-matrix-born", "chunk_id": "11-Neo4J-Part2__0002", "lecture_id": "11-Neo4J-Part2", "text": "- UNION combines the results of two statements that have the same result structure\nEquivalent Query MATCH (p:Person)-[r:ACTED_IN]->(m:Movie) RETuRN p.name as name, type(r) as Acted_Directed, m.title as title UNION MATCH (p:Person)-[r:DIRECTED]->(m:Movie) RETURNp.name as name type(r) as Acted_Directed, m.title as title MATCH (actor:Person)-[r:ACTED_INI DIRECTED]->(movie:Movie) RETURN actor.name AS name, type(r) AS acted_in, movie.title AS title\n\"name\", 1 = \"Acted_Directed\"|\"title\". \"name\", 2 = . \"Nathan Lane\", 1 = \"ACTED_IN\". \"Nathan Lane\", 2 = \"JoeVersustheVolcano\". \"Tom Hanks\", 1 = \"ACTED_IN\". \"Tom Hanks\", 2 = \"Joe Versus the Volcano\". \"Meg Ryan\", 1 = \"ACTED_IN\". \"Meg Ryan\", 2 = \"Joe Versus the Volcano\". \"Lilly Wachowski\", 1 = \"DIRECTED\". \"Lilly Wachowski\", 2 = \"The Matrix\". \"Lana Wachowski\", 1 = \"DIRECTED\". \"Lana Wachowski\", 2 = \"The Matrix\". \"Rob Reiner\", 1 = \"DIRECTED\". \"Rob Reiner\", 2 = \"When Harry Met Sally\"\n4\nSource: https://neo4j.com/developer/cypher-query-language/"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 2, "lecture_id": "11-Neo4J-Part2", "chunk_id": "11-Neo4J-Part2__0002"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0008"}, "gap_lectures": -1}}}
{"A": {"name": "GRAPH_DATABASES", "role": "NA"}, "B": {"name": "PATTERN_MATCHING", "role": "NA"}, "relation": "depends_on", "justification": "Graph databases are introduced as a method to store and manage relationships and connections, while pattern matching is described as a query language used to find specific patterns within these graph databases. Therefore, pattern matching depends on the existence and understanding of graph databases.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 110, "label_hint": "graph-and-road-nodes-edges", "chunk_id": "10-Neo4J-Part 1__0002", "lecture_id": "10-Neo4J-Part 1", "text": "- Many types of data can be represented as graphs\n- Road networks, with intersections as nodes and road segments as edges\n- Computer networks, with computers as nodes and connections as edges\n- Social networks, with people/postings as nodes and edges as relationship (e.g. friends, likes, created, …)\n- Graph databases store relationships and connections as first -class entities: 'Property Graph Model'\nRoad Nodes\n非\nSingle Direction Road Links\nDouble Direction Road Links"}, {"source": "cluster_B", "cluster_id": 110, "label_hint": "graph-and-road-nodes-edges", "chunk_id": "10-Neo4J-Part 1__0008", "lecture_id": "10-Neo4J-Part 1", "text": "- SQL -like syntax\n- Declarative pattern -matching graph query language\n- Query a graph DB to find data (Nodes, Relationships, subgraphs) that matches a specific pattern\n- uses ASCII to specify a patterns"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0008"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0002"}, "gap_lectures": 0}}}
{"A": {"name": "GRAPH_DATABASES", "role": "NA"}, "B": {"name": "QUERY_LANGUAGE", "role": "NA"}, "relation": "depends_on", "justification": "GRAPH_DATABASES are introduced as a way to store relationships and connections as first-class entities, and QUERY_LANGUAGE is necessary to interact with and query these databases effectively.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 110, "label_hint": "graph-and-road-nodes-edges", "chunk_id": "10-Neo4J-Part 1__0002", "lecture_id": "10-Neo4J-Part 1", "text": "- Many types of data can be represented as graphs\n- Road networks, with intersections as nodes and road segments as edges\n- Computer networks, with computers as nodes and connections as edges\n- Social networks, with people/postings as nodes and edges as relationship (e.g. friends, likes, created, …)\n- Graph databases store relationships and connections as first -class entities: 'Property Graph Model'\nRoad Nodes\n非\nSingle Direction Road Links\nDouble Direction Road Links"}, {"source": "cluster_B", "cluster_id": 110, "label_hint": "graph-and-road-nodes-edges", "chunk_id": "10-Neo4J-Part 1__0007", "lecture_id": "10-Neo4J-Part 1", "text": "- graph data model is schema -free\n- testable graph database's API\n- query language\nGraph DB and application evolve in an agile fashion"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0007"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0002"}, "gap_lectures": 0}}}
{"A": {"name": "GROUP_BY", "role": "NA"}, "B": {"name": "JOIN_OPERATION", "role": "NA"}, "relation": "depends_on", "justification": "GROUP_BY operation is introduced after JOIN_OPERATION in the course structure, indicating that JOIN_OPERATION is a prerequisite for understanding GROUP_BY.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 87, "label_hint": "001-and-sem-sid-cid", "chunk_id": "23-Rule-basedOpt__0001", "lecture_id": "23-Rule-basedOpt", "text": "Need to start someplace..\nThe easy cases:\n```\nSelect a1, …, an From R1, …, Rk Where C\n```\n<!-- formula-not-decoded -->\n```\nSelect a1, …, an, aggs From R1, …, Rk Where C Group by b1, …, bl\n```\nUses 'extended' relational algebra, with gamma and delta\n<!-- formula-not-decoded -->\nIn most of these cases, the x will be a"}, {"source": "cluster_B", "cluster_id": 87, "label_hint": "001-and-sem-sid-cid", "chunk_id": "21-RA__0005", "lecture_id": "21-RA", "text": "- Join\nR1 ⋈  R2\n- Intersection R1 ∩ R2\n550-001, subj = DB. 550-001, sem = F14. 502-001, subj = Algo. 502-001, sem = F14. 555-001, subj = I&W. 555-001, sem = S15. 666-001, subj = Ethics. 666-001, sem = S66\nNote:\nduplicate elimination.\n1, exp- grade = A. 1, cid = 550-001. 1, sem = F14. 1, exp- grade = C. 1, cid = 502-001. 1, sem = F14. 3, exp- grade = A. 3, cid = 555-001. 3, sem = S15. 3, exp- grade = B. 3, cid = 550-001. 3, sem = F14"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0005"}, "A_first_introduced_at": {"lecture_index": 14, "lecture_id": "23-Rule-basedOpt", "chunk_id": "23-Rule-basedOpt__0001"}, "gap_lectures": 2}}}
{"A": {"name": "GROUP_BY", "role": "NA"}, "B": {"name": "RELATIONAL_SCHEMA", "role": "NA"}, "relation": "depends_on", "justification": "GROUP_BY operation requires an understanding of relational schema to properly apply it on relational data.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 87, "label_hint": "001-and-sem-sid-cid", "chunk_id": "23-Rule-basedOpt__0001", "lecture_id": "23-Rule-basedOpt", "text": "Need to start someplace..\nThe easy cases:\n```\nSelect a1, …, an From R1, …, Rk Where C\n```\n<!-- formula-not-decoded -->\n```\nSelect a1, …, an, aggs From R1, …, Rk Where C Group by b1, …, bl\n```\nUses 'extended' relational algebra, with gamma and delta\n<!-- formula-not-decoded -->\nIn most of these cases, the x will be a"}, {"source": "cluster_B", "cluster_id": 87, "label_hint": "001-and-sem-sid-cid", "chunk_id": "21-RA__0006", "lecture_id": "21-RA", "text": "- Does not change the relational instance\n- Changes the relational schema only\n- Notation: ρS(B1,…,Bn) (R)\n- Input schema:\nR(A1, …, An)\n- Output schema:\nS(B1, …, Bn)\n- Example: rename Student(sid, name)\nρ RenamedStudent(UIN, lastname) (Student)"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "A_first_introduced_at": {"lecture_index": 14, "lecture_id": "23-Rule-basedOpt", "chunk_id": "23-Rule-basedOpt__0001"}, "gap_lectures": 10}}}
{"A": {"name": "GROUP_BY", "role": "NA"}, "B": {"name": "STUDENT_DATA", "role": "NA"}, "relation": null, "justification": "There is no clear connection between GROUP_BY and STUDENT_DATA based on the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 87, "label_hint": "001-and-sem-sid-cid", "chunk_id": "23-Rule-basedOpt__0001", "lecture_id": "23-Rule-basedOpt", "text": "Need to start someplace..\nThe easy cases:\n```\nSelect a1, …, an From R1, …, Rk Where C\n```\n<!-- formula-not-decoded -->\n```\nSelect a1, …, an, aggs From R1, …, Rk Where C Group by b1, …, bl\n```\nUses 'extended' relational algebra, with gamma and delta\n<!-- formula-not-decoded -->\nIn most of these cases, the x will be a"}, {"source": "cluster_B", "cluster_id": 87, "label_hint": "001-and-sem-sid-cid", "chunk_id": "21-RA__0008", "lecture_id": "21-RA", "text": "- Products are hardly ever used alone; they are typically used in conjunction with a selection. Example:\n<!-- formula-not-decoded -->\nSELECT DISTINCT * FROM Student s JOIN Takes t On s.sid=t.sid\nSELECT DISTINCT * FROM Student s, Takes t WHERE s.sid=t.sid\n1, name = Jill. 1, sid:2 = 1. 1, exp-grade = A. 1, cid = 550-001. 1, sem = F14. 1, name = Jill. 1, sid:2 = 1. 1, exp-grade = C. 1, cid = 502-001. 1, sem = F14. 3, name = Maya. 3, sid:2 = 3. 3, exp-grade = A. 3, cid = 555-001. 3, sem = S15. 3, name = Maya. 3, sid:2 = 3. 3, exp-grade = B. 3, cid = 550-001. 3, sem = F14"}, {"source": "cluster_B", "cluster_id": 87, "label_hint": "001-and-sem-sid-cid", "chunk_id": "21-RA__0012", "lecture_id": "21-RA", "text": "1, name = Jill. 12, name = Susan. 18, name = Roger\n1, name = Jill. 2, name = Bo. 3, name = Maya\n(SELECT sid, name FROM STUDENT) UNION (SELECT sid, name FROM POSTDOC)\nSTUDENT U POSTDOC\n1, name = Jill. 2, name = Bo. 3, name = Maya. 12, name = Susan. 18, name = Roger\n1, name = Jill. 2, name = Bo. 3, name = Maya\n1, name = Jill. 12, name = Susan. 18, name = Roger\n2, name = Bo. 3, name = Maya\n550-001, subj = DB. 550-001, sem = F14. 502-001, subj = Algo. 502-001, sem = F14. 555-001, subj = I&W. 555-001, sem = S15. 666-001, subj = Ethics. 666-001, sem = S66"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0008"}, "A_first_introduced_at": {"lecture_index": 14, "lecture_id": "23-Rule-basedOpt", "chunk_id": "23-Rule-basedOpt__0001"}, "gap_lectures": 2}}}
{"A": {"name": "JOIN_OPERATION", "role": "NA"}, "B": {"name": "RELATIONAL_ALGEBRA", "role": "NA"}, "relation": "part_of", "justification": "The evidence shows that JOIN_OPERATION is discussed as a specific operation within the broader context of RELATIONAL_ALGEBRA.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 87, "label_hint": "001-and-sem-sid-cid", "chunk_id": "21-RA__0005", "lecture_id": "21-RA", "text": "- Join\nR1 ⋈  R2\n- Intersection R1 ∩ R2\n550-001, subj = DB. 550-001, sem = F14. 502-001, subj = Algo. 502-001, sem = F14. 555-001, subj = I&W. 555-001, sem = S15. 666-001, subj = Ethics. 666-001, sem = S66\nNote:\nduplicate elimination.\n1, exp- grade = A. 1, cid = 550-001. 1, sem = F14. 1, exp- grade = C. 1, cid = 502-001. 1, sem = F14. 3, exp- grade = A. 3, cid = 555-001. 3, sem = S15. 3, exp- grade = B. 3, cid = 550-001. 3, sem = F14"}, {"source": "cluster_B", "cluster_id": 87, "label_hint": "001-and-sem-sid-cid", "chunk_id": "23-Rule-basedOpt__0001", "lecture_id": "23-Rule-basedOpt", "text": "Need to start someplace..\nThe easy cases:\n```\nSelect a1, …, an From R1, …, Rk Where C\n```\n<!-- formula-not-decoded -->\n```\nSelect a1, …, an, aggs From R1, …, Rk Where C Group by b1, …, bl\n```\nUses 'extended' relational algebra, with gamma and delta\n<!-- formula-not-decoded -->\nIn most of these cases, the x will be a"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0002"}, "A_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0005"}, "gap_lectures": 0}}}
{"A": {"name": "JOIN_OPERATION", "role": "NA"}, "B": {"name": "RELATIONAL_SCHEMA", "role": "NA"}, "relation": "depends_on", "justification": "The JOIN operation requires an understanding of the relational schema to be performed correctly, as it involves combining data from multiple tables based on their schema.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 87, "label_hint": "001-and-sem-sid-cid", "chunk_id": "21-RA__0005", "lecture_id": "21-RA", "text": "- Join\nR1 ⋈  R2\n- Intersection R1 ∩ R2\n550-001, subj = DB. 550-001, sem = F14. 502-001, subj = Algo. 502-001, sem = F14. 555-001, subj = I&W. 555-001, sem = S15. 666-001, subj = Ethics. 666-001, sem = S66\nNote:\nduplicate elimination.\n1, exp- grade = A. 1, cid = 550-001. 1, sem = F14. 1, exp- grade = C. 1, cid = 502-001. 1, sem = F14. 3, exp- grade = A. 3, cid = 555-001. 3, sem = S15. 3, exp- grade = B. 3, cid = 550-001. 3, sem = F14"}, {"source": "cluster_B", "cluster_id": 87, "label_hint": "001-and-sem-sid-cid", "chunk_id": "21-RA__0006", "lecture_id": "21-RA", "text": "- Does not change the relational instance\n- Changes the relational schema only\n- Notation: ρS(B1,…,Bn) (R)\n- Input schema:\nR(A1, …, An)\n- Output schema:\nS(B1, …, Bn)\n- Example: rename Student(sid, name)\nρ RenamedStudent(UIN, lastname) (Student)"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "A_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0005"}, "gap_lectures": 8}}}
{"A": {"name": "JOIN_OPERATION", "role": "NA"}, "B": {"name": "STUDENT_DATA", "role": "NA"}, "relation": "depends_on", "justification": "The JOIN operation is demonstrated using STUDENT_DATA in the provided evidence, indicating that understanding STUDENT_DATA is a prerequisite for performing JOIN operations.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 87, "label_hint": "001-and-sem-sid-cid", "chunk_id": "21-RA__0005", "lecture_id": "21-RA", "text": "- Join\nR1 ⋈  R2\n- Intersection R1 ∩ R2\n550-001, subj = DB. 550-001, sem = F14. 502-001, subj = Algo. 502-001, sem = F14. 555-001, subj = I&W. 555-001, sem = S15. 666-001, subj = Ethics. 666-001, sem = S66\nNote:\nduplicate elimination.\n1, exp- grade = A. 1, cid = 550-001. 1, sem = F14. 1, exp- grade = C. 1, cid = 502-001. 1, sem = F14. 3, exp- grade = A. 3, cid = 555-001. 3, sem = S15. 3, exp- grade = B. 3, cid = 550-001. 3, sem = F14"}, {"source": "cluster_B", "cluster_id": 87, "label_hint": "001-and-sem-sid-cid", "chunk_id": "21-RA__0008", "lecture_id": "21-RA", "text": "- Products are hardly ever used alone; they are typically used in conjunction with a selection. Example:\n<!-- formula-not-decoded -->\nSELECT DISTINCT * FROM Student s JOIN Takes t On s.sid=t.sid\nSELECT DISTINCT * FROM Student s, Takes t WHERE s.sid=t.sid\n1, name = Jill. 1, sid:2 = 1. 1, exp-grade = A. 1, cid = 550-001. 1, sem = F14. 1, name = Jill. 1, sid:2 = 1. 1, exp-grade = C. 1, cid = 502-001. 1, sem = F14. 3, name = Maya. 3, sid:2 = 3. 3, exp-grade = A. 3, cid = 555-001. 3, sem = S15. 3, name = Maya. 3, sid:2 = 3. 3, exp-grade = B. 3, cid = 550-001. 3, sem = F14"}, {"source": "cluster_B", "cluster_id": 87, "label_hint": "001-and-sem-sid-cid", "chunk_id": "21-RA__0012", "lecture_id": "21-RA", "text": "1, name = Jill. 12, name = Susan. 18, name = Roger\n1, name = Jill. 2, name = Bo. 3, name = Maya\n(SELECT sid, name FROM STUDENT) UNION (SELECT sid, name FROM POSTDOC)\nSTUDENT U POSTDOC\n1, name = Jill. 2, name = Bo. 3, name = Maya. 12, name = Susan. 18, name = Roger\n1, name = Jill. 2, name = Bo. 3, name = Maya\n1, name = Jill. 12, name = Susan. 18, name = Roger\n2, name = Bo. 3, name = Maya\n550-001, subj = DB. 550-001, sem = F14. 502-001, subj = Algo. 502-001, sem = F14. 555-001, subj = I&W. 555-001, sem = S15. 666-001, subj = Ethics. 666-001, sem = S66"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0008"}, "A_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0005"}, "gap_lectures": 0}}}
{"A": {"name": "KEYS", "role": "NA"}, "B": {"name": "PRIMARY_KEY", "role": "NA"}, "relation": "part_of", "justification": "Primary key is a specific type of key in the relational model, making it a part of the broader concept of keys.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 103, "label_hint": "keys-and-model-foreign-relational", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0001", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Relational model has:\n- tables (relations) with attributes, keys, foreign keys, domain definitions for attributes"}, {"source": "cluster_A", "cluster_id": 103, "label_hint": "keys-and-model-foreign-relational", "chunk_id": "12-Conceptual_Logical_DB_Design__0001", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Relational model has:\n- tables (relations) with attributes, keys, foreign keys, domain definitions for attributes"}, {"source": "cluster_B", "cluster_id": 103, "label_hint": "keys-and-model-foreign-relational", "chunk_id": "1-RelationalModel__0000", "lecture_id": "1-RelationalModel", "text": "- Define a data model\n- Define the relational data model\n- Articulate the basic terminologies of the relational data model (from a practical perspective)\n- Define Primary and Foreign keys"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0000"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "gap_lectures": 0}}}
{"A": {"name": "KEYS", "role": "NA"}, "B": {"name": "WHERE_CLAUSE", "role": "NA"}, "relation": "depends_on", "justification": "The concept of keys is foundational in understanding how to filter and retrieve specific data using WHERE clauses in SQL.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0012", "lecture_id": "1-RelationalModel", "text": "The intension of the table\n101, Owner = J. Smith. 101, Balance = 1000.00. 101, Type = checking. 102, Owner = W. Wei. 102, Balance = 2000.00. 102, Type = checking. 103, Owner = J. Smith. 103, Balance = 5000.00. 103, Type = savings. 104, Owner = M. Jones. 104, Balance = 1000.00. 104, Type = checking. 105, Owner = H. Martin. 105, Balance = 10,000.00. 105, Type = checking\nThe extension of the table.  Also called the extent .\n, Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. Cardinality, Number = 102. Cardinality, Owner = W. Wei. Cardinality, Balance = 2000.00. Cardinality, Type = checking. of this instance is 5 (because, Number = 103. of this instance is 5 (because, Owner = J. Smith. of this instance is 5 (because, Balance = 5000.00. of this instance is 5 (because, Type = savings. there are 5, Number = 104. there are 5, Owner = M. Jones. there are 5, Balance = 1000.00. there are 5, Type = checking. rows), Number = 105. rows), Owner = H. Martin. rows), Balance = 10,000.00. rows), Type = checking\n-  Data Models\n- Relational Database Model\n-  Basic Concepts and Terminology\n- Keys and Foreign Keys\n- Schema Specifications"}, {"source": "cluster_A", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0015", "lecture_id": "1-RelationalModel", "text": ", Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. , Number = 102. , Owner = W. Wei. , Balance = 2000.00. , Type = checking. , Number = 103. , Owner = J. Smith. , Balance = 5000.00. , Type = savings. , Number = 104. , Owner = M. Jones. , Balance = 1000.00. , Type = checking. , Number = 105. , Owner = H. Martin. , Balance = 10,000.00. , Type = checking. Deposit, Number = AcctNo Transaction-id. Deposit, Owner = Date. Deposit, Balance = Amount. Deposit, Type = . , Number = 102 1. , Owner = 10/22/00. , Balance = 500.00. , Type = . , Number = 102 2. , Owner = 10/29/00. , Balance = 200.00. , Type = . , Number = 104 3. , Owner = 10/29/00. , Balance = 1000.00. , Type = . , Number = 105 4. , Owner = 11/02/00. , Balance = 10,000.00. , Type = . , Number = 106 5. , Owner = 12/05/00. , Balance = 555.00. , Type = \nWe say that Deposit.AcctNo is a foreign key that references Account.Number.  If the DBMS enforces this constraint, we have referential integrity .\n, Foreign keys might or might not be part of the key for the referring table.Number = 101 102 103 104 105. , Foreign keys might or might not be part of the key for the referring table.Owner = J. Smith W. Wei J. Smith M. Jones H. Martin. , Foreign keys might or might not be part of the key for the referring table.Balance = 1000.00 2000.00 5000.00 1000.00 10,000.00. , Foreign keys might or might not be part of the key for the referring table.Type = checking checking savings checking checking. Deposit, Foreign keys might or might not be part of the key for the referring table.Number = AcctNo. Deposit, Foreign keys might or might not be part of the key for the referring table.Owner = Transaction-id. Deposit, Foreign keys might or might not be part of the key for the referring table.Balance = Date. Deposit, Foreign keys might or might not be part of the key for the referring table.Type = Amount. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Number = AcctNo 101 101. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Owner = Check-number 924 925. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Balance = Date 10/23/00 10/24/00. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Type = Amount 125.00 23.98\n-  Data Models\n- Relational Database Model\n-  Basic Concepts and Terminology\n-  Keys and Foreign Keys\n- Schema Specifications"}, {"source": "cluster_B", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "2-SQL-Basics__0005", "lecture_id": "2-SQL-Basics", "text": "Account, 1 = Number. Account, 2 = Owner. Account, 3 = Balance. Account, 4 = T\\pe. , 1 = 101. , 2 = J. Smith. , 3 = 1000.00. , 4 = checking. , 1 = 102. , 2 = W. Wei. , 3 = 2000.00. , 4 = checking. , 1 = 103. , 2 = J. Smith. , 3 = 5000.00. , 4 = savings. , 1 = 104. , 2 = M. Jones. , 3 = 1000.00. , 4 = checking. , 1 = 105. , 2 = H. Martin. , 3 = 10,000.00. , 4 = checking\nSELECT, 1 = Number, Owner. FROM, 1 = Account. WHERE, 1 = T\\pe = \" savings \" ;\nNumber, 1 = Owner\n103\nJ. Smith"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 10, "lecture_id": "2-SQL-Basics", "chunk_id": "2-SQL-Basics__0005"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "gap_lectures": -10}}}
{"A": {"name": "LEFT_OUTER_JOIN", "role": "NA"}, "B": {"name": "RANGE_QUERIES", "role": "NA"}, "relation": null, "justification": "There is no clear indication that LEFT_OUTER_JOIN depends on RANGE_QUERIES or vice versa based on the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 92, "label_hint": "results-and-number-cursor-collection", "chunk_id": "9- MongoDB-Part2__0007", "lecture_id": "9- MongoDB-Part2", "text": "- Use a left outer -joins to a collection in the same database to search (filter) in documents from the (joined) second collection for processing."}, {"source": "cluster_B", "cluster_id": 92, "label_hint": "results-and-number-cursor-collection", "chunk_id": "8- NoSQL-MongoDB-Basics__0018", "lecture_id": "8- NoSQL-MongoDB-Basics", "text": "- Use find( ) function and a query document\n- Ranges, set inclusion, inequalities using $ conditionals\n- Complex queries using $where clause\n- Queries return a database cursor\n- Meta-operations on cursor include skipping some number of results, limiting the number of results returned, sorting results."}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 3, "lecture_id": "12-BTree", "chunk_id": "12-BTree__0006"}, "A_first_introduced_at": {"lecture_index": 15, "lecture_id": "3-SQL2-JOINS_Nulls", "chunk_id": "3-SQL2-JOINS_Nulls__0009"}, "gap_lectures": 12}}}
{"A": {"name": "MANY_ONE_RELATIONSHIP", "role": "NA"}, "B": {"name": "RELATIONSHIP_SET", "role": "NA"}, "relation": "part_of", "justification": "A MANY_ONE_RELATIONSHIP is a specific type of relationship within the broader concept of RELATIONSHIP_SET.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 116, "label_hint": "entity-and-set-uniquely-weak", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0012", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "- Occasionally, entities of an entity set need 'help' to identify them uniquely.\n- Entity set E is weak if in order to identify entities of E uniquely, we need to follow one or more many-one relationships from E and include the key of the related entity sets.\n- Note: not an is-a relationship because E is not a 'subclass' of F: Univ and Team"}, {"source": "cluster_A", "cluster_id": 116, "label_hint": "entity-and-set-uniquely-weak", "chunk_id": "12-Conceptual_Logical_DB_Design__0012", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "- Occasionally, entities of an entity set need 'help' to identify them uniquely.\n- Entity set E is weak if in order to identify entities of E uniquely, we need to follow one or more many-one relationships from E and include the key of the related entity sets.\n- Note: not an is-a relationship because E is not a 'subclass' of F: Univ and Team"}, {"source": "cluster_B", "cluster_id": 116, "label_hint": "entity-and-set-uniquely-weak", "chunk_id": "12-Conceptual_Logical_DB_Design__0021", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "supporting entity set supporting relationship set\nweak Entity set"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0005"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0006"}, "gap_lectures": 0}}}
{"A": {"name": "NODES", "role": "NA"}, "B": {"name": "PATTERN_MATCHING", "role": "NA"}, "relation": null, "justification": "There is no clear dependency or part_of relationship between 'NODES' and 'PATTERN_MATCHING' based on the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 110, "label_hint": "graph-and-road-nodes-edges", "chunk_id": "10-Neo4J-Part 1__0002", "lecture_id": "10-Neo4J-Part 1", "text": "- Many types of data can be represented as graphs\n- Road networks, with intersections as nodes and road segments as edges\n- Computer networks, with computers as nodes and connections as edges\n- Social networks, with people/postings as nodes and edges as relationship (e.g. friends, likes, created, …)\n- Graph databases store relationships and connections as first -class entities: 'Property Graph Model'\nRoad Nodes\n非\nSingle Direction Road Links\nDouble Direction Road Links"}, {"source": "cluster_B", "cluster_id": 110, "label_hint": "graph-and-road-nodes-edges", "chunk_id": "10-Neo4J-Part 1__0008", "lecture_id": "10-Neo4J-Part 1", "text": "- SQL -like syntax\n- Declarative pattern -matching graph query language\n- Query a graph DB to find data (Nodes, Relationships, subgraphs) that matches a specific pattern\n- uses ASCII to specify a patterns"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0008"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0002"}, "gap_lectures": 0}}}
{"A": {"name": "NODES", "role": "NA"}, "B": {"name": "QUERY_LANGUAGE", "role": "NA"}, "relation": null, "justification": "There is no clear connection between 'NODES' and 'QUERY_LANGUAGE' based on the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 110, "label_hint": "graph-and-road-nodes-edges", "chunk_id": "10-Neo4J-Part 1__0002", "lecture_id": "10-Neo4J-Part 1", "text": "- Many types of data can be represented as graphs\n- Road networks, with intersections as nodes and road segments as edges\n- Computer networks, with computers as nodes and connections as edges\n- Social networks, with people/postings as nodes and edges as relationship (e.g. friends, likes, created, …)\n- Graph databases store relationships and connections as first -class entities: 'Property Graph Model'\nRoad Nodes\n非\nSingle Direction Road Links\nDouble Direction Road Links"}, {"source": "cluster_B", "cluster_id": 110, "label_hint": "graph-and-road-nodes-edges", "chunk_id": "10-Neo4J-Part 1__0007", "lecture_id": "10-Neo4J-Part 1", "text": "- graph data model is schema -free\n- testable graph database's API\n- query language\nGraph DB and application evolve in an agile fashion"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0007"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0002"}, "gap_lectures": 0}}}
{"A": {"name": "NORMALIZATION", "role": "NA"}, "B": {"name": "QUERY_OPTIMIZATION", "role": "NA"}, "relation": null, "justification": "There is no clear connection or dependency between NORMALIZATION and QUERY_OPTIMIZATION based on the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "10-Neo4J-Part 1__0000", "lecture_id": "10-Neo4J-Part 1", "text": "University of Illinois at Urbana -Champaign CS411: Database Systems"}, {"source": "cluster_B", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "5- SQL4-AggGrpViews__0000", "lecture_id": "5- SQL4-AggGrpViews", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems\n工"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0022"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0000"}, "gap_lectures": -11}}}
{"A": {"name": "NORMALIZATION", "role": "NA"}, "B": {"name": "QUERY_PROCESSING", "role": "NA"}, "relation": null, "justification": "There is no clear evidence in the provided text that establishes a 'depends_on' or 'part_of' relationship between 'NORMALIZATION' and 'QUERY_PROCESSING'. Both concepts appear in different chunks within the same course but do not have any direct textual connection indicating a dependency or part-whole relationship.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "10-Neo4J-Part 1__0000", "lecture_id": "10-Neo4J-Part 1", "text": "University of Illinois at Urbana -Champaign CS411: Database Systems"}, {"source": "cluster_B", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "19-Trxn-Mgmt__0001", "lecture_id": "19-Trxn-Mgmt", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}, {"source": "cluster_B", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "20-Trxn-Serializability__0000", "lecture_id": "20-Trxn-Serializability", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}, {"source": "cluster_B", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "7- ConstraintsTriggers__0000", "lecture_id": "7- ConstraintsTriggers", "text": "University of Illinois at Urbana -Champaign CS411: Database Systems\n工"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0001"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0000"}, "gap_lectures": -8}}}
{"A": {"name": "NORMALIZATION", "role": "NA"}, "B": {"name": "STORAGE_STRUCTURES", "role": "NA"}, "relation": null, "justification": "There is no clear connection or dependency between 'NORMALIZATION' and 'STORAGE_STRUCTURES' based on the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "10-Neo4J-Part 1__0000", "lecture_id": "10-Neo4J-Part 1", "text": "University of Illinois at Urbana -Champaign CS411: Database Systems"}, {"source": "cluster_B", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "19-Trxn-Mgmt__0001", "lecture_id": "19-Trxn-Mgmt", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}, {"source": "cluster_B", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "20-Trxn-Serializability__0000", "lecture_id": "20-Trxn-Serializability", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}, {"source": "cluster_B", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "5- SQL4-AggGrpViews__0000", "lecture_id": "5- SQL4-AggGrpViews", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems\n工"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0001"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0000"}, "gap_lectures": -8}}}
{"A": {"name": "NORMALIZATION", "role": "NA"}, "B": {"name": "TRANSACTION_MANAGEMENT", "role": "NA"}, "relation": null, "justification": "There is no clear connection or dependency between 'NORMALIZATION' and 'TRANSACTION_MANAGEMENT' based on the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "10-Neo4J-Part 1__0000", "lecture_id": "10-Neo4J-Part 1", "text": "University of Illinois at Urbana -Champaign CS411: Database Systems"}, {"source": "cluster_B", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "19-Trxn-Mgmt__0001", "lecture_id": "19-Trxn-Mgmt", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}, {"source": "cluster_B", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "20-Trxn-Serializability__0000", "lecture_id": "20-Trxn-Serializability", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}, {"source": "cluster_B", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "5- SQL4-AggGrpViews__0000", "lecture_id": "5- SQL4-AggGrpViews", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems\n工"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0001"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0000"}, "gap_lectures": -8}}}
{"A": {"name": "NORMAL_FORM", "role": "NA"}, "B": {"name": "SUPERKEY", "role": "NA"}, "relation": null, "justification": "There is no clear indication in the provided evidence that NORMAL_FORM depends on or is part of SUPERKEY.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 47, "label_hint": "normal-and-form-bcnf-3nf", "chunk_id": "15-NFs-3NF__0001", "lecture_id": "15-NFs-3NF", "text": "First Normal Form = all attributes are atomic Second Normal Form (2NF) = old and obsolete\nBoyce Codd Normal Form (BCNF)\nThird Normal Form (3NF)\nOthers..."}, {"source": "cluster_A", "cluster_id": 47, "label_hint": "normal-and-form-bcnf-3nf", "chunk_id": "DBDesign_BCNF__0001", "lecture_id": "DBDesign_BCNF", "text": "First Normal Form = all attributes are atomic Second Normal Form (2NF) = old and obsolete\nBoyce Codd Normal Form (BCNF) Third Normal Form (3NF)\nOthers..."}, {"source": "cluster_B", "cluster_id": 47, "label_hint": "normal-and-form-bcnf-3nf", "chunk_id": "DBDesign_BCNF__0003", "lecture_id": "DBDesign_BCNF", "text": "- X  A is OK, if X is a (super)key\n- X  A is NOT OK, otherwise\n- Need to decompose the table, but how?\nBoyce-Codd Normal Form (BCNF)"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 7, "lecture_id": "15-NFs-3NF", "chunk_id": "15-NFs-3NF__0012"}, "A_first_introduced_at": {"lecture_index": 7, "lecture_id": "15-NFs-3NF", "chunk_id": "15-NFs-3NF__0001"}, "gap_lectures": 0}}}
{"A": {"name": "PATTERN_MATCHING", "role": "NA"}, "B": {"name": "PROJECTION", "role": "NA"}, "relation": null, "justification": "There is no clear connection or dependency between PATTERN_MATCHING and PROJECTION based on the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 9, "label_hint": "wkh-and-r1-iru-rshudwlrqv", "chunk_id": "2-SQL-Basics__0011", "lecture_id": "2-SQL-Basics", "text": "-  DWWULEXWH QDPHV RI WKH UHODWLRQ(V) XVHG LQ WKH FROM.\n-  FRPSDULVRQ RSHUDWRUV:  =, <>, <, >, <=, >=\n-  DSSO\\ DULWKPHWLF RSHUDWLRQV:  VWRFNSULFH*2\n-  RSHUDWLRQV, FRPSDULVRQV RQ VWULQJV\n-  SDWWHUQ PDWFKLQJ:    V LIKE S\n-  VSHFLDO VWXII IRU FRPSDULQJ GDWHV DQG WLPHV.\nSHH WKH WH[WERRN IRU PRUH«\nTKHQ, FUHDWH ELJJHU H[SUHVVLRQV XVLQJ BRROHDQ FRQQHFWLYHV"}, {"source": "cluster_B", "cluster_id": 9, "label_hint": "wkh-and-r1-iru-rshudwlrqv", "chunk_id": "21-RA__0004", "lecture_id": "21-RA", "text": "- Projection\n  (R)\n• Selection  (R)\n- (Rename)   (R)\n- Union R1 U R2\n- Difference\nR1 - R 2\n- Product\nR1 x R2"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0004"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0008"}, "gap_lectures": -11}}}
{"A": {"name": "PATTERN_MATCHING", "role": "NA"}, "B": {"name": "QUERY_LANGUAGE", "role": "NA"}, "relation": "part_of", "justification": "Pattern matching is described as a component of a declarative graph query language, indicating that it is a specific feature or part of the broader concept of query language.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 110, "label_hint": "graph-and-road-nodes-edges", "chunk_id": "10-Neo4J-Part 1__0008", "lecture_id": "10-Neo4J-Part 1", "text": "- SQL -like syntax\n- Declarative pattern -matching graph query language\n- Query a graph DB to find data (Nodes, Relationships, subgraphs) that matches a specific pattern\n- uses ASCII to specify a patterns"}, {"source": "cluster_B", "cluster_id": 110, "label_hint": "graph-and-road-nodes-edges", "chunk_id": "10-Neo4J-Part 1__0007", "lecture_id": "10-Neo4J-Part 1", "text": "- graph data model is schema -free\n- testable graph database's API\n- query language\nGraph DB and application evolve in an agile fashion"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0007"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0008"}, "gap_lectures": 0}}}
{"A": {"name": "PATTERN_MATCHING", "role": "NA"}, "B": {"name": "RELATIONSHIPS", "role": "NA"}, "relation": null, "justification": "There is no clear dependency or part_of relationship between PATTERN_MATCHING and RELATIONSHIPS based on the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 110, "label_hint": "graph-and-road-nodes-edges", "chunk_id": "10-Neo4J-Part 1__0008", "lecture_id": "10-Neo4J-Part 1", "text": "- SQL -like syntax\n- Declarative pattern -matching graph query language\n- Query a graph DB to find data (Nodes, Relationships, subgraphs) that matches a specific pattern\n- uses ASCII to specify a patterns"}, {"source": "cluster_B", "cluster_id": 110, "label_hint": "graph-and-road-nodes-edges", "chunk_id": "10-Neo4J-Part 1__0002", "lecture_id": "10-Neo4J-Part 1", "text": "- Many types of data can be represented as graphs\n- Road networks, with intersections as nodes and road segments as edges\n- Computer networks, with computers as nodes and connections as edges\n- Social networks, with people/postings as nodes and edges as relationship (e.g. friends, likes, created, …)\n- Graph databases store relationships and connections as first -class entities: 'Property Graph Model'\nRoad Nodes\n非\nSingle Direction Road Links\nDouble Direction Road Links"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0002"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0008"}, "gap_lectures": 0}}}
{"A": {"name": "PATTERN_MATCHING", "role": "NA"}, "B": {"name": "RENAME", "role": "NA"}, "relation": null, "justification": "There is no clear connection or dependency between 'PATTERN_MATCHING' and 'RENAME' based on the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 9, "label_hint": "wkh-and-r1-iru-rshudwlrqv", "chunk_id": "2-SQL-Basics__0011", "lecture_id": "2-SQL-Basics", "text": "-  DWWULEXWH QDPHV RI WKH UHODWLRQ(V) XVHG LQ WKH FROM.\n-  FRPSDULVRQ RSHUDWRUV:  =, <>, <, >, <=, >=\n-  DSSO\\ DULWKPHWLF RSHUDWLRQV:  VWRFNSULFH*2\n-  RSHUDWLRQV, FRPSDULVRQV RQ VWULQJV\n-  SDWWHUQ PDWFKLQJ:    V LIKE S\n-  VSHFLDO VWXII IRU FRPSDULQJ GDWHV DQG WLPHV.\nSHH WKH WH[WERRN IRU PRUH«\nTKHQ, FUHDWH ELJJHU H[SUHVVLRQV XVLQJ BRROHDQ FRQQHFWLYHV"}, {"source": "cluster_B", "cluster_id": 9, "label_hint": "wkh-and-r1-iru-rshudwlrqv", "chunk_id": "21-RA__0004", "lecture_id": "21-RA", "text": "- Projection\n  (R)\n• Selection  (R)\n- (Rename)   (R)\n- Union R1 U R2\n- Difference\nR1 - R 2\n- Product\nR1 x R2"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0004"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0008"}, "gap_lectures": -11}}}
{"A": {"name": "PATTERN_MATCHING", "role": "NA"}, "B": {"name": "SELECTION", "role": "NA"}, "relation": null, "justification": "There is no clear evidence that PATTERN_MATCHING depends_on or is part_of SELECTION based on the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 9, "label_hint": "wkh-and-r1-iru-rshudwlrqv", "chunk_id": "2-SQL-Basics__0011", "lecture_id": "2-SQL-Basics", "text": "-  DWWULEXWH QDPHV RI WKH UHODWLRQ(V) XVHG LQ WKH FROM.\n-  FRPSDULVRQ RSHUDWRUV:  =, <>, <, >, <=, >=\n-  DSSO\\ DULWKPHWLF RSHUDWLRQV:  VWRFNSULFH*2\n-  RSHUDWLRQV, FRPSDULVRQV RQ VWULQJV\n-  SDWWHUQ PDWFKLQJ:    V LIKE S\n-  VSHFLDO VWXII IRU FRPSDULQJ GDWHV DQG WLPHV.\nSHH WKH WH[WERRN IRU PRUH«\nTKHQ, FUHDWH ELJJHU H[SUHVVLRQV XVLQJ BRROHDQ FRQQHFWLYHV"}, {"source": "cluster_B", "cluster_id": 9, "label_hint": "wkh-and-r1-iru-rshudwlrqv", "chunk_id": "21-RA__0004", "lecture_id": "21-RA", "text": "- Projection\n  (R)\n• Selection  (R)\n- (Rename)   (R)\n- Union R1 U R2\n- Difference\nR1 - R 2\n- Product\nR1 x R2"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0004"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0008"}, "gap_lectures": -11}}}
{"A": {"name": "QUERY_LANGUAGE", "role": "NA"}, "B": {"name": "RELATIONSHIPS", "role": "NA"}, "relation": null, "justification": "There is no clear evidence that QUERY_LANGUAGE depends_on or part_of RELATIONSHIPS based on the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 110, "label_hint": "graph-and-road-nodes-edges", "chunk_id": "10-Neo4J-Part 1__0007", "lecture_id": "10-Neo4J-Part 1", "text": "- graph data model is schema -free\n- testable graph database's API\n- query language\nGraph DB and application evolve in an agile fashion"}, {"source": "cluster_B", "cluster_id": 110, "label_hint": "graph-and-road-nodes-edges", "chunk_id": "10-Neo4J-Part 1__0002", "lecture_id": "10-Neo4J-Part 1", "text": "- Many types of data can be represented as graphs\n- Road networks, with intersections as nodes and road segments as edges\n- Computer networks, with computers as nodes and connections as edges\n- Social networks, with people/postings as nodes and edges as relationship (e.g. friends, likes, created, …)\n- Graph databases store relationships and connections as first -class entities: 'Property Graph Model'\nRoad Nodes\n非\nSingle Direction Road Links\nDouble Direction Road Links"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0002"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0007"}, "gap_lectures": 0}}}
{"A": {"name": "QUERY_LANGUAGE", "role": "NA"}, "B": {"name": "RELATIONSHIP_TYPES", "role": "NA"}, "relation": "depends_on", "justification": "QUERY_LANGUAGE (A) is used to query and manipulate data in Neo4J, which requires an understanding of RELATIONSHIP_TYPES (B) to effectively work with the relationships between nodes in the graph database.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 32, "label_hint": "title-and-movie-matrix-born", "chunk_id": "10-Neo4J-Part 1__0018", "lecture_id": "10-Neo4J-Part 1", "text": "```\nMATCH (p:Person)-[:ACTED_IN]->(m:Movie)<-[:DIRECTED]-Cp) RETURN I p.name, m.title;\n```\nTom Hanks, m.title = That Thing You Do. Clint Eastwood, m.title = Unforgiven. Danny DeVito, m.title = Hoffa"}, {"source": "cluster_A", "cluster_id": 32, "label_hint": "title-and-movie-matrix-born", "chunk_id": "11-Neo4J-Part2__0004", "lecture_id": "11-Neo4J-Part2", "text": "```\nMATCH (person: Person)-[:ACTED_IN] ->(m:Movie) WITH person, count(*) AS appearances, collect(m.title) AS movies WHERE appearances > 1 RETURN person.name, appearances, movies\n```\n\"Cuba Gooding Jr.\", \"appearances\" = \"4\". \"Cuba Gooding Jr.\", \"movies\" = [\"AFewGood Men\",\"Jerry Magui re\",\"AsGoodasItGets\",\"what DreamsMayCome\"]. \"oliver Platt\", \"appearances\" = \"2\". \"oliver Platt\", \"movies\" = [\"Frost/Nixon\",\"BicentennialM an\"]. \"Philip Seymour Hoffman\", \"appearances\" = \"2\". \"Philip Seymour Hoffman\", \"movies\" = [\"Twister\",\"charliewilson'sw ar\"]. \"SamRockwell\", \"appearances\" = \"2\". \"SamRockwell\", \"movies\" = [\"The Green Mile\",\"Frost/Nixon \"]. \"Greg Kinnear\", \"appearances\" = \"2\". \"Greg Kinnear\", \"movies\" = [\"As Good as It Gets\",\"You've Got Mail\"]. \"Zach Grenier\", \"appearances\" = \"2\". \"Zach Grenier\", \"movies\" = [\"RescueDawn\",\"Twister\"]. \"Rosieo'Donnell\", \"appearances\" = \"2\". \"Rosieo'Donnell\", \"movies\" = [\"A League ofTheirOwn\",\"slee plessinSeattle\"]\nSource: https://neo4j.com/developer/cypher-query-language/"}, {"source": "cluster_B", "cluster_id": 32, "label_hint": "title-and-movie-matrix-born", "chunk_id": "11-Neo4J-Part2__0002", "lecture_id": "11-Neo4J-Part2", "text": "- UNION combines the results of two statements that have the same result structure\nEquivalent Query MATCH (p:Person)-[r:ACTED_IN]->(m:Movie) RETuRN p.name as name, type(r) as Acted_Directed, m.title as title UNION MATCH (p:Person)-[r:DIRECTED]->(m:Movie) RETURNp.name as name type(r) as Acted_Directed, m.title as title MATCH (actor:Person)-[r:ACTED_INI DIRECTED]->(movie:Movie) RETURN actor.name AS name, type(r) AS acted_in, movie.title AS title\n\"name\", 1 = \"Acted_Directed\"|\"title\". \"name\", 2 = . \"Nathan Lane\", 1 = \"ACTED_IN\". \"Nathan Lane\", 2 = \"JoeVersustheVolcano\". \"Tom Hanks\", 1 = \"ACTED_IN\". \"Tom Hanks\", 2 = \"Joe Versus the Volcano\". \"Meg Ryan\", 1 = \"ACTED_IN\". \"Meg Ryan\", 2 = \"Joe Versus the Volcano\". \"Lilly Wachowski\", 1 = \"DIRECTED\". \"Lilly Wachowski\", 2 = \"The Matrix\". \"Lana Wachowski\", 1 = \"DIRECTED\". \"Lana Wachowski\", 2 = \"The Matrix\". \"Rob Reiner\", 1 = \"DIRECTED\". \"Rob Reiner\", 2 = \"When Harry Met Sally\"\n4\nSource: https://neo4j.com/developer/cypher-query-language/"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 2, "lecture_id": "11-Neo4J-Part2", "chunk_id": "11-Neo4J-Part2__0002"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0007"}, "gap_lectures": -1}}}
{"A": {"name": "QUERY_OPTIMIZATION", "role": "NA"}, "B": {"name": "QUERY_PROCESSING", "role": "NA"}, "relation": "depends_on", "justification": "Query optimization is a process that relies on query processing to determine the most efficient execution plan for a given query. Query processing is a prerequisite for understanding and implementing query optimization.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "5- SQL4-AggGrpViews__0000", "lecture_id": "5- SQL4-AggGrpViews", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems\n工"}, {"source": "cluster_B", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "19-Trxn-Mgmt__0001", "lecture_id": "19-Trxn-Mgmt", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}, {"source": "cluster_B", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "20-Trxn-Serializability__0000", "lecture_id": "20-Trxn-Serializability", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}, {"source": "cluster_B", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "7- ConstraintsTriggers__0000", "lecture_id": "7- ConstraintsTriggers", "text": "University of Illinois at Urbana -Champaign CS411: Database Systems\n工"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0001"}, "A_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0022"}, "gap_lectures": 3}}}
{"A": {"name": "QUERY_OPTIMIZATION", "role": "NA"}, "B": {"name": "SET_OPERATIONS", "role": "NA"}, "relation": "depends_on", "justification": "Query optimization relies on understanding relational algebra operations, including set operations, to find the most efficient way to evaluate queries.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 76, "label_hint": "algebra-and-relations-relational-operations", "chunk_id": "21-RA__0022", "lecture_id": "21-RA", "text": "- The relational algebra is a set of mathematical operators that compose, modify, and combine tuples within different relations\n- Basic SQL expressions can be expressed in this form\n- Relational algebra has laws of commutativity, associativity, etc. that imply certain expressions are equivalent in semantics\n- This is used in query optimization to find the most efficient representation to evaluate (or one that's not bad)"}, {"source": "cluster_B", "cluster_id": 76, "label_hint": "algebra-and-relations-relational-operations", "chunk_id": "21-RA__0011", "lecture_id": "21-RA", "text": "- If two relations have the same structure (DB terminology: are union-compatible. Programming language terminology: have the same type) we can perform set operations."}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0011"}, "A_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0022"}, "gap_lectures": 0}}}
{"A": {"name": "QUERY_OPTIMIZATION", "role": "NA"}, "B": {"name": "TRANSACTIONS", "role": "NA"}, "relation": null, "justification": "There is no clear connection or co-occurrence between QUERY_OPTIMIZATION and TRANSACTIONS in the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "5- SQL4-AggGrpViews__0000", "lecture_id": "5- SQL4-AggGrpViews", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems\n工"}, {"source": "cluster_B", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "10-Neo4J-Part 1__0000", "lecture_id": "10-Neo4J-Part 1", "text": "University of Illinois at Urbana -Champaign CS411: Database Systems"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0000"}, "A_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0022"}, "gap_lectures": 11}}}
{"A": {"name": "QUERY_PROCESSING", "role": "NA"}, "B": {"name": "TRANSACTIONS", "role": "NA"}, "relation": null, "justification": "There is no clear evidence in the provided text that establishes a 'depends_on' or 'part_of' relationship between QUERY_PROCESSING and TRANSACTIONS.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "19-Trxn-Mgmt__0001", "lecture_id": "19-Trxn-Mgmt", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}, {"source": "cluster_A", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "20-Trxn-Serializability__0000", "lecture_id": "20-Trxn-Serializability", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}, {"source": "cluster_A", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "7- ConstraintsTriggers__0000", "lecture_id": "7- ConstraintsTriggers", "text": "University of Illinois at Urbana -Champaign CS411: Database Systems\n工"}, {"source": "cluster_B", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "10-Neo4J-Part 1__0000", "lecture_id": "10-Neo4J-Part 1", "text": "University of Illinois at Urbana -Champaign CS411: Database Systems"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0000"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0001"}, "gap_lectures": 8}}}
{"A": {"name": "READ", "role": "NA"}, "B": {"name": "READ_OPERATION", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly establish a 'depends_on' or 'part_of' relationship between 'READ' and 'READ_OPERATION'. The evidence shows both terms in different contexts within the same lecture but does not provide sufficient information to infer a clear dependency or part-of relationship.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 34, "label_hint": "t1-and-t2-t3-write", "chunk_id": "20-Trxn-Serializability__0019", "lecture_id": "20-Trxn-Serializability", "text": "T1:        R(A)   W(A)\nR(B)    W(B)\nT2:\nR(A)     W(A)\nR(B)   W(B)"}, {"source": "cluster_B", "cluster_id": 34, "label_hint": "t1-and-t2-t3-write", "chunk_id": "20-Trxn-Serializability__0020", "lecture_id": "20-Trxn-Serializability", "text": "T1:, 1 = R(A),. T1:, 2 = R(C). T1:, 3 = W(B). T2: T3:, 1 = R(B). T2: T3:, 2 = . T2: T3:, 3 = R(B)\n```\nS1(A); R1(A); S2(B) R2(B); S3(A); R3(A); X2(C); W2(C); REL2(C); S1(C); R1(C); R2(B); REL2(B); X1(B); W1(B); REL1(A,B,C); S3(B); R3(B); REL3(A,B);\n```"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 2, "reason": "A and B appear in different chunks within 2 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0021"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0019"}, "gap_lectures": 2}}}
{"A": {"name": "READ", "role": "NA"}, "B": {"name": "TRANSACTION_ISOLATION", "role": "NA"}, "relation": null, "justification": "There is no clear dependency or part_of relationship between 'READ' and 'TRANSACTION_ISOLATION' based on the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 34, "label_hint": "t1-and-t2-t3-write", "chunk_id": "20-Trxn-Serializability__0019", "lecture_id": "20-Trxn-Serializability", "text": "T1:        R(A)   W(A)\nR(B)    W(B)\nT2:\nR(A)     W(A)\nR(B)   W(B)"}, {"source": "cluster_B", "cluster_id": 34, "label_hint": "t1-and-t2-t3-write", "chunk_id": "20-Trxn-Serializability__0020", "lecture_id": "20-Trxn-Serializability", "text": "T1:, 1 = R(A),. T1:, 2 = R(C). T1:, 3 = W(B). T2: T3:, 1 = R(B). T2: T3:, 2 = . T2: T3:, 3 = R(B)\n```\nS1(A); R1(A); S2(B) R2(B); S3(A); R3(A); X2(C); W2(C); REL2(C); S1(C); R1(C); R2(B); REL2(B); X1(B); W1(B); REL1(A,B,C); S3(B); R3(B); REL3(A,B);\n```"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 2, "reason": "A and B appear in different chunks within 2 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0013"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0019"}, "gap_lectures": 2}}}
{"A": {"name": "READ", "role": "NA"}, "B": {"name": "WRITE_OPERATION", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly establish a 'depends_on' or 'part_of' relationship between 'READ' and 'WRITE_OPERATION'. The co-occurrence in different chunks within the same cluster does not provide sufficient context to infer a clear prerequisite or component relationship.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 34, "label_hint": "t1-and-t2-t3-write", "chunk_id": "20-Trxn-Serializability__0019", "lecture_id": "20-Trxn-Serializability", "text": "T1:        R(A)   W(A)\nR(B)    W(B)\nT2:\nR(A)     W(A)\nR(B)   W(B)"}, {"source": "cluster_B", "cluster_id": 34, "label_hint": "t1-and-t2-t3-write", "chunk_id": "20-Trxn-Serializability__0020", "lecture_id": "20-Trxn-Serializability", "text": "T1:, 1 = R(A),. T1:, 2 = R(C). T1:, 3 = W(B). T2: T3:, 1 = R(B). T2: T3:, 2 = . T2: T3:, 3 = R(B)\n```\nS1(A); R1(A); S2(B) R2(B); S3(A); R3(A); X2(C); W2(C); REL2(C); S1(C); R1(C); R2(B); REL2(B); X1(B); W1(B); REL1(A,B,C); S3(B); R3(B); REL3(A,B);\n```"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 2, "reason": "A and B appear in different chunks within 2 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0004"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0019"}, "gap_lectures": 0}}}
{"A": {"name": "READ_OPERATION", "role": "NA"}, "B": {"name": "SERIALIZABILITY", "role": "NA"}, "relation": "depends_on", "justification": "The concept of read operations is necessary to understand the conditions for view equivalence, which is a prerequisite for understanding serializability.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0014", "lecture_id": "20-Trxn-Serializability", "text": "Two schedules S1 and S2 are view equivalent if:\n- If ௜ reads an initial value of A in S1, then ௜ reads the initial value of A in S2\n- If ௜ reads a value of A written by ௝ in S1, then ௜ reads a value of A written by ௝ in S2\n- If ௜ writes the final value of A in S1, then ௜ writes the final value of A in S2\nA schedule is view serializable if it is view-equivalent to a serial schedule"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0005", "lecture_id": "20-Trxn-Serializability", "text": "A schedule is serializable if it is equivalent to a serial schedule.\nFinal state must be the same as the state produced by one of the serial schedules.\nT1\nT2\nREAD(A, t)\nt := t+100\nWRITE(A, t)\nREAD(A, s)\ns := s*2\nWRITE(A,s)\nREAD(B, t)\nt := t+100\nWRITE(B,t)\nREAD(B,s)\ns := s*2\nWRITE(B,s)"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0017", "lecture_id": "20-Trxn-Serializability", "text": "If all transactions are well-formed and two-phase, then any schedule in which conflicting locks are never granted ensures serializability"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0006"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0021"}, "gap_lectures": 0}}}
{"A": {"name": "READ_OPERATION", "role": "NA"}, "B": {"name": "SERIALIZABLE_SCHEDULES", "role": "NA"}, "relation": "depends_on", "justification": "The concept of read operations is necessary to understand the context of serializable schedules, as serializable schedules involve specific read and write operations that must be view-equivalent to a serial schedule.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0014", "lecture_id": "20-Trxn-Serializability", "text": "Two schedules S1 and S2 are view equivalent if:\n- If ௜ reads an initial value of A in S1, then ௜ reads the initial value of A in S2\n- If ௜ reads a value of A written by ௝ in S1, then ௜ reads a value of A written by ௝ in S2\n- If ௜ writes the final value of A in S1, then ௜ writes the final value of A in S2\nA schedule is view serializable if it is view-equivalent to a serial schedule"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0007", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n- Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0015", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0023", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n-  Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0021"}, "gap_lectures": -2}}}
{"A": {"name": "READ_OPERATION", "role": "NA"}, "B": {"name": "SERIAL_SCHEDULES", "role": "NA"}, "relation": "depends_on", "justification": "The concept of read operations is necessary to understand the conditions for view equivalence, which is a prerequisite for understanding serial schedules and serializability.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0014", "lecture_id": "20-Trxn-Serializability", "text": "Two schedules S1 and S2 are view equivalent if:\n- If ௜ reads an initial value of A in S1, then ௜ reads the initial value of A in S2\n- If ௜ reads a value of A written by ௝ in S1, then ௜ reads a value of A written by ௝ in S2\n- If ௜ writes the final value of A in S1, then ௜ writes the final value of A in S2\nA schedule is view serializable if it is view-equivalent to a serial schedule"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0001", "lecture_id": "20-Trxn-Serializability", "text": "- Describe the theory of serializability, including Serial, Serializable, Conflict-Serializable, and  View-Serializable schedules.\n- Use the Precedence Graph Algorithm to test for conflictserializability.\n- Describe how commercial database systems use twophase locking to guarantee serializability of concurrent transactions."}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0007", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n- Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0015", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0001"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0021"}, "gap_lectures": -2}}}
{"A": {"name": "READ_OPERATION", "role": "NA"}, "B": {"name": "STRICT_TWO_PHASED_LOCKING", "role": "NA"}, "relation": null, "justification": "There is no clear evidence that either 'READ_OPERATION' depends on 'STRICT_TWO_PHASED_LOCKING' or vice versa. The provided evidence does not establish a clear prerequisite or part-of relationship between the two concepts.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0014", "lecture_id": "20-Trxn-Serializability", "text": "Two schedules S1 and S2 are view equivalent if:\n- If ௜ reads an initial value of A in S1, then ௜ reads the initial value of A in S2\n- If ௜ reads a value of A written by ௝ in S1, then ௜ reads a value of A written by ௝ in S2\n- If ௜ writes the final value of A in S1, then ௜ writes the final value of A in S2\nA schedule is view serializable if it is view-equivalent to a serial schedule"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0007", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n- Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0015", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0023", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n-  Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0021"}, "gap_lectures": -2}}}
{"A": {"name": "READ_OPERATION", "role": "NA"}, "B": {"name": "THEORY_OF_SERIALIZABILITY", "role": "NA"}, "relation": "depends_on", "justification": "The concept of read operations is used in the definition of view equivalence, which is a fundamental concept in the theory of serializability. Therefore, understanding read operations is a prerequisite for understanding the theory of serializability.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0014", "lecture_id": "20-Trxn-Serializability", "text": "Two schedules S1 and S2 are view equivalent if:\n- If ௜ reads an initial value of A in S1, then ௜ reads the initial value of A in S2\n- If ௜ reads a value of A written by ௝ in S1, then ௜ reads a value of A written by ௝ in S2\n- If ௜ writes the final value of A in S1, then ௜ writes the final value of A in S2\nA schedule is view serializable if it is view-equivalent to a serial schedule"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0007", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n- Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0015", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0023", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n-  Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0021"}, "gap_lectures": -2}}}
{"A": {"name": "READ_OPERATION", "role": "NA"}, "B": {"name": "TRANSACTION", "role": "NA"}, "relation": "depends_on", "justification": "The evidence suggests that a read operation is part of a transaction, but more strongly, a transaction is necessary to perform a read operation, indicating a dependency.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 8, "label_hint": "123-and-zip-starttransaction-sid", "chunk_id": "19-Trxn-Mgmt__0021", "lecture_id": "19-Trxn-Mgmt", "text": "sid, 1 = name. sid, 2 = zip. 123, 1 = Qin. 123, 2 = 14001. 321, 1 = Kristin. 321, 2 = 14104\nSTARTTRANSACTION;, Transaction 2 = STARTTRANSACTION;. SELECT zipFROM studentWHEREsid = 123; /* will read 14111*/, Transaction 2 = ROLLBACK /* zip code will revert to 14001*/ 19"}, {"source": "cluster_B", "cluster_id": 8, "label_hint": "123-and-zip-starttransaction-sid", "chunk_id": "19-Trxn-Mgmt__0022", "lecture_id": "19-Trxn-Mgmt", "text": "123, name = Qin. 123, zip = 14001. 321, name = Kristin. 321, zip = 14104. Transaction 1, name = Transaction 1. Transaction 1, zip = Transaction 2. STARTTRANSACTION;, name = STARTTRANSACTION;. STARTTRANSACTION;, zip = STARTTRANSACTION;. SELECT zipFROM studentWHEREsid = 123; /* will read 14001*/, name = SELECT zipFROM studentWHEREsid = 123; /* will read 14001*/. SELECT zipFROM studentWHEREsid = 123; /* will read 14001*/, zip = UPDATE student SET zip = 14111WHERE sid = 123;. SELECT zipFROM studentWHEREsid = 123; /* will read 14111*/, name = SELECT zipFROM studentWHEREsid = 123; /* will read 14111*/. SELECT zipFROM studentWHEREsid = 123; /* will read 14111*/, zip = COMMIT;"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 3, "reason": "A and B appear in different chunks within 3 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0022"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0021"}, "gap_lectures": 0}}}
{"A": {"name": "READ_OPERATION", "role": "NA"}, "B": {"name": "TRANSACTION_MANAGEMENT", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly establish a 'depends_on' or 'part_of' relationship between 'READ_OPERATION' and 'TRANSACTION_MANAGEMENT'. The evidence shows that 'READ_OPERATION' is part of the discussion on view equivalence and serializability, while 'TRANSACTION_MANAGEMENT' is discussed in the context of ensuring serializability through locking. There is no clear indication that one concept directly depends on or is part of the other.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0014", "lecture_id": "20-Trxn-Serializability", "text": "Two schedules S1 and S2 are view equivalent if:\n- If ௜ reads an initial value of A in S1, then ௜ reads the initial value of A in S2\n- If ௜ reads a value of A written by ௝ in S1, then ௜ reads a value of A written by ௝ in S2\n- If ௜ writes the final value of A in S1, then ௜ writes the final value of A in S2\nA schedule is view serializable if it is view-equivalent to a serial schedule"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0017", "lecture_id": "20-Trxn-Serializability", "text": "If all transactions are well-formed and two-phase, then any schedule in which conflicting locks are never granted ensures serializability"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 3, "reason": "A and B appear in different chunks within 3 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0001"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0021"}, "gap_lectures": 0}}}
{"A": {"name": "READ_OPERATION", "role": "NA"}, "B": {"name": "TWO_PHASED_LOCKING", "role": "NA"}, "relation": null, "justification": "There is no clear evidence that READ_OPERATION depends on or is part of TWO_PHASED_LOCKING. The provided evidence does not establish a direct prerequisite or component relationship between the two concepts.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0014", "lecture_id": "20-Trxn-Serializability", "text": "Two schedules S1 and S2 are view equivalent if:\n- If ௜ reads an initial value of A in S1, then ௜ reads the initial value of A in S2\n- If ௜ reads a value of A written by ௝ in S1, then ௜ reads a value of A written by ௝ in S2\n- If ௜ writes the final value of A in S1, then ௜ writes the final value of A in S2\nA schedule is view serializable if it is view-equivalent to a serial schedule"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0007", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n- Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0015", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0016", "lecture_id": "20-Trxn-Serializability", "text": "A transaction is well-formed if it acquires at least a shared lock on Q before reading Q or an exclusive lock on Q before writing Q and doesn't release the lock until the action is performed\nA transaction is two-phased if it never acquires a lock after unlocking one\n-  There are two phases:\n-  a growing phase in which the transaction acquires locks\n-  a shrinking phase in which locks are released"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0021"}, "gap_lectures": -2}}}
{"A": {"name": "READ_OPERATION", "role": "NA"}, "B": {"name": "WRITE", "role": "NA"}, "relation": null, "justification": "There is no clear dependency or part_of relationship between READ_OPERATION and WRITE based on the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 34, "label_hint": "t1-and-t2-t3-write", "chunk_id": "20-Trxn-Serializability__0020", "lecture_id": "20-Trxn-Serializability", "text": "T1:, 1 = R(A),. T1:, 2 = R(C). T1:, 3 = W(B). T2: T3:, 1 = R(B). T2: T3:, 2 = . T2: T3:, 3 = R(B)\n```\nS1(A); R1(A); S2(B) R2(B); S3(A); R3(A); X2(C); W2(C); REL2(C); S1(C); R1(C); R2(B); REL2(B); X1(B); W1(B); REL1(A,B,C); S3(B); R3(B); REL3(A,B);\n```"}, {"source": "cluster_B", "cluster_id": 34, "label_hint": "t1-and-t2-t3-write", "chunk_id": "20-Trxn-Serializability__0019", "lecture_id": "20-Trxn-Serializability", "text": "T1:        R(A)   W(A)\nR(B)    W(B)\nT2:\nR(A)     W(A)\nR(B)   W(B)"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 2, "reason": "A and B appear in different chunks within 2 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0019"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0021"}, "gap_lectures": -2}}}
{"A": {"name": "REFERENTIAL_INTEGRITY", "role": "NA"}, "B": {"name": "RELATIONSHIP", "role": "NA"}, "relation": "depends_on", "justification": "Referential integrity relies on the concept of relationships to ensure that the foreign keys in one table reference valid primary keys in another table.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0018", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nMgrSSN is a foreign key (referencing the Employee relation)\nvalue of Manager must match an SSN\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nvs.\nProject(P-number, P-name, Due-Date)\nEmployee(SSN, E-Name, Office)\nManager(P-number, SSN)\nWhat are the tradeoffs between these two?\nNote: P-number is the key for Manager"}, {"source": "cluster_A", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design__0018", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nMgrSSN is a foreign key (referencing the Employee relation)\nvalue of Manager must match an SSN\nProject(P-number, P-name, Due-Date, MgrSSN) Employee(SSN, E-Name, Office)\nvs.\nProject(P-number, P-name, Due-Date)\nEmployee(SSN, E-Name, Office)\nManager(P-number, SSN)\nWhat are the tradeoffs between these two?\nNote: P-number is the key for Manager"}, {"source": "cluster_B", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design (1)__0016", "lecture_id": "12-Conceptual_Logical_DB_Design (1)", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nWhat are the attributes and what is the key for Assignment?\n```\nProject(P-number, P-name, Due-Date) Employee(SSN, E-Name, Office)\n```\nProject\nP-number P-name Due-Date\nEmployee\nSSN\nE-Name\nOffice\n0..*     Assignment      0..*\n- 0..*        Manager        1..1\nAnswer: Assignment(P-Number, SSN)\nP-Number is a foreign key for Project SSN is a foreign key for Employee\nProject(P-Number, P-Due-Date)\nEmployee(SSN, E-Name, Office)"}, {"source": "cluster_B", "cluster_id": 38, "label_hint": "number-and-date-employee-ssn", "chunk_id": "12-Conceptual_Logical_DB_Design__0016", "lecture_id": "12-Conceptual_Logical_DB_Design", "text": "P-number, 0..* = 0..*. P-number, Assignment = Manager. P-number, 0..* = 1..1. P-number, Employee = SSN. P-name Due-Date, 0..* = . P-name Due-Date, Assignment = . P-name Due-Date, 0..* = . P-name Due-Date, Employee = E-Name Office\nWhat are the attributes and what is the key for Assignment?\n```\nProject(P-number, P-name, Due-Date) Employee(SSN, E-Name, Office)\n```\nProject\nP-number P-name Due-Date\nEmployee\nSSN\nE-Name\nOffice\n0..*     Assignment      0..*\n- 0..*        Manager        1..1\nAnswer: Assignment(P-Number, SSN)\nP-Number is a foreign key for Project SSN is a foreign key for Employee\nProject(P-Number, P-Due-Date)\nEmployee(SSN, E-Name, Office)"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0005"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0015"}, "gap_lectures": -4}}}
{"A": {"name": "REFERENTIAL_INTEGRITY", "role": "NA"}, "B": {"name": "WHERE_CLAUSE", "role": "NA"}, "relation": null, "justification": "There is no clear connection between referential integrity and WHERE clause based on the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0015", "lecture_id": "1-RelationalModel", "text": ", Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. , Number = 102. , Owner = W. Wei. , Balance = 2000.00. , Type = checking. , Number = 103. , Owner = J. Smith. , Balance = 5000.00. , Type = savings. , Number = 104. , Owner = M. Jones. , Balance = 1000.00. , Type = checking. , Number = 105. , Owner = H. Martin. , Balance = 10,000.00. , Type = checking. Deposit, Number = AcctNo Transaction-id. Deposit, Owner = Date. Deposit, Balance = Amount. Deposit, Type = . , Number = 102 1. , Owner = 10/22/00. , Balance = 500.00. , Type = . , Number = 102 2. , Owner = 10/29/00. , Balance = 200.00. , Type = . , Number = 104 3. , Owner = 10/29/00. , Balance = 1000.00. , Type = . , Number = 105 4. , Owner = 11/02/00. , Balance = 10,000.00. , Type = . , Number = 106 5. , Owner = 12/05/00. , Balance = 555.00. , Type = \nWe say that Deposit.AcctNo is a foreign key that references Account.Number.  If the DBMS enforces this constraint, we have referential integrity .\n, Foreign keys might or might not be part of the key for the referring table.Number = 101 102 103 104 105. , Foreign keys might or might not be part of the key for the referring table.Owner = J. Smith W. Wei J. Smith M. Jones H. Martin. , Foreign keys might or might not be part of the key for the referring table.Balance = 1000.00 2000.00 5000.00 1000.00 10,000.00. , Foreign keys might or might not be part of the key for the referring table.Type = checking checking savings checking checking. Deposit, Foreign keys might or might not be part of the key for the referring table.Number = AcctNo. Deposit, Foreign keys might or might not be part of the key for the referring table.Owner = Transaction-id. Deposit, Foreign keys might or might not be part of the key for the referring table.Balance = Date. Deposit, Foreign keys might or might not be part of the key for the referring table.Type = Amount. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Number = AcctNo 101 101. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Owner = Check-number 924 925. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Balance = Date 10/23/00 10/24/00. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Type = Amount 125.00 23.98\n-  Data Models\n- Relational Database Model\n-  Basic Concepts and Terminology\n-  Keys and Foreign Keys\n- Schema Specifications"}, {"source": "cluster_B", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "2-SQL-Basics__0005", "lecture_id": "2-SQL-Basics", "text": "Account, 1 = Number. Account, 2 = Owner. Account, 3 = Balance. Account, 4 = T\\pe. , 1 = 101. , 2 = J. Smith. , 3 = 1000.00. , 4 = checking. , 1 = 102. , 2 = W. Wei. , 3 = 2000.00. , 4 = checking. , 1 = 103. , 2 = J. Smith. , 3 = 5000.00. , 4 = savings. , 1 = 104. , 2 = M. Jones. , 3 = 1000.00. , 4 = checking. , 1 = 105. , 2 = H. Martin. , 3 = 10,000.00. , 4 = checking\nSELECT, 1 = Number, Owner. FROM, 1 = Account. WHERE, 1 = T\\pe = \" savings \" ;\nNumber, 1 = Owner\n103\nJ. Smith"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 10, "lecture_id": "2-SQL-Basics", "chunk_id": "2-SQL-Basics__0005"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0015"}, "gap_lectures": -10}}}
{"A": {"name": "RELATIONAL_ALGEBRA", "role": "NA"}, "B": {"name": "RELATIONAL_SCHEMA", "role": "NA"}, "relation": "depends_on", "justification": "Relational Algebra (A) involves operations that manipulate relations, which are defined by a Relational Schema (B). Understanding the schema is necessary to apply algebraic operations correctly.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 87, "label_hint": "001-and-sem-sid-cid", "chunk_id": "23-Rule-basedOpt__0001", "lecture_id": "23-Rule-basedOpt", "text": "Need to start someplace..\nThe easy cases:\n```\nSelect a1, …, an From R1, …, Rk Where C\n```\n<!-- formula-not-decoded -->\n```\nSelect a1, …, an, aggs From R1, …, Rk Where C Group by b1, …, bl\n```\nUses 'extended' relational algebra, with gamma and delta\n<!-- formula-not-decoded -->\nIn most of these cases, the x will be a"}, {"source": "cluster_B", "cluster_id": 87, "label_hint": "001-and-sem-sid-cid", "chunk_id": "21-RA__0006", "lecture_id": "21-RA", "text": "- Does not change the relational instance\n- Changes the relational schema only\n- Notation: ρS(B1,…,Bn) (R)\n- Input schema:\nR(A1, …, An)\n- Output schema:\nS(B1, …, Bn)\n- Example: rename Student(sid, name)\nρ RenamedStudent(UIN, lastname) (Student)"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "A_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0002"}, "gap_lectures": 8}}}
{"A": {"name": "RELATIONAL_ALGEBRA", "role": "NA"}, "B": {"name": "SET_OPERATIONS", "role": "NA"}, "relation": "depends_on", "justification": "Set operations are foundational for understanding relational algebra, as relational algebra operations operate on relations and produce relations, and set operations are a key component of these operations.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 76, "label_hint": "algebra-and-relations-relational-operations", "chunk_id": "21-RA__0003", "lecture_id": "21-RA", "text": "- An algebra whose:\n- Operands are relations or variables that represent relations.\n- Operators are designed to do common things that we need to do with relations in a database.\n- Relational algebra operations operate on relations and produce relations\n- The result is an algebra that can be used as a query language for relations.\n- Unary:  f: Relation  Relation\n- Binary: g: Relation x Relation \nRelation"}, {"source": "cluster_A", "cluster_id": 76, "label_hint": "algebra-and-relations-relational-operations", "chunk_id": "21-RA__0014", "lecture_id": "21-RA", "text": "- Algebras allow us to express sequences of operations in a natural way.\n- Example\n- in arithmetic algebra:     ( x + 4)*( y -\n<!-- formula-not-decoded -->\n- Relational algebra allows the same.\n- Three notations:\n1. Sequences of assignment statements.\n2. Expressions with several operators.\n3. Expression trees."}, {"source": "cluster_A", "cluster_id": 76, "label_hint": "algebra-and-relations-relational-operations", "chunk_id": "21-RA__0022", "lecture_id": "21-RA", "text": "- The relational algebra is a set of mathematical operators that compose, modify, and combine tuples within different relations\n- Basic SQL expressions can be expressed in this form\n- Relational algebra has laws of commutativity, associativity, etc. that imply certain expressions are equivalent in semantics\n- This is used in query optimization to find the most efficient representation to evaluate (or one that's not bad)"}, {"source": "cluster_B", "cluster_id": 76, "label_hint": "algebra-and-relations-relational-operations", "chunk_id": "21-RA__0011", "lecture_id": "21-RA", "text": "- If two relations have the same structure (DB terminology: are union-compatible. Programming language terminology: have the same type) we can perform set operations."}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0011"}, "A_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0002"}, "gap_lectures": 0}}}
{"A": {"name": "RELATIONAL_ALGEBRA", "role": "NA"}, "B": {"name": "STUDENT_DATA", "role": "NA"}, "relation": null, "justification": "No decision (LLM output invalid).", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 87, "label_hint": "001-and-sem-sid-cid", "chunk_id": "23-Rule-basedOpt__0001", "lecture_id": "23-Rule-basedOpt", "text": "Need to start someplace..\nThe easy cases:\n```\nSelect a1, …, an From R1, …, Rk Where C\n```\n<!-- formula-not-decoded -->\n```\nSelect a1, …, an, aggs From R1, …, Rk Where C Group by b1, …, bl\n```\nUses 'extended' relational algebra, with gamma and delta\n<!-- formula-not-decoded -->\nIn most of these cases, the x will be a"}, {"source": "cluster_B", "cluster_id": 87, "label_hint": "001-and-sem-sid-cid", "chunk_id": "21-RA__0008", "lecture_id": "21-RA", "text": "- Products are hardly ever used alone; they are typically used in conjunction with a selection. Example:\n<!-- formula-not-decoded -->\nSELECT DISTINCT * FROM Student s JOIN Takes t On s.sid=t.sid\nSELECT DISTINCT * FROM Student s, Takes t WHERE s.sid=t.sid\n1, name = Jill. 1, sid:2 = 1. 1, exp-grade = A. 1, cid = 550-001. 1, sem = F14. 1, name = Jill. 1, sid:2 = 1. 1, exp-grade = C. 1, cid = 502-001. 1, sem = F14. 3, name = Maya. 3, sid:2 = 3. 3, exp-grade = A. 3, cid = 555-001. 3, sem = S15. 3, name = Maya. 3, sid:2 = 3. 3, exp-grade = B. 3, cid = 550-001. 3, sem = F14"}, {"source": "cluster_B", "cluster_id": 87, "label_hint": "001-and-sem-sid-cid", "chunk_id": "21-RA__0012", "lecture_id": "21-RA", "text": "1, name = Jill. 12, name = Susan. 18, name = Roger\n1, name = Jill. 2, name = Bo. 3, name = Maya\n(SELECT sid, name FROM STUDENT) UNION (SELECT sid, name FROM POSTDOC)\nSTUDENT U POSTDOC\n1, name = Jill. 2, name = Bo. 3, name = Maya. 12, name = Susan. 18, name = Roger\n1, name = Jill. 2, name = Bo. 3, name = Maya\n1, name = Jill. 12, name = Susan. 18, name = Roger\n2, name = Bo. 3, name = Maya\n550-001, subj = DB. 550-001, sem = F14. 502-001, subj = Algo. 502-001, sem = F14. 555-001, subj = I&W. 555-001, sem = S15. 666-001, subj = Ethics. 666-001, sem = S66"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0008"}, "A_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0002"}, "gap_lectures": 0}, "_error": "Unbalanced JSON braces in output."}}
{"A": {"name": "RELATIONAL_SCHEMA", "role": "NA"}, "B": {"name": "STUDENT_DATA", "role": "NA"}, "relation": "depends_on", "justification": "The evidence suggests that understanding relational schema is a prerequisite for working with STUDENT_DATA, as relational schema operations like renaming are applied to the STUDENT_DATA.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 87, "label_hint": "001-and-sem-sid-cid", "chunk_id": "21-RA__0006", "lecture_id": "21-RA", "text": "- Does not change the relational instance\n- Changes the relational schema only\n- Notation: ρS(B1,…,Bn) (R)\n- Input schema:\nR(A1, …, An)\n- Output schema:\nS(B1, …, Bn)\n- Example: rename Student(sid, name)\nρ RenamedStudent(UIN, lastname) (Student)"}, {"source": "cluster_B", "cluster_id": 87, "label_hint": "001-and-sem-sid-cid", "chunk_id": "21-RA__0008", "lecture_id": "21-RA", "text": "- Products are hardly ever used alone; they are typically used in conjunction with a selection. Example:\n<!-- formula-not-decoded -->\nSELECT DISTINCT * FROM Student s JOIN Takes t On s.sid=t.sid\nSELECT DISTINCT * FROM Student s, Takes t WHERE s.sid=t.sid\n1, name = Jill. 1, sid:2 = 1. 1, exp-grade = A. 1, cid = 550-001. 1, sem = F14. 1, name = Jill. 1, sid:2 = 1. 1, exp-grade = C. 1, cid = 502-001. 1, sem = F14. 3, name = Maya. 3, sid:2 = 3. 3, exp-grade = A. 3, cid = 555-001. 3, sem = S15. 3, name = Maya. 3, sid:2 = 3. 3, exp-grade = B. 3, cid = 550-001. 3, sem = F14"}, {"source": "cluster_B", "cluster_id": 87, "label_hint": "001-and-sem-sid-cid", "chunk_id": "21-RA__0012", "lecture_id": "21-RA", "text": "1, name = Jill. 12, name = Susan. 18, name = Roger\n1, name = Jill. 2, name = Bo. 3, name = Maya\n(SELECT sid, name FROM STUDENT) UNION (SELECT sid, name FROM POSTDOC)\nSTUDENT U POSTDOC\n1, name = Jill. 2, name = Bo. 3, name = Maya. 12, name = Susan. 18, name = Roger\n1, name = Jill. 2, name = Bo. 3, name = Maya\n1, name = Jill. 12, name = Susan. 18, name = Roger\n2, name = Bo. 3, name = Maya\n550-001, subj = DB. 550-001, sem = F14. 502-001, subj = Algo. 502-001, sem = F14. 555-001, subj = I&W. 555-001, sem = S15. 666-001, subj = Ethics. 666-001, sem = S66"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0008"}, "A_first_introduced_at": {"lecture_index": 4, "lecture_id": "12-Conceptual_Logical_DB_Design", "chunk_id": "12-Conceptual_Logical_DB_Design__0000"}, "gap_lectures": -8}}}
{"A": {"name": "SCHEMA_SPECIFICATIONS", "role": "NA"}, "B": {"name": "WHERE_CLAUSE", "role": "NA"}, "relation": "depends_on", "justification": "Schema Specifications (A) are foundational concepts that define the structure of a database, which are necessary prerequisites for understanding and using WHERE clauses (B) in SQL queries.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0012", "lecture_id": "1-RelationalModel", "text": "The intension of the table\n101, Owner = J. Smith. 101, Balance = 1000.00. 101, Type = checking. 102, Owner = W. Wei. 102, Balance = 2000.00. 102, Type = checking. 103, Owner = J. Smith. 103, Balance = 5000.00. 103, Type = savings. 104, Owner = M. Jones. 104, Balance = 1000.00. 104, Type = checking. 105, Owner = H. Martin. 105, Balance = 10,000.00. 105, Type = checking\nThe extension of the table.  Also called the extent .\n, Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. Cardinality, Number = 102. Cardinality, Owner = W. Wei. Cardinality, Balance = 2000.00. Cardinality, Type = checking. of this instance is 5 (because, Number = 103. of this instance is 5 (because, Owner = J. Smith. of this instance is 5 (because, Balance = 5000.00. of this instance is 5 (because, Type = savings. there are 5, Number = 104. there are 5, Owner = M. Jones. there are 5, Balance = 1000.00. there are 5, Type = checking. rows), Number = 105. rows), Owner = H. Martin. rows), Balance = 10,000.00. rows), Type = checking\n-  Data Models\n- Relational Database Model\n-  Basic Concepts and Terminology\n- Keys and Foreign Keys\n- Schema Specifications"}, {"source": "cluster_A", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "1-RelationalModel__0015", "lecture_id": "1-RelationalModel", "text": ", Number = 101. , Owner = J. Smith. , Balance = 1000.00. , Type = checking. , Number = 102. , Owner = W. Wei. , Balance = 2000.00. , Type = checking. , Number = 103. , Owner = J. Smith. , Balance = 5000.00. , Type = savings. , Number = 104. , Owner = M. Jones. , Balance = 1000.00. , Type = checking. , Number = 105. , Owner = H. Martin. , Balance = 10,000.00. , Type = checking. Deposit, Number = AcctNo Transaction-id. Deposit, Owner = Date. Deposit, Balance = Amount. Deposit, Type = . , Number = 102 1. , Owner = 10/22/00. , Balance = 500.00. , Type = . , Number = 102 2. , Owner = 10/29/00. , Balance = 200.00. , Type = . , Number = 104 3. , Owner = 10/29/00. , Balance = 1000.00. , Type = . , Number = 105 4. , Owner = 11/02/00. , Balance = 10,000.00. , Type = . , Number = 106 5. , Owner = 12/05/00. , Balance = 555.00. , Type = \nWe say that Deposit.AcctNo is a foreign key that references Account.Number.  If the DBMS enforces this constraint, we have referential integrity .\n, Foreign keys might or might not be part of the key for the referring table.Number = 101 102 103 104 105. , Foreign keys might or might not be part of the key for the referring table.Owner = J. Smith W. Wei J. Smith M. Jones H. Martin. , Foreign keys might or might not be part of the key for the referring table.Balance = 1000.00 2000.00 5000.00 1000.00 10,000.00. , Foreign keys might or might not be part of the key for the referring table.Type = checking checking savings checking checking. Deposit, Foreign keys might or might not be part of the key for the referring table.Number = AcctNo. Deposit, Foreign keys might or might not be part of the key for the referring table.Owner = Transaction-id. Deposit, Foreign keys might or might not be part of the key for the referring table.Balance = Date. Deposit, Foreign keys might or might not be part of the key for the referring table.Type = Amount. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Number = AcctNo 101 101. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Owner = Check-number 924 925. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Balance = Date 10/23/00 10/24/00. Check.AcctNo is part of key for Check. Check, Foreign keys might or might not be part of the key for the referring table.Type = Amount 125.00 23.98\n-  Data Models\n- Relational Database Model\n-  Basic Concepts and Terminology\n-  Keys and Foreign Keys\n- Schema Specifications"}, {"source": "cluster_B", "cluster_id": 85, "label_hint": "00-and-owner-balance-checking", "chunk_id": "2-SQL-Basics__0005", "lecture_id": "2-SQL-Basics", "text": "Account, 1 = Number. Account, 2 = Owner. Account, 3 = Balance. Account, 4 = T\\pe. , 1 = 101. , 2 = J. Smith. , 3 = 1000.00. , 4 = checking. , 1 = 102. , 2 = W. Wei. , 3 = 2000.00. , 4 = checking. , 1 = 103. , 2 = J. Smith. , 3 = 5000.00. , 4 = savings. , 1 = 104. , 2 = M. Jones. , 3 = 1000.00. , 4 = checking. , 1 = 105. , 2 = H. Martin. , 3 = 10,000.00. , 4 = checking\nSELECT, 1 = Number, Owner. FROM, 1 = Account. WHERE, 1 = T\\pe = \" savings \" ;\nNumber, 1 = Owner\n103\nJ. Smith"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 10, "lecture_id": "2-SQL-Basics", "chunk_id": "2-SQL-Basics__0005"}, "A_first_introduced_at": {"lecture_index": 0, "lecture_id": "1-RelationalModel", "chunk_id": "1-RelationalModel__0006"}, "gap_lectures": -10}}}
{"A": {"name": "SERIALIZABILITY", "role": "NA"}, "B": {"name": "SERIALIZABLE_SCHEDULES", "role": "NA"}, "relation": "part_of", "justification": "Serializable schedules are a specific type of schedule that satisfies the condition of serializability.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0005", "lecture_id": "20-Trxn-Serializability", "text": "A schedule is serializable if it is equivalent to a serial schedule.\nFinal state must be the same as the state produced by one of the serial schedules.\nT1\nT2\nREAD(A, t)\nt := t+100\nWRITE(A, t)\nREAD(A, s)\ns := s*2\nWRITE(A,s)\nREAD(B, t)\nt := t+100\nWRITE(B,t)\nREAD(B,s)\ns := s*2\nWRITE(B,s)"}, {"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0017", "lecture_id": "20-Trxn-Serializability", "text": "If all transactions are well-formed and two-phase, then any schedule in which conflicting locks are never granted ensures serializability"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0007", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n- Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0015", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0023", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n-  Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0006"}, "gap_lectures": -2}}}
{"A": {"name": "SERIALIZABILITY", "role": "NA"}, "B": {"name": "SERIAL_SCHEDULES", "role": "NA"}, "relation": "depends_on", "justification": "SERIALIZABILITY depends on understanding SERIAL_SCHEDULES because the definition of serializability is based on the equivalence to serial schedules.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0005", "lecture_id": "20-Trxn-Serializability", "text": "A schedule is serializable if it is equivalent to a serial schedule.\nFinal state must be the same as the state produced by one of the serial schedules.\nT1\nT2\nREAD(A, t)\nt := t+100\nWRITE(A, t)\nREAD(A, s)\ns := s*2\nWRITE(A,s)\nREAD(B, t)\nt := t+100\nWRITE(B,t)\nREAD(B,s)\ns := s*2\nWRITE(B,s)"}, {"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0017", "lecture_id": "20-Trxn-Serializability", "text": "If all transactions are well-formed and two-phase, then any schedule in which conflicting locks are never granted ensures serializability"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0001", "lecture_id": "20-Trxn-Serializability", "text": "- Describe the theory of serializability, including Serial, Serializable, Conflict-Serializable, and  View-Serializable schedules.\n- Use the Precedence Graph Algorithm to test for conflictserializability.\n- Describe how commercial database systems use twophase locking to guarantee serializability of concurrent transactions."}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0007", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n- Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0015", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0001"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0006"}, "gap_lectures": -2}}}
{"A": {"name": "SERIALIZABILITY", "role": "NA"}, "B": {"name": "STRICT_TWO_PHASED_LOCKING", "role": "NA"}, "relation": "depends_on", "justification": "Strict two-phased locking (S2PL) is a specific locking protocol that ensures serializability, implying that understanding S2PL requires prior knowledge of serializability.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0005", "lecture_id": "20-Trxn-Serializability", "text": "A schedule is serializable if it is equivalent to a serial schedule.\nFinal state must be the same as the state produced by one of the serial schedules.\nT1\nT2\nREAD(A, t)\nt := t+100\nWRITE(A, t)\nREAD(A, s)\ns := s*2\nWRITE(A,s)\nREAD(B, t)\nt := t+100\nWRITE(B,t)\nREAD(B,s)\ns := s*2\nWRITE(B,s)"}, {"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0017", "lecture_id": "20-Trxn-Serializability", "text": "If all transactions are well-formed and two-phase, then any schedule in which conflicting locks are never granted ensures serializability"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0007", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n- Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0015", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0023", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n-  Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0006"}, "gap_lectures": -2}}}
{"A": {"name": "SERIALIZABILITY", "role": "NA"}, "B": {"name": "THEORY_OF_SERIALIZABILITY", "role": "NA"}, "relation": "depends_on", "justification": "The concept of serializability (A) is built upon the theory of serializability (B), which provides the foundational understanding required to grasp serializability.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0005", "lecture_id": "20-Trxn-Serializability", "text": "A schedule is serializable if it is equivalent to a serial schedule.\nFinal state must be the same as the state produced by one of the serial schedules.\nT1\nT2\nREAD(A, t)\nt := t+100\nWRITE(A, t)\nREAD(A, s)\ns := s*2\nWRITE(A,s)\nREAD(B, t)\nt := t+100\nWRITE(B,t)\nREAD(B,s)\ns := s*2\nWRITE(B,s)"}, {"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0017", "lecture_id": "20-Trxn-Serializability", "text": "If all transactions are well-formed and two-phase, then any schedule in which conflicting locks are never granted ensures serializability"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0007", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n- Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0015", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0023", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n-  Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0006"}, "gap_lectures": -2}}}
{"A": {"name": "SERIALIZABILITY", "role": "NA"}, "B": {"name": "TWO_PHASED_LOCKING", "role": "NA"}, "relation": "depends_on", "justification": "Two-Phased Locking is a method that ensures serializability, implying that understanding Two-Phased Locking is a prerequisite for understanding serializability.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0005", "lecture_id": "20-Trxn-Serializability", "text": "A schedule is serializable if it is equivalent to a serial schedule.\nFinal state must be the same as the state produced by one of the serial schedules.\nT1\nT2\nREAD(A, t)\nt := t+100\nWRITE(A, t)\nREAD(A, s)\ns := s*2\nWRITE(A,s)\nREAD(B, t)\nt := t+100\nWRITE(B,t)\nREAD(B,s)\ns := s*2\nWRITE(B,s)"}, {"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0017", "lecture_id": "20-Trxn-Serializability", "text": "If all transactions are well-formed and two-phase, then any schedule in which conflicting locks are never granted ensures serializability"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0007", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n- Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0015", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0016", "lecture_id": "20-Trxn-Serializability", "text": "A transaction is well-formed if it acquires at least a shared lock on Q before reading Q or an exclusive lock on Q before writing Q and doesn't release the lock until the action is performed\nA transaction is two-phased if it never acquires a lock after unlocking one\n-  There are two phases:\n-  a growing phase in which the transaction acquires locks\n-  a shrinking phase in which locks are released"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0006"}, "gap_lectures": -2}}}
{"A": {"name": "SERIALIZABILITY", "role": "NA"}, "B": {"name": "WRITE_OPERATION", "role": "NA"}, "relation": null, "justification": "The provided evidence does not establish a clear 'depends_on' or 'part_of' relationship between SERIALIZABILITY and WRITE_OPERATION.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0005", "lecture_id": "20-Trxn-Serializability", "text": "A schedule is serializable if it is equivalent to a serial schedule.\nFinal state must be the same as the state produced by one of the serial schedules.\nT1\nT2\nREAD(A, t)\nt := t+100\nWRITE(A, t)\nREAD(A, s)\ns := s*2\nWRITE(A,s)\nREAD(B, t)\nt := t+100\nWRITE(B,t)\nREAD(B,s)\ns := s*2\nWRITE(B,s)"}, {"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0017", "lecture_id": "20-Trxn-Serializability", "text": "If all transactions are well-formed and two-phase, then any schedule in which conflicting locks are never granted ensures serializability"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0014", "lecture_id": "20-Trxn-Serializability", "text": "Two schedules S1 and S2 are view equivalent if:\n- If ௜ reads an initial value of A in S1, then ௜ reads the initial value of A in S2\n- If ௜ reads a value of A written by ௝ in S1, then ௜ reads a value of A written by ௝ in S2\n- If ௜ writes the final value of A in S1, then ௜ writes the final value of A in S2\nA schedule is view serializable if it is view-equivalent to a serial schedule"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0004"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0006"}, "gap_lectures": -2}}}
{"A": {"name": "SERIALIZABLE_SCHEDULES", "role": "NA"}, "B": {"name": "SERIAL_SCHEDULE", "role": "NA"}, "relation": "depends_on", "justification": "SERIALIZABLE_SCHEDULES depend on SERIAL_SCHEDULE as the definition of serializability is based on the equivalence to a serial schedule.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0007", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n- Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0015", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0023", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n-  Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0005", "lecture_id": "20-Trxn-Serializability", "text": "A schedule is serializable if it is equivalent to a serial schedule.\nFinal state must be the same as the state produced by one of the serial schedules.\nT1\nT2\nREAD(A, t)\nt := t+100\nWRITE(A, t)\nREAD(A, s)\ns := s*2\nWRITE(A,s)\nREAD(B, t)\nt := t+100\nWRITE(B,t)\nREAD(B,s)\ns := s*2\nWRITE(B,s)"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0013", "lecture_id": "20-Trxn-Serializability", "text": "Is this schedule conflict-serializable?\nIn both schedules, database is in the same state:\nA written by T2 and B written by T3\nBoth schedules are equivalent\nBut not conflict-equivalent\nA schedule is view serializable if it is view-equivalent to a serial schedule\nW(A), T2 = . W(A), T3 = . , T2 = W(A). , T3 = . , T2 = W(B). , T3 = . W(B), T2 = . W(B), T3 = . , T2 = . , T3 = W(B). T1, T2 = T2. T1, T3 = T3. W(A), T2 = . W(A), T3 = . W(B), T2 = . W(B), T3 = . , T2 = W(A). , T3 = . , T2 = W(B). , T3 = . , T2 = . , T3 = W(B)"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0014", "lecture_id": "20-Trxn-Serializability", "text": "Two schedules S1 and S2 are view equivalent if:\n- If ௜ reads an initial value of A in S1, then ௜ reads the initial value of A in S2\n- If ௜ reads a value of A written by ௝ in S1, then ௜ reads a value of A written by ௝ in S2\n- If ௜ writes the final value of A in S1, then ௜ writes the final value of A in S2\nA schedule is view serializable if it is view-equivalent to a serial schedule"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0005"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "gap_lectures": 0}}}
{"A": {"name": "SERIALIZABLE_SCHEDULES", "role": "NA"}, "B": {"name": "TRANSACTION_MANAGEMENT", "role": "NA"}, "relation": "depends_on", "justification": "Serializable schedules are a specific concept within transaction management, requiring an understanding of transaction management principles such as two-phase locking.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0007", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n- Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0015", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0023", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n-  Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0017", "lecture_id": "20-Trxn-Serializability", "text": "If all transactions are well-formed and two-phase, then any schedule in which conflicting locks are never granted ensures serializability"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0001"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "gap_lectures": 2}}}
{"A": {"name": "SERIALIZABLE_SCHEDULES", "role": "NA"}, "B": {"name": "WRITE_OPERATION", "role": "NA"}, "relation": null, "justification": "There is no clear evidence that SERIALIZABLE_SCHEDULES depends_on or part_of WRITE_OPERATION based on the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0007", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n- Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0015", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0023", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n-  Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0014", "lecture_id": "20-Trxn-Serializability", "text": "Two schedules S1 and S2 are view equivalent if:\n- If ௜ reads an initial value of A in S1, then ௜ reads the initial value of A in S2\n- If ௜ reads a value of A written by ௝ in S1, then ௜ reads a value of A written by ௝ in S2\n- If ௜ writes the final value of A in S1, then ௜ writes the final value of A in S2\nA schedule is view serializable if it is view-equivalent to a serial schedule"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0004"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "gap_lectures": 0}}}
{"A": {"name": "SERIAL_SCHEDULE", "role": "NA"}, "B": {"name": "SERIAL_SCHEDULES", "role": "NA"}, "relation": "part_of", "justification": "The evidence shows that 'SERIAL_SCHEDULE' is discussed as a specific instance within the broader concept of 'SERIAL_SCHEDULES'.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0005", "lecture_id": "20-Trxn-Serializability", "text": "A schedule is serializable if it is equivalent to a serial schedule.\nFinal state must be the same as the state produced by one of the serial schedules.\nT1\nT2\nREAD(A, t)\nt := t+100\nWRITE(A, t)\nREAD(A, s)\ns := s*2\nWRITE(A,s)\nREAD(B, t)\nt := t+100\nWRITE(B,t)\nREAD(B,s)\ns := s*2\nWRITE(B,s)"}, {"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0013", "lecture_id": "20-Trxn-Serializability", "text": "Is this schedule conflict-serializable?\nIn both schedules, database is in the same state:\nA written by T2 and B written by T3\nBoth schedules are equivalent\nBut not conflict-equivalent\nA schedule is view serializable if it is view-equivalent to a serial schedule\nW(A), T2 = . W(A), T3 = . , T2 = W(A). , T3 = . , T2 = W(B). , T3 = . W(B), T2 = . W(B), T3 = . , T2 = . , T3 = W(B). T1, T2 = T2. T1, T3 = T3. W(A), T2 = . W(A), T3 = . W(B), T2 = . W(B), T3 = . , T2 = W(A). , T3 = . , T2 = W(B). , T3 = . , T2 = . , T3 = W(B)"}, {"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0014", "lecture_id": "20-Trxn-Serializability", "text": "Two schedules S1 and S2 are view equivalent if:\n- If ௜ reads an initial value of A in S1, then ௜ reads the initial value of A in S2\n- If ௜ reads a value of A written by ௝ in S1, then ௜ reads a value of A written by ௝ in S2\n- If ௜ writes the final value of A in S1, then ௜ writes the final value of A in S2\nA schedule is view serializable if it is view-equivalent to a serial schedule"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0001", "lecture_id": "20-Trxn-Serializability", "text": "- Describe the theory of serializability, including Serial, Serializable, Conflict-Serializable, and  View-Serializable schedules.\n- Use the Precedence Graph Algorithm to test for conflictserializability.\n- Describe how commercial database systems use twophase locking to guarantee serializability of concurrent transactions."}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0007", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n- Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0015", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0001"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0005"}, "gap_lectures": 0}}}
{"A": {"name": "SERIAL_SCHEDULE", "role": "NA"}, "B": {"name": "STRICT_TWO_PHASED_LOCKING", "role": "NA"}, "relation": null, "justification": "There is no clear evidence that either concept directly depends on or is part of the other. Both concepts are mentioned in the context of serializability but do not establish a clear dependency or part_of relationship.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0005", "lecture_id": "20-Trxn-Serializability", "text": "A schedule is serializable if it is equivalent to a serial schedule.\nFinal state must be the same as the state produced by one of the serial schedules.\nT1\nT2\nREAD(A, t)\nt := t+100\nWRITE(A, t)\nREAD(A, s)\ns := s*2\nWRITE(A,s)\nREAD(B, t)\nt := t+100\nWRITE(B,t)\nREAD(B,s)\ns := s*2\nWRITE(B,s)"}, {"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0013", "lecture_id": "20-Trxn-Serializability", "text": "Is this schedule conflict-serializable?\nIn both schedules, database is in the same state:\nA written by T2 and B written by T3\nBoth schedules are equivalent\nBut not conflict-equivalent\nA schedule is view serializable if it is view-equivalent to a serial schedule\nW(A), T2 = . W(A), T3 = . , T2 = W(A). , T3 = . , T2 = W(B). , T3 = . W(B), T2 = . W(B), T3 = . , T2 = . , T3 = W(B). T1, T2 = T2. T1, T3 = T3. W(A), T2 = . W(A), T3 = . W(B), T2 = . W(B), T3 = . , T2 = W(A). , T3 = . , T2 = W(B). , T3 = . , T2 = . , T3 = W(B)"}, {"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0014", "lecture_id": "20-Trxn-Serializability", "text": "Two schedules S1 and S2 are view equivalent if:\n- If ௜ reads an initial value of A in S1, then ௜ reads the initial value of A in S2\n- If ௜ reads a value of A written by ௝ in S1, then ௜ reads a value of A written by ௝ in S2\n- If ௜ writes the final value of A in S1, then ௜ writes the final value of A in S2\nA schedule is view serializable if it is view-equivalent to a serial schedule"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0007", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n- Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0015", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0023", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n-  Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0005"}, "gap_lectures": 0}}}
{"A": {"name": "SERIAL_SCHEDULE", "role": "NA"}, "B": {"name": "THEORY_OF_SERIALIZABILITY", "role": "NA"}, "relation": "part_of", "justification": "SERIAL_SCHEDULE is a specific type of schedule that is discussed within the broader context of THEORY_OF_SERIALIZABILITY.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0005", "lecture_id": "20-Trxn-Serializability", "text": "A schedule is serializable if it is equivalent to a serial schedule.\nFinal state must be the same as the state produced by one of the serial schedules.\nT1\nT2\nREAD(A, t)\nt := t+100\nWRITE(A, t)\nREAD(A, s)\ns := s*2\nWRITE(A,s)\nREAD(B, t)\nt := t+100\nWRITE(B,t)\nREAD(B,s)\ns := s*2\nWRITE(B,s)"}, {"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0013", "lecture_id": "20-Trxn-Serializability", "text": "Is this schedule conflict-serializable?\nIn both schedules, database is in the same state:\nA written by T2 and B written by T3\nBoth schedules are equivalent\nBut not conflict-equivalent\nA schedule is view serializable if it is view-equivalent to a serial schedule\nW(A), T2 = . W(A), T3 = . , T2 = W(A). , T3 = . , T2 = W(B). , T3 = . W(B), T2 = . W(B), T3 = . , T2 = . , T3 = W(B). T1, T2 = T2. T1, T3 = T3. W(A), T2 = . W(A), T3 = . W(B), T2 = . W(B), T3 = . , T2 = W(A). , T3 = . , T2 = W(B). , T3 = . , T2 = . , T3 = W(B)"}, {"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0014", "lecture_id": "20-Trxn-Serializability", "text": "Two schedules S1 and S2 are view equivalent if:\n- If ௜ reads an initial value of A in S1, then ௜ reads the initial value of A in S2\n- If ௜ reads a value of A written by ௝ in S1, then ௜ reads a value of A written by ௝ in S2\n- If ௜ writes the final value of A in S1, then ௜ writes the final value of A in S2\nA schedule is view serializable if it is view-equivalent to a serial schedule"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0007", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n- Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0015", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0023", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n-  Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0005"}, "gap_lectures": 0}}}
{"A": {"name": "SERIAL_SCHEDULE", "role": "NA"}, "B": {"name": "TRANSACTION_MANAGEMENT", "role": "NA"}, "relation": "depends_on", "justification": "The concept of a serial schedule is introduced in the context of transaction management, specifically in the discussion of serializability, which is a key aspect of transaction management.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0005", "lecture_id": "20-Trxn-Serializability", "text": "A schedule is serializable if it is equivalent to a serial schedule.\nFinal state must be the same as the state produced by one of the serial schedules.\nT1\nT2\nREAD(A, t)\nt := t+100\nWRITE(A, t)\nREAD(A, s)\ns := s*2\nWRITE(A,s)\nREAD(B, t)\nt := t+100\nWRITE(B,t)\nREAD(B,s)\ns := s*2\nWRITE(B,s)"}, {"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0013", "lecture_id": "20-Trxn-Serializability", "text": "Is this schedule conflict-serializable?\nIn both schedules, database is in the same state:\nA written by T2 and B written by T3\nBoth schedules are equivalent\nBut not conflict-equivalent\nA schedule is view serializable if it is view-equivalent to a serial schedule\nW(A), T2 = . W(A), T3 = . , T2 = W(A). , T3 = . , T2 = W(B). , T3 = . W(B), T2 = . W(B), T3 = . , T2 = . , T3 = W(B). T1, T2 = T2. T1, T3 = T3. W(A), T2 = . W(A), T3 = . W(B), T2 = . W(B), T3 = . , T2 = W(A). , T3 = . , T2 = W(B). , T3 = . , T2 = . , T3 = W(B)"}, {"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0014", "lecture_id": "20-Trxn-Serializability", "text": "Two schedules S1 and S2 are view equivalent if:\n- If ௜ reads an initial value of A in S1, then ௜ reads the initial value of A in S2\n- If ௜ reads a value of A written by ௝ in S1, then ௜ reads a value of A written by ௝ in S2\n- If ௜ writes the final value of A in S1, then ௜ writes the final value of A in S2\nA schedule is view serializable if it is view-equivalent to a serial schedule"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0017", "lecture_id": "20-Trxn-Serializability", "text": "If all transactions are well-formed and two-phase, then any schedule in which conflicting locks are never granted ensures serializability"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0001"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0005"}, "gap_lectures": 2}}}
{"A": {"name": "SERIAL_SCHEDULE", "role": "NA"}, "B": {"name": "TWO_PHASED_LOCKING", "role": "NA"}, "relation": null, "justification": "There is no clear evidence that either 'SERIAL_SCHEDULE' depends on 'TWO_PHASED_LOCKING' or vice versa. The provided evidence does not establish a clear prerequisite or part_of relationship between the two concepts.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0005", "lecture_id": "20-Trxn-Serializability", "text": "A schedule is serializable if it is equivalent to a serial schedule.\nFinal state must be the same as the state produced by one of the serial schedules.\nT1\nT2\nREAD(A, t)\nt := t+100\nWRITE(A, t)\nREAD(A, s)\ns := s*2\nWRITE(A,s)\nREAD(B, t)\nt := t+100\nWRITE(B,t)\nREAD(B,s)\ns := s*2\nWRITE(B,s)"}, {"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0013", "lecture_id": "20-Trxn-Serializability", "text": "Is this schedule conflict-serializable?\nIn both schedules, database is in the same state:\nA written by T2 and B written by T3\nBoth schedules are equivalent\nBut not conflict-equivalent\nA schedule is view serializable if it is view-equivalent to a serial schedule\nW(A), T2 = . W(A), T3 = . , T2 = W(A). , T3 = . , T2 = W(B). , T3 = . W(B), T2 = . W(B), T3 = . , T2 = . , T3 = W(B). T1, T2 = T2. T1, T3 = T3. W(A), T2 = . W(A), T3 = . W(B), T2 = . W(B), T3 = . , T2 = W(A). , T3 = . , T2 = W(B). , T3 = . , T2 = . , T3 = W(B)"}, {"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0014", "lecture_id": "20-Trxn-Serializability", "text": "Two schedules S1 and S2 are view equivalent if:\n- If ௜ reads an initial value of A in S1, then ௜ reads the initial value of A in S2\n- If ௜ reads a value of A written by ௝ in S1, then ௜ reads a value of A written by ௝ in S2\n- If ௜ writes the final value of A in S1, then ௜ writes the final value of A in S2\nA schedule is view serializable if it is view-equivalent to a serial schedule"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0007", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n- Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0015", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0016", "lecture_id": "20-Trxn-Serializability", "text": "A transaction is well-formed if it acquires at least a shared lock on Q before reading Q or an exclusive lock on Q before writing Q and doesn't release the lock until the action is performed\nA transaction is two-phased if it never acquires a lock after unlocking one\n-  There are two phases:\n-  a growing phase in which the transaction acquires locks\n-  a shrinking phase in which locks are released"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0005"}, "gap_lectures": 0}}}
{"A": {"name": "SERIAL_SCHEDULES", "role": "NA"}, "B": {"name": "TRANSACTION_MANAGEMENT", "role": "NA"}, "relation": "depends_on", "justification": "Serial schedules are a specific type of schedule that is discussed within the context of transaction management, indicating that understanding transaction management is a prerequisite for understanding serial schedules.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0001", "lecture_id": "20-Trxn-Serializability", "text": "- Describe the theory of serializability, including Serial, Serializable, Conflict-Serializable, and  View-Serializable schedules.\n- Use the Precedence Graph Algorithm to test for conflictserializability.\n- Describe how commercial database systems use twophase locking to guarantee serializability of concurrent transactions."}, {"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0007", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n- Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0015", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0017", "lecture_id": "20-Trxn-Serializability", "text": "If all transactions are well-formed and two-phase, then any schedule in which conflicting locks are never granted ensures serializability"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0001"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0001"}, "gap_lectures": 2}}}
{"A": {"name": "SERIAL_SCHEDULES", "role": "NA"}, "B": {"name": "WRITE_OPERATION", "role": "NA"}, "relation": null, "justification": "There is no clear evidence that either 'SERIAL_SCHEDULES' depends on 'WRITE_OPERATION' or vice versa. The provided evidence does not establish a clear prerequisite or part-of relationship between the two concepts.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0001", "lecture_id": "20-Trxn-Serializability", "text": "- Describe the theory of serializability, including Serial, Serializable, Conflict-Serializable, and  View-Serializable schedules.\n- Use the Precedence Graph Algorithm to test for conflictserializability.\n- Describe how commercial database systems use twophase locking to guarantee serializability of concurrent transactions."}, {"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0007", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n- Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0015", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0014", "lecture_id": "20-Trxn-Serializability", "text": "Two schedules S1 and S2 are view equivalent if:\n- If ௜ reads an initial value of A in S1, then ௜ reads the initial value of A in S2\n- If ௜ reads a value of A written by ௝ in S1, then ௜ reads a value of A written by ௝ in S2\n- If ௜ writes the final value of A in S1, then ௜ writes the final value of A in S2\nA schedule is view serializable if it is view-equivalent to a serial schedule"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0004"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0001"}, "gap_lectures": 0}}}
{"A": {"name": "SET_OPERATIONS", "role": "NA"}, "B": {"name": "SET_SEMANTICS", "role": "NA"}, "relation": "depends_on", "justification": "SET_SEMANTICS provides the underlying rules and laws that govern the behavior of SET_OPERATIONS, indicating that understanding SET_SEMANTICS is a prerequisite for comprehending SET_OPERATIONS.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 6, "label_hint": "laws-and-involving-involves-attributes", "chunk_id": "23-Rule-basedOpt__0005", "lecture_id": "23-Rule-basedOpt", "text": "-  C (R - S) =  C (R) - S\n- When is this true?\n-  C (R U S) =  C (R) U  C (S)\n-  C (R ∩ S)  =  C (R) ∩ S\nI"}, {"source": "cluster_B", "cluster_id": 6, "label_hint": "laws-and-involving-involves-attributes", "chunk_id": "23-Rule-basedOpt__0004", "lecture_id": "23-Rule-basedOpt", "text": "Hold independent of set or bag..\n- Commutative and Associative Laws\n- R U S = S U R,  R U (S U T) = (R U S) U T\n- R ∩ S = S ∩ R,  R ∩ (S ∩ T) = (R ∩ S) ∩ T\n- R S = S R,  R (S T) = (R S) T\n- Distributive Laws\n- R (S U T)  =  (R S) U (R T)\n- Laws involving selection (set semantics):\n-  C AND C' (R) =  C (  C' (R)) =  C (R) ∩  C' (R)\n-  C OR C' (R) =  C (R) U  C' (R)\n-  C (R S) =  C (R) S\n- When is this true?\n- Certainly true when C involves only attributes of R\n- What if it involves attributes of R and S?\n- For example: R(X, Y), S(Y, Z)\n- Say: Y = 3; X = 3 ^ Z = 5\nI"}, {"source": "cluster_B", "cluster_id": 6, "label_hint": "laws-and-involving-involves-attributes", "chunk_id": "23-Rule-basedOpt__0006", "lecture_id": "23-Rule-basedOpt", "text": "- Example:  R(A, B, C, D), S(E, F, G)\n-  F=3 (R D=E S) =                                     ?\n-  A=5 AND G=9 (R D=E S) =                         ?\n- Simplify as much as possible by pushing down predicates\n- As close to the relations as possible\nI\n- Example:  R(A, B, C, D), S(E, F, G)\n-  F=3 (R D=E S) = R D=E (  F=3 (S))\n-  A=5 AND G=9 (R D=E S) =   (  A=5 (R)) D=E (  G=9 (S))\nI ILLINOIS\n- Laws involving selection (set semantics):\n-  C AND C' (R) =  C (  C' (R)) =  C (R) ∩  C' (R)\n-  C OR C' (R) =  C (R) U  C' (R)  what about this one?\n-  C (R S) =  C (R) S\n- Only when C involves only attributes of R\n-  C (R - S) =  C (R) - S\n-  C (R U S) =  C (R) U  C (S)\n-  C (R ∩ S)  =  C (R) ∩ S\nExercise: Think about which\nof these hold for bag semantics….\n© A. Alawini\n工\n- Laws involving projections\n-  M(  N (R)) =  M ∩ N (R)\n-  M(R S) =  N (  P (R)  Q (S))\n- Where N, P, Q are appropriate subsets of attributes of M that are 'needed afterwards'\n- Example R(A,B,C,D), S(E, F, G)\n-  A,B,G (R D=E S) =  ? (  ? (R)  ? (S))"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 14, "lecture_id": "23-Rule-basedOpt", "chunk_id": "23-Rule-basedOpt__0004"}, "A_first_introduced_at": {"lecture_index": 12, "lecture_id": "21-RA", "chunk_id": "21-RA__0011"}, "gap_lectures": -2}}}
{"A": {"name": "STORAGE_STRUCTURES", "role": "NA"}, "B": {"name": "TRANSACTIONS", "role": "NA"}, "relation": null, "justification": "There is no clear evidence in the provided text that supports a 'depends_on' or 'part_of' relationship between STORAGE_STRUCTURES and TRANSACTIONS.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "19-Trxn-Mgmt__0001", "lecture_id": "19-Trxn-Mgmt", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}, {"source": "cluster_A", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "20-Trxn-Serializability__0000", "lecture_id": "20-Trxn-Serializability", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}, {"source": "cluster_A", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "5- SQL4-AggGrpViews__0000", "lecture_id": "5- SQL4-AggGrpViews", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems\n工"}, {"source": "cluster_B", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "10-Neo4J-Part 1__0000", "lecture_id": "10-Neo4J-Part 1", "text": "University of Illinois at Urbana -Champaign CS411: Database Systems"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0000"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0001"}, "gap_lectures": 8}}}
{"A": {"name": "STRICT_TWO_PHASED_LOCKING", "role": "NA"}, "B": {"name": "TRANSACTION_MANAGEMENT", "role": "NA"}, "relation": "part_of", "justification": "Strict two-phased locking is a specific technique used within transaction management to ensure serializability.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0007", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n- Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0015", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0023", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n-  Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0017", "lecture_id": "20-Trxn-Serializability", "text": "If all transactions are well-formed and two-phase, then any schedule in which conflicting locks are never granted ensures serializability"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0001"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "gap_lectures": 2}}}
{"A": {"name": "STRICT_TWO_PHASED_LOCKING", "role": "NA"}, "B": {"name": "WRITE_OPERATION", "role": "NA"}, "relation": "depends_on", "justification": "Strict two-phased locking (S2PL) is a protocol that imposes constraints on write operations to ensure serializability, indicating that understanding write operations is a prerequisite for understanding S2PL.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0007", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n- Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0015", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0023", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n-  Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0014", "lecture_id": "20-Trxn-Serializability", "text": "Two schedules S1 and S2 are view equivalent if:\n- If ௜ reads an initial value of A in S1, then ௜ reads the initial value of A in S2\n- If ௜ reads a value of A written by ௝ in S1, then ௜ reads a value of A written by ௝ in S2\n- If ௜ writes the final value of A in S1, then ௜ writes the final value of A in S2\nA schedule is view serializable if it is view-equivalent to a serial schedule"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0004"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "gap_lectures": 0}}}
{"A": {"name": "THEORY_OF_SERIALIZABILITY", "role": "NA"}, "B": {"name": "TRANSACTION_MANAGEMENT", "role": "NA"}, "relation": "depends_on", "justification": "The evidence shows that the theory of serializability is discussed in the context of ensuring serializability in schedules, which is a concept within transaction management. Therefore, the theory of serializability depends on the understanding of transaction management.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0007", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n- Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0015", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0023", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n-  Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0017", "lecture_id": "20-Trxn-Serializability", "text": "If all transactions are well-formed and two-phase, then any schedule in which conflicting locks are never granted ensures serializability"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0001"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "gap_lectures": 2}}}
{"A": {"name": "THEORY_OF_SERIALIZABILITY", "role": "NA"}, "B": {"name": "WRITE_OPERATION", "role": "NA"}, "relation": null, "justification": "There is no clear evidence that THEORY_OF_SERIALIZABILITY depends on or is part of WRITE_OPERATION, or vice versa, based on the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0007", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n- Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0015", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0023", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n-  Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0014", "lecture_id": "20-Trxn-Serializability", "text": "Two schedules S1 and S2 are view equivalent if:\n- If ௜ reads an initial value of A in S1, then ௜ reads the initial value of A in S2\n- If ௜ reads a value of A written by ௝ in S1, then ௜ reads a value of A written by ௝ in S2\n- If ௜ writes the final value of A in S1, then ௜ writes the final value of A in S2\nA schedule is view serializable if it is view-equivalent to a serial schedule"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0004"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "gap_lectures": 0}}}
{"A": {"name": "TRANSACTION", "role": "NA"}, "B": {"name": "TRANSACTION_ISOLATION", "role": "NA"}, "relation": "depends_on", "justification": "Transaction isolation is a property that defines how transactions interact with each other, which depends on the concept of transactions.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 34, "label_hint": "t1-and-t2-t3-write", "chunk_id": "20-Trxn-Serializability__0019", "lecture_id": "20-Trxn-Serializability", "text": "T1:        R(A)   W(A)\nR(B)    W(B)\nT2:\nR(A)     W(A)\nR(B)   W(B)"}, {"source": "cluster_B", "cluster_id": 34, "label_hint": "t1-and-t2-t3-write", "chunk_id": "20-Trxn-Serializability__0020", "lecture_id": "20-Trxn-Serializability", "text": "T1:, 1 = R(A),. T1:, 2 = R(C). T1:, 3 = W(B). T2: T3:, 1 = R(B). T2: T3:, 2 = . T2: T3:, 3 = R(B)\n```\nS1(A); R1(A); S2(B) R2(B); S3(A); R3(A); X2(C); W2(C); REL2(C); S1(C); R1(C); R2(B); REL2(B); X1(B); W1(B); REL1(A,B,C); S3(B); R3(B); REL3(A,B);\n```"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 2, "reason": "A and B appear in different chunks within 2 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0013"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0022"}, "gap_lectures": 0}}}
{"A": {"name": "TRANSACTION", "role": "NA"}, "B": {"name": "WRITE_OPERATION", "role": "NA"}, "relation": "depends_on", "justification": "A transaction involves a series of operations, including write operations, which are essential for understanding the behavior and properties of transactions.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 34, "label_hint": "t1-and-t2-t3-write", "chunk_id": "20-Trxn-Serializability__0019", "lecture_id": "20-Trxn-Serializability", "text": "T1:        R(A)   W(A)\nR(B)    W(B)\nT2:\nR(A)     W(A)\nR(B)   W(B)"}, {"source": "cluster_B", "cluster_id": 34, "label_hint": "t1-and-t2-t3-write", "chunk_id": "20-Trxn-Serializability__0020", "lecture_id": "20-Trxn-Serializability", "text": "T1:, 1 = R(A),. T1:, 2 = R(C). T1:, 3 = W(B). T2: T3:, 1 = R(B). T2: T3:, 2 = . T2: T3:, 3 = R(B)\n```\nS1(A); R1(A); S2(B) R2(B); S3(A); R3(A); X2(C); W2(C); REL2(C); S1(C); R1(C); R2(B); REL2(B); X1(B); W1(B); REL1(A,B,C); S3(B); R3(B); REL3(A,B);\n```"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 2, "reason": "A and B appear in different chunks within 2 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0004"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0022"}, "gap_lectures": -2}}}
{"A": {"name": "TRANSACTIONS", "role": "NA"}, "B": {"name": "TRANSACTION_ISOLATION", "role": "NA"}, "relation": "depends_on", "justification": "Transactions are a fundamental concept that must be understood before the concept of transaction isolation can be introduced and explained.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 82, "label_hint": "isolation-and-transactions-item-lock", "chunk_id": "20-Trxn-Serializability__0029", "lecture_id": "20-Trxn-Serializability", "text": "- Transactions are all-or-nothing units of work guaranteed despite concurrency or failures in the system.\n- Theoretically, the 'correct' execution of transactions is serializable (i.e. equivalent to some serial execution).\n- Practically, this may adversely affect throughput  isolation levels.\n- With isolation levels, users can specify the level of 'incorrectness' they are willing to tolerate."}, {"source": "cluster_B", "cluster_id": 82, "label_hint": "isolation-and-transactions-item-lock", "chunk_id": "19-Trxn-Mgmt__0014", "lecture_id": "19-Trxn-Mgmt", "text": "- Transactions are isolated from the effects of other, concurrently executing, transactions."}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0013"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0000"}, "gap_lectures": -8}}}
{"A": {"name": "TRANSACTIONS", "role": "NA"}, "B": {"name": "TRANSACTION_MANAGEMENT", "role": "NA"}, "relation": "depends_on", "justification": "Based on the evidence, 'TRANSACTIONS' appears to be a foundational concept that is likely required before understanding 'TRANSACTION_MANAGEMENT'. The temporal order of introduction also supports this, with 'TRANSACTIONS' introduced earlier in the course.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "10-Neo4J-Part 1__0000", "lecture_id": "10-Neo4J-Part 1", "text": "University of Illinois at Urbana -Champaign CS411: Database Systems"}, {"source": "cluster_B", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "19-Trxn-Mgmt__0001", "lecture_id": "19-Trxn-Mgmt", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}, {"source": "cluster_B", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "20-Trxn-Serializability__0000", "lecture_id": "20-Trxn-Serializability", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems"}, {"source": "cluster_B", "cluster_id": 74, "label_hint": "champaign-and-cs411-illinois-urbana", "chunk_id": "5- SQL4-AggGrpViews__0000", "lecture_id": "5- SQL4-AggGrpViews", "text": "University of Illinois at Urbana-Champaign CS411: Database Systems\n工"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 2, "reason": "A and B appear in different chunks within 2 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0001"}, "A_first_introduced_at": {"lecture_index": 1, "lecture_id": "10-Neo4J-Part 1", "chunk_id": "10-Neo4J-Part 1__0000"}, "gap_lectures": -8}}}
{"A": {"name": "TRANSACTION_ISOLATION", "role": "NA"}, "B": {"name": "TRANSACTION_MANAGEMENT", "role": "NA"}, "relation": "part_of", "justification": "Transaction isolation is a specific aspect or component of transaction management, as it deals with the isolation of transactions from each other, which is a key part of managing transactions.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 82, "label_hint": "isolation-and-transactions-item-lock", "chunk_id": "19-Trxn-Mgmt__0014", "lecture_id": "19-Trxn-Mgmt", "text": "- Transactions are isolated from the effects of other, concurrently executing, transactions."}, {"source": "cluster_B", "cluster_id": 82, "label_hint": "isolation-and-transactions-item-lock", "chunk_id": "19-Trxn-Mgmt__0032", "lecture_id": "19-Trxn-Mgmt", "text": "- One approach - use locking at some level (tuple, page, table, etc.):\n- each data item is either locked (in some mode, e.g. shared or exclusive) or is available (no lock)\n- an action on a data item can be executed if the transaction holds an appropriate lock\n- consider granularity of locks - how big of an item to lock\n- Larger granularity = fewer locking operations but more contention!"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0001"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0013"}, "gap_lectures": 0}}}
{"A": {"name": "TRANSACTION_ISOLATION", "role": "NA"}, "B": {"name": "WRITE", "role": "NA"}, "relation": null, "justification": "There is no clear indication that TRANSACTION_ISOLATION depends on WRITE or that WRITE is part of TRANSACTION_ISOLATION based on the provided evidence.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 34, "label_hint": "t1-and-t2-t3-write", "chunk_id": "20-Trxn-Serializability__0020", "lecture_id": "20-Trxn-Serializability", "text": "T1:, 1 = R(A),. T1:, 2 = R(C). T1:, 3 = W(B). T2: T3:, 1 = R(B). T2: T3:, 2 = . T2: T3:, 3 = R(B)\n```\nS1(A); R1(A); S2(B) R2(B); S3(A); R3(A); X2(C); W2(C); REL2(C); S1(C); R1(C); R2(B); REL2(B); X1(B); W1(B); REL1(A,B,C); S3(B); R3(B); REL3(A,B);\n```"}, {"source": "cluster_B", "cluster_id": 34, "label_hint": "t1-and-t2-t3-write", "chunk_id": "20-Trxn-Serializability__0019", "lecture_id": "20-Trxn-Serializability", "text": "T1:        R(A)   W(A)\nR(B)    W(B)\nT2:\nR(A)     W(A)\nR(B)   W(B)"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 2, "reason": "A and B appear in different chunks within 2 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0019"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0013"}, "gap_lectures": -2}}}
{"A": {"name": "TRANSACTION_MANAGEMENT", "role": "NA"}, "B": {"name": "TWO_PHASED_LOCKING", "role": "NA"}, "relation": "depends_on", "justification": "Two-Phased Locking is a specific technique used within transaction management to ensure serializability, implying that understanding Two-Phased Locking is necessary for a comprehensive grasp of transaction management.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0017", "lecture_id": "20-Trxn-Serializability", "text": "If all transactions are well-formed and two-phase, then any schedule in which conflicting locks are never granted ensures serializability"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0007", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n- Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0015", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0016", "lecture_id": "20-Trxn-Serializability", "text": "A transaction is well-formed if it acquires at least a shared lock on Q before reading Q or an exclusive lock on Q before writing Q and doesn't release the lock until the action is performed\nA transaction is two-phased if it never acquires a lock after unlocking one\n-  There are two phases:\n-  a growing phase in which the transaction acquires locks\n-  a shrinking phase in which locks are released"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0001"}, "gap_lectures": -2}}}
{"A": {"name": "TRANSACTION_MANAGEMENT", "role": "NA"}, "B": {"name": "WRITE_OPERATION", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly establish a 'depends_on' or 'part_of' relationship between TRANSACTION_MANAGEMENT and WRITE_OPERATION.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0017", "lecture_id": "20-Trxn-Serializability", "text": "If all transactions are well-formed and two-phase, then any schedule in which conflicting locks are never granted ensures serializability"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0014", "lecture_id": "20-Trxn-Serializability", "text": "Two schedules S1 and S2 are view equivalent if:\n- If ௜ reads an initial value of A in S1, then ௜ reads the initial value of A in S2\n- If ௜ reads a value of A written by ௝ in S1, then ௜ reads a value of A written by ௝ in S2\n- If ௜ writes the final value of A in S1, then ௜ writes the final value of A in S2\nA schedule is view serializable if it is view-equivalent to a serial schedule"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 3, "reason": "A and B appear in different chunks within 3 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0004"}, "A_first_introduced_at": {"lecture_index": 9, "lecture_id": "19-Trxn-Mgmt", "chunk_id": "19-Trxn-Mgmt__0001"}, "gap_lectures": -2}}}
{"A": {"name": "TWO_PHASED_LOCKING", "role": "NA"}, "B": {"name": "WRITE_OPERATION", "role": "NA"}, "relation": "depends_on", "justification": "Two-Phased Locking (A) depends on the concept of write operations (B) because it specifies the locking behavior before and after write operations to ensure transactional integrity and prevent conflicts.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0007", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n- Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0015", "lecture_id": "20-Trxn-Serializability", "text": "-  Theory of Serializability\n-  Serial and serializable schedules\n-  Conflict-Serializable schedules\n- Two-Phased Locking Theorem\n- Tw0-Phased Locking (2PL)\n- Strict two-phased locking (S2PL)"}, {"source": "cluster_A", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0016", "lecture_id": "20-Trxn-Serializability", "text": "A transaction is well-formed if it acquires at least a shared lock on Q before reading Q or an exclusive lock on Q before writing Q and doesn't release the lock until the action is performed\nA transaction is two-phased if it never acquires a lock after unlocking one\n-  There are two phases:\n-  a growing phase in which the transaction acquires locks\n-  a shrinking phase in which locks are released"}, {"source": "cluster_B", "cluster_id": 17, "label_hint": "schedule-and-serializable-schedules-t3", "chunk_id": "20-Trxn-Serializability__0014", "lecture_id": "20-Trxn-Serializability", "text": "Two schedules S1 and S2 are view equivalent if:\n- If ௜ reads an initial value of A in S1, then ௜ reads the initial value of A in S2\n- If ௜ reads a value of A written by ௝ in S1, then ௜ reads a value of A written by ௝ in S2\n- If ௜ writes the final value of A in S1, then ௜ writes the final value of A in S2\nA schedule is view serializable if it is view-equivalent to a serial schedule"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 1, "reason": "A and B appear in different chunks within 1 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0004"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0007"}, "gap_lectures": 0}}}
{"A": {"name": "WRITE", "role": "NA"}, "B": {"name": "WRITE_OPERATION", "role": "NA"}, "relation": null, "justification": "The provided evidence does not clearly establish a 'depends_on' or 'part_of' relationship between 'WRITE' and 'WRITE_OPERATION'. The terms appear in different contexts within the same lecture but do not provide sufficient information to infer a clear dependency or part-whole relationship.", "evidence_chunks": [{"source": "cluster_A", "cluster_id": 34, "label_hint": "t1-and-t2-t3-write", "chunk_id": "20-Trxn-Serializability__0019", "lecture_id": "20-Trxn-Serializability", "text": "T1:        R(A)   W(A)\nR(B)    W(B)\nT2:\nR(A)     W(A)\nR(B)   W(B)"}, {"source": "cluster_B", "cluster_id": 34, "label_hint": "t1-and-t2-t3-write", "chunk_id": "20-Trxn-Serializability__0020", "lecture_id": "20-Trxn-Serializability", "text": "T1:, 1 = R(A),. T1:, 2 = R(C). T1:, 3 = W(B). T2: T3:, 1 = R(B). T2: T3:, 2 = . T2: T3:, 3 = R(B)\n```\nS1(A); R1(A); S2(B) R2(B); S3(A); R3(A); X2(C); W2(C); REL2(C); S1(C); R1(C); R2(B); REL2(B); X1(B); W1(B); REL1(A,B,C); S3(B); R3(B); REL3(A,B);\n```"}], "_meta": {"mode": "CLUSTER_CO_OCCURRENCE", "mode_info": {"chunk_co_occurrence_count": 0, "cluster_co_occurrence_count": 2, "reason": "A and B appear in different chunks within 2 shared cluster(s)"}, "temporal_order": {"B_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0004"}, "A_first_introduced_at": {"lecture_index": 11, "lecture_id": "20-Trxn-Serializability", "chunk_id": "20-Trxn-Serializability__0019"}, "gap_lectures": 0}}}
